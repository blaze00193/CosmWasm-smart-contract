<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\n\nuse cw1_subkeys::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ContractExecMsg,\n        query: ContractQueryMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","contract.rs"],"content":"use cosmwasm_std::{\n    ensure, ensure_ne, Addr, BankMsg, Coin, CosmosMsg, Deps, DistributionMsg, Env, Order, Response,\n    StakingMsg, StdResult,\n};\nuse cw1_whitelist::contract::Cw1WhitelistContract;\nuse cw1_whitelist::whitelist;\nuse cw2::set_contract_version;\nuse cw_storage_plus::{Bound, Map};\nuse cw_utils::Expiration;\nuse sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};\nuse sylvia::{contract, schemars};\n\n#[cfg(not(feature = \"library\"))]\nuse sylvia::entry_points;\n\nuse crate::error::ContractError;\nuse crate::responses::{\n    AllAllowancesResponse, AllPermissionsResponse, AllowanceInfo, PermissionsInfo,\n};\nuse crate::state::{Allowance, Permissions};\n\npub const CONTRACT_NAME: \u0026str = env!(\"CARGO_PKG_NAME\");\npub const CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n// Default and max limits for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub struct Cw1SubkeysContract\u003c'a\u003e {\n    pub(crate) whitelist: Cw1WhitelistContract\u003c'a\u003e,\n    pub(crate) permissions: Map\u003c'static, \u0026'a Addr, Permissions\u003e,\n    pub(crate) allowances: Map\u003c'static, \u0026'a Addr, Allowance\u003e,\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_points)]\n#[contract]\n#[error(ContractError)]\n#[messages(cw1 as Cw1)]\n#[messages(whitelist as Whitelist)]\nimpl Cw1SubkeysContract\u003c'_\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            whitelist: Cw1WhitelistContract::new(),\n            permissions: Map::new(\"permissions\"),\n            allowances: Map::new(\"allowances\"),\n        }\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        mut ctx: InstantiateCtx,\n        admins: Vec\u003cString\u003e,\n        mutable: bool,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let result = self.whitelist.instantiate(ctx.branch(), admins, mutable)?;\n        set_contract_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n        Ok(result)\n    }\n\n    #[msg(exec)]\n    pub fn increase_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Coin,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(\n            self.whitelist.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender),\n            ContractError::Unauthorized\n        );\n\n        let spender = ctx.deps.api.addr_validate(\u0026spender)?;\n        ensure_ne!(ctx.info.sender, spender, ContractError::CannotSetOwnAccount);\n\n        self.allowances\n            .update(ctx.deps.storage, \u0026spender, |allow| {\n                let prev_expires = allow\n                    .as_ref()\n                    .map(|allow| allow.expires)\n                    .unwrap_or_default();\n\n                let mut allowance = allow\n                    .filter(|allow| !allow.expires.is_expired(\u0026ctx.env.block))\n                    .unwrap_or_default();\n\n                if let Some(exp) = expires {\n                    if exp.is_expired(\u0026ctx.env.block) {\n                        return Err(ContractError::SettingExpiredAllowance(exp));\n                    }\n\n                    allowance.expires = exp;\n                } else if prev_expires.is_expired(\u0026ctx.env.block) {\n                    return Err(ContractError::SettingExpiredAllowance(prev_expires));\n                }\n\n                allowance.balance += amount.clone();\n                Ok(allowance)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"increase_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"denomination\", amount.denom)\n            .add_attribute(\"amount\", amount.amount);\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    pub fn decrease_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Coin,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(\n            self.whitelist.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender),\n            ContractError::Unauthorized\n        );\n\n        let spender = ctx.deps.api.addr_validate(\u0026spender)?;\n        ensure_ne!(ctx.info.sender, spender, ContractError::CannotSetOwnAccount);\n\n        let allowance = self\n            .allowances\n            .update(ctx.deps.storage, \u0026spender, |allow| {\n                // Fail fast\n                let mut allowance = allow\n                    .filter(|allow| !allow.expires.is_expired(\u0026ctx.env.block))\n                    .ok_or(ContractError::NoAllowance)?;\n\n                if let Some(exp) = expires {\n                    if exp.is_expired(\u0026ctx.env.block) {\n                        return Err(ContractError::SettingExpiredAllowance(exp));\n                    }\n\n                    allowance.expires = exp;\n                }\n\n                // Tolerates underflows (amount bigger than balance), but fails if there are no tokens at all for the denom (report potential errors)\n                allowance.balance = allowance.balance.sub_saturating(amount.clone())?;\n\n                Ok(allowance)\n            })?;\n\n        if allowance.balance.is_empty() {\n            self.allowances.remove(ctx.deps.storage, \u0026spender);\n        }\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"decrease_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"denomination\", amount.denom)\n            .add_attribute(\"amount\", amount.amount);\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    pub fn set_permissions(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        permissions: Permissions,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(\n            self.whitelist.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender),\n            ContractError::Unauthorized\n        );\n\n        let spender = ctx.deps.api.addr_validate(\u0026spender)?;\n        ensure_ne!(ctx.info.sender, spender, ContractError::CannotSetOwnAccount);\n        self.permissions\n            .save(ctx.deps.storage, \u0026spender, \u0026permissions)?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"set_permissions\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"permissions\", permissions.to_string());\n        Ok(res)\n    }\n\n    #[msg(query)]\n    pub fn allowance(\u0026self, ctx: QueryCtx, spender: String) -\u003e StdResult\u003cAllowance\u003e {\n        // we can use unchecked here as it is a query - bad value means a miss, we never write it\n        let spender = Addr::unchecked(spender);\n        let allow = self\n            .allowances\n            .may_load(ctx.deps.storage, \u0026spender)?\n            .filter(|allow| !allow.expires.is_expired(\u0026ctx.env.block))\n            .unwrap_or_default();\n\n        Ok(allow)\n    }\n\n    #[msg(query)]\n    pub fn permissions(\u0026self, ctx: QueryCtx, spender: String) -\u003e StdResult\u003cPermissions\u003e {\n        let spender = Addr::unchecked(spender);\n        let permissions = self\n            .permissions\n            .may_load(ctx.deps.storage, \u0026spender)?\n            .unwrap_or_default();\n\n        Ok(permissions)\n    }\n\n    #[msg(query)]\n    pub fn all_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n        let limit = calc_limit(limit);\n        // we use raw addresses here....\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n        let allowances: StdResult\u003c_\u003e = self\n            .allowances\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .filter(|item| {\n                if let Ok((_, allow)) = item {\n                    !allow.expires.is_expired(\u0026ctx.env.block)\n                } else {\n                    true\n                }\n            })\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, allow)| AllowanceInfo {\n                    spender: addr,\n                    balance: allow.balance,\n                    expires: allow.expires,\n                })\n            })\n            .collect();\n\n        Ok(AllAllowancesResponse {\n            allowances: allowances?,\n        })\n    }\n\n    #[msg(query)]\n    pub fn all_permissions(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllPermissionsResponse\u003e {\n        let limit = calc_limit(limit);\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n        let permissions: StdResult\u003c_\u003e = self\n            .permissions\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, perm)| PermissionsInfo {\n                    spender: addr,\n                    permissions: perm,\n                })\n            })\n            .collect();\n\n        Ok(AllPermissionsResponse {\n            permissions: permissions?,\n        })\n    }\n\n    pub fn is_authorized(\n        \u0026self,\n        deps: Deps,\n        env: \u0026Env,\n        sender: \u0026Addr,\n        msg: \u0026CosmosMsg,\n    ) -\u003e StdResult\u003cbool\u003e {\n        if self.whitelist.is_admin(deps, sender) {\n            return Ok(true);\n        }\n\n        match msg {\n            CosmosMsg::Bank(BankMsg::Send { amount, .. }) =\u003e {\n                // now we check if there is enough allowance for this message\n                let allowance = self.allowances.may_load(deps.storage, sender)?;\n                match allowance {\n                    // if there is an allowance, we subtract the requested amount to ensure it is covered (error on underflow)\n                    Some(allow) =\u003e Ok(!allow.expires.is_expired(\u0026env.block)\n                        \u0026\u0026 (allow.balance - amount.clone()).is_ok()),\n                    None =\u003e Ok(false),\n                }\n            }\n            CosmosMsg::Staking(staking_msg) =\u003e {\n                let permissions = match self.permissions.may_load(deps.storage, sender)? {\n                    Some(permissions) =\u003e permissions,\n                    None =\u003e return Ok(false),\n                };\n\n                let delegate =\n                    matches!(staking_msg, StakingMsg::Delegate { .. } if permissions.delegate);\n                let undelegate =\n                    matches!(staking_msg, StakingMsg::Undelegate { .. } if permissions.undelegate);\n                let redelegate =\n                    matches!(staking_msg, StakingMsg::Redelegate { .. } if permissions.redelegate);\n\n                Ok(delegate || undelegate || redelegate)\n            }\n            CosmosMsg::Distribution(distribution_msg) =\u003e {\n                let permissions = match self.permissions.may_load(deps.storage, sender)? {\n                    Some(permissions) =\u003e permissions,\n                    None =\u003e return Ok(false),\n                };\n\n                let set_withdraw_addr = matches!(distribution_msg, DistributionMsg::SetWithdrawAddress { .. } if permissions.withdraw);\n                let withdraw_perm = matches!(distribution_msg, DistributionMsg::WithdrawDelegatorReward { .. } if permissions.withdraw);\n\n                Ok(set_withdraw_addr || withdraw_perm)\n            }\n            _ =\u003e Ok(false),\n        }\n    }\n}\n\nfn calc_limit(request: Option\u003cu32\u003e) -\u003e usize {\n    request.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize\n}\n","traces":[{"line":40,"address":[1259127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[686432],"length":1,"stats":{"Line":5},"fn_name":"new"},{"line":43,"address":[686446],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[686457],"length":1,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[686484],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[687535,687492,686592],"length":1,"stats":{"Line":7},"fn_name":"instantiate"},{"line":56,"address":[686656,686746,687107],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[687387,687252,687043],"length":1,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[687304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[687568,689532,689428],"length":1,"stats":{"Line":2},"fn_name":"increase_allowance"},{"line":69,"address":[687867,687774,687639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[687679,687746],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[687825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[687940,688120,687790],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[688404,688362,688266,688085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[688476,688287,688691,688355],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[688291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[798739,798813],"length":1,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[799529,799520],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":84,"address":[798941,798887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[798930,799577,799552],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":88,"address":[799306,798997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[799274,799054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[799316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[799280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[799088,799152],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[799203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[799397,799163],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[799416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[689032,689112,688949,689167,688841],"length":1,"stats":{"Line":5},"fn_name":null},{"line":104,"address":[688917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[688992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[689080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[689160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[689212],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[691541,691691,689616],"length":1,"stats":{"Line":0},"fn_name":"decrease_allowance"},{"line":119,"address":[689822,689687,689915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[689794,689727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[689873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[689988,689838,690168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[690314,690133,690452,690410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[690747,690403,690335,690524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[690339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[799694,799881,799635,799662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[800761,799651,800736],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":133,"address":[799683,799853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[799826,800118,799919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[799946,800086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[800128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[800092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[800208,800356,799977,800567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[800480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[690941,690660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[690976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[691004,691311,690947,691093,691256,691176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[691061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[691136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[691224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[691304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[691351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[693417,693520,691776],"length":1,"stats":{"Line":2},"fn_name":"set_permissions"},{"line":169,"address":[692057,691837,691964],"length":1,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[691869,691936],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[692015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[692130,692310,691980],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[692275,692456,692511,692553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[692752,692609,692472,692504],"length":1,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[692476,692688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[692661,693132,692848,692937,693020],"length":1,"stats":{"Line":10},"fn_name":null},{"line":181,"address":[692905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[692980,693063],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[693193,693395,693084],"length":1,"stats":{"Line":4},"fn_name":null},{"line":184,"address":[693201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[700657,693616,694215,726324,725413,724802,694189,702352],"length":1,"stats":{"Line":3},"fn_name":"allowance"},{"line":190,"address":[693663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[694080,693728,694009,693752,693813,693909],"length":1,"stats":{"Line":5},"fn_name":null},{"line":193,"address":[693945,693732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[693897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[694092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[694725,694240,700715,701977,725490,726274,694701,724874],"length":1,"stats":{"Line":6},"fn_name":"permissions"},{"line":202,"address":[694288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[694569,694640,694379,694355,694437],"length":1,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[694514,694359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[694658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[695593,694752],"length":1,"stats":{"Line":1},"fn_name":"all_allowances"},{"line":218,"address":[694830,694909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[694917],"length":1,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[695043,695085,694972],"length":1,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[694976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[695073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[800936,800982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[800965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[800984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[801008],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":234,"address":[801056,801070,801036,801165],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":236,"address":[801125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[801155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[695356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[695182,695462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[696425,695632],"length":1,"stats":{"Line":1},"fn_name":"all_permissions"},{"line":254,"address":[695789,695710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[695797],"length":1,"stats":{"Line":3},"fn_name":null},{"line":257,"address":[695923,695852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[695856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[801312],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":262,"address":[801367,801360,801340],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":269,"address":[696188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[696014,696294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[698448,698225,696464],"length":1,"stats":{"Line":1},"fn_name":"is_authorized"},{"line":281,"address":[696546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[696671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[696716,696621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[697613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[697790,697634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[697765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[698295,697879,698355,698005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[697960,698029,698331,698244,698374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[697859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[696767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[697244,696784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[697366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[697346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[697380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[697419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[697458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[697492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[696883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[696900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[697092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[697072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[697106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[697145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[697179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[696699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[686384],"length":1,"stats":{"Line":1},"fn_name":"calc_limit"},{"line":328,"address":[686392],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":86,"coverable":136},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","cw1.rs"],"content":"use cosmwasm_std::{ensure, Addr, Response, StdResult};\nuse cw1::{CanExecuteResp, Cw1};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw1SubkeysContract;\nuse crate::error::ContractError;\n\n#[contract]\n#[messages(cw1 as Cw1)]\nimpl Cw1 for Cw1SubkeysContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn execute(\n        \u0026self,\n        ctx: ExecCtx,\n        msgs: Vec\u003ccosmwasm_std::CosmosMsg\u003e,\n    ) -\u003e Result\u003ccosmwasm_std::Response, Self::Error\u003e {\n        let authorized: StdResult\u003c_\u003e = msgs.iter().fold(Ok(true), |acc, msg| {\n            Ok(acc? \u0026 self.is_authorized(ctx.deps.as_ref(), \u0026ctx.env, \u0026ctx.info.sender, msg)?)\n        });\n\n        ensure!(authorized?, ContractError::Unauthorized);\n\n        let res = Response::new()\n            .add_messages(msgs)\n            .add_attribute(\"action\", \"execute\")\n            .add_attribute(\"owner\", ctx.info.sender);\n        Ok(res)\n    }\n\n    #[msg(query)]\n    fn can_execute(\n        \u0026self,\n        ctx: QueryCtx,\n        sender: String,\n        msg: cosmwasm_std::CosmosMsg,\n    ) -\u003e StdResult\u003cCanExecuteResp\u003e {\n        let sender = Addr::unchecked(sender);\n\n        self.is_authorized(ctx.deps, \u0026ctx.env, \u0026sender, \u0026msg)\n            .map(|can| CanExecuteResp { can_execute: can })\n    }\n}\n","traces":[{"line":15,"address":[747350,746224,747411],"length":1,"stats":{"Line":1},"fn_name":"execute"},{"line":20,"address":[746376,746272],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[1111121,1111159,1110872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[746506,746778,746820],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[746961,746756,747085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[746930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[747053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[747138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[747504,747767,747856],"length":1,"stats":{"Line":1},"fn_name":"can_execute"},{"line":40,"address":[747557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[747744,747629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[1111216,1111232],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"}],"covered":12,"coverable":12},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse cw1_whitelist::error::ContractError as WhitelistError;\nuse cw_utils::Expiration;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Contract is frozen\")]\n    ContractFrozen,\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount,\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance,\n\n    #[error(\"Allowance already expired while setting: {0}\")]\n    SettingExpiredAllowance(Expiration),\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cWhitelistError\u003e for ContractError {\n    fn from(err: WhitelistError) -\u003e Self {\n        match err {\n            WhitelistError::Unauthorized =\u003e ContractError::Unauthorized,\n            WhitelistError::ContractFrozen =\u003e ContractError::ContractFrozen,\n            WhitelistError::Std(err) =\u003e ContractError::Std(err),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","lib.rs"],"content":"pub mod contract;\nmod cw1;\npub mod error;\n#[cfg(any(test, feature = \"tests\"))]\npub mod multitest;\npub mod responses;\npub mod state;\nmod whitelist;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","multitest","tests.rs"],"content":"use cosmwasm_std::{coin, coins, Addr};\nuse cw2::{query_contract_info, ContractVersion};\nuse cw_utils::{Expiration, NativeBalance};\nuse sylvia::multitest::App;\n\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::{CONTRACT_NAME, CONTRACT_VERSION};\n\nconst ATOM: \u0026str = \"atom\";\n\n/// Helper function for comparing vectors or another slice-like object as they would represent\n/// set with duplications. Compares sets by first sorting elements using provided ordering.\n/// This functions reshufless elements inplace, as it should never matter as compared\n/// containers should represent same value regardless of ordering, and making this inplace just\n/// safes obsolete copying.\n///\n/// This is implemented as a macro instead of function to throw panic in the place of macro\n/// usage instead of from function called inside test.\nmacro_rules! assert_sorted_eq {\n    ($left:expr, $right:expr, $cmp:expr $(,)?) =\u003e {\n        let mut left = $left;\n        left.sort_by(\u0026$cmp);\n\n        let mut right = $right;\n        right.sort_by($cmp);\n\n        assert_eq!(left, right);\n    };\n}\n\n#[test]\nfn get_contract_version_works() {\n    let app = App::default();\n\n    let owner = \"owner\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(vec![owner.to_owned()], true)\n        .with_label(\"Sublist contract\")\n        .call(owner)\n        .unwrap();\n\n    let version: ContractVersion =\n        query_contract_info(\u0026app.app().wrap(), contract.contract_addr.to_string()).unwrap();\n\n    assert_eq!(\n        ContractVersion {\n            contract: CONTRACT_NAME.to_string(),\n            version: CONTRACT_VERSION.to_string(),\n        },\n        version\n    );\n}\n\nmod allowance {\n    use cw_multi_test::next_block;\n\n    use crate::responses::AllowanceInfo;\n    use crate::state::Allowance;\n\n    use super::*;\n\n    #[test]\n    fn query() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spenders = [\"spender1\", \"spender2\", \"spender3\"];\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Sublist contract\")\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(spenders[0].to_owned(), coin(1, ATOM), None)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(spenders[1].to_owned(), coin(2, ATOM), None)\n            .call(owner)\n            .unwrap();\n\n        assert_eq!(\n            Allowance {\n                balance: NativeBalance(coins(1, ATOM)),\n                expires: Expiration::Never {},\n            },\n            contract.allowance(spenders[0].to_owned()).unwrap()\n        );\n\n        assert_eq!(\n            Allowance {\n                balance: NativeBalance(coins(2, ATOM)),\n                expires: Expiration::Never {},\n            },\n            contract.allowance(spenders[1].to_owned()).unwrap()\n        );\n\n        assert_eq!(\n            Allowance::default(),\n            contract.allowance(spenders[2].to_owned()).unwrap()\n        );\n    }\n\n    #[test]\n    fn query_expired() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender = \"spender\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Sublist contract\")\n            .call(owner)\n            .unwrap();\n\n        let height = app.block_info().height;\n        contract\n            .increase_allowance(\n                spender.to_owned(),\n                coin(1, ATOM),\n                Some(Expiration::AtHeight(height + 1)),\n            )\n            .call(owner)\n            .unwrap();\n\n        app.update_block(next_block);\n\n        // Check allowances work for accounts with balances\n        assert_eq!(\n            Allowance {\n                balance: NativeBalance(vec![]),\n                expires: Expiration::Never {},\n            },\n            contract.allowance(spender.to_owned()).unwrap()\n        );\n    }\n\n    #[test]\n    fn query_all() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender1 = \"spender1\";\n        let spender2 = \"spender2\";\n        let spender3 = \"spender3\";\n        let spender4 = \"spender4\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Sublist contract\")\n            .call(owner)\n            .unwrap();\n\n        let height = app.block_info().height;\n        contract\n            .increase_allowance(spender1.to_owned(), coin(1234, ATOM), None)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(\n                spender2.to_owned(),\n                coin(2345, ATOM),\n                Some(Expiration::Never {}),\n            )\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(\n                spender3.to_owned(),\n                coin(3456, ATOM),\n                Some(Expiration::AtHeight(height + 2)),\n            )\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(\n                spender4.to_owned(),\n                coin(2222, ATOM),\n                Some(Expiration::AtHeight(height + 1)),\n            )\n            .call(owner)\n            .unwrap();\n\n        app.update_block(next_block);\n\n        let batch1 = contract.all_allowances(None, Some(2)).unwrap().allowances;\n        assert_eq!(2, batch1.len());\n\n        let batch2 = contract\n            .all_allowances(Some(batch1.last().unwrap().spender.to_string()), Some(2))\n            .unwrap()\n            .allowances;\n        assert_eq!(1, batch2.len());\n\n        let height = app.block_info().height;\n        let expected = vec![\n            AllowanceInfo {\n                spender: Addr::unchecked(spender1),\n                balance: NativeBalance(coins(1234, ATOM)),\n                expires: Expiration::Never {}, // Not set, expected default\n            },\n            AllowanceInfo {\n                spender: Addr::unchecked(spender2),\n                balance: NativeBalance(coins(2345, ATOM)),\n                expires: Expiration::Never {},\n            },\n            AllowanceInfo {\n                spender: Addr::unchecked(spender3),\n                balance: NativeBalance(coins(3456, ATOM)),\n                expires: Expiration::AtHeight(height + 1),\n            },\n        ];\n\n        // Check allowances work for accounts with balances\n        assert_sorted_eq!(\n            expected,\n            [batch1, batch2].concat(),\n            AllowanceInfo::cmp_by_spender\n        );\n    }\n}\n\nmod permissions {\n    use crate::responses::PermissionsInfo;\n    use crate::state::Permissions;\n\n    use super::*;\n\n    const ALL_PERMS: Permissions = Permissions {\n        delegate: true,\n        redelegate: true,\n        undelegate: true,\n        withdraw: true,\n    };\n\n    const NO_PERMS: Permissions = Permissions {\n        delegate: false,\n        redelegate: false,\n        undelegate: false,\n        withdraw: false,\n    };\n\n    #[test]\n    fn query() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender1 = \"spender1\";\n        let spender2 = \"spender2\";\n        let spender3 = \"spender2\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_string()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender1.to_string(), ALL_PERMS)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender2.to_string(), NO_PERMS)\n            .call(owner)\n            .unwrap();\n\n        assert_eq!(\n            ALL_PERMS,\n            contract.permissions(spender1.to_string()).unwrap()\n        );\n        assert_eq!(\n            NO_PERMS,\n            contract.permissions(spender2.to_string()).unwrap()\n        );\n        assert_eq!(\n            NO_PERMS,\n            contract.permissions(spender3.to_string()).unwrap()\n        );\n    }\n\n    #[test]\n    fn query_all() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender1 = \"spender1\";\n        let spender2 = \"spender2\";\n        let spender3 = \"spender3\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender1.to_owned(), ALL_PERMS)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender2.to_owned(), NO_PERMS)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender3.to_owned(), NO_PERMS)\n            .call(owner)\n            .unwrap();\n\n        assert_eq!(\n            ALL_PERMS,\n            contract.permissions(spender1.to_owned()).unwrap()\n        );\n        assert_eq!(NO_PERMS, contract.permissions(spender2.to_owned()).unwrap());\n        assert_eq!(NO_PERMS, contract.permissions(spender3.to_owned()).unwrap());\n\n        let batch1 = contract.all_permissions(None, Some(2)).unwrap().permissions;\n        assert_eq!(2, batch1.len());\n\n        let batch2 = contract\n            .all_permissions(Some(batch1.last().unwrap().spender.to_string()), Some(2))\n            .unwrap()\n            .permissions;\n        assert_eq!(1, batch2.len());\n\n        let expected = vec![\n            PermissionsInfo {\n                spender: Addr::unchecked(spender1),\n                permissions: ALL_PERMS,\n            },\n            PermissionsInfo {\n                spender: Addr::unchecked(spender2),\n                permissions: NO_PERMS,\n            },\n            PermissionsInfo {\n                spender: Addr::unchecked(spender3),\n                permissions: NO_PERMS,\n            },\n        ];\n\n        // Check allowances work for accounts with balances\n        assert_sorted_eq!(\n            expected,\n            [batch1, batch2].concat(),\n            PermissionsInfo::cmp_by_spender\n        );\n    }\n}\n\nmod cw1_execute {\n    use crate::cw1::test_utils::Cw1;\n    use cosmwasm_std::BankMsg;\n\n    use super::*;\n\n    #[test]\n    fn can_execute() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let admin = \"admin\";\n        let non_admin = \"non_admin\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned(), admin.to_owned()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        let msg = BankMsg::Send {\n            to_address: \"owner\".to_owned(),\n            amount: vec![],\n        };\n\n        let resp = contract\n            .cw1_proxy()\n            .can_execute(admin.to_string(), msg.clone().into())\n            .unwrap();\n\n        assert!(resp.can_execute);\n\n        let resp = contract\n            .cw1_proxy()\n            .can_execute(non_admin.to_string(), msg.into())\n            .unwrap();\n\n        assert!(!resp.can_execute);\n    }\n\n    #[test]\n    fn execute() {\n        let owner = \"owner\";\n        let admin = \"admin\";\n        let non_admin = \"non_admin\";\n\n        let app = cw_multi_test::App::new(|router, _api, storage| {\n            router\n                .bank\n                .init_balance(storage, \u0026Addr::unchecked(admin), coins(2345, ATOM))\n                .unwrap();\n            router\n                .bank\n                .init_balance(storage, \u0026Addr::unchecked(non_admin), coins(2345, ATOM))\n                .unwrap();\n        });\n\n        let app = App::new(app);\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned(), admin.to_string()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        let msg = BankMsg::Send {\n            to_address: \"owner\".to_owned(),\n            amount: vec![coin(2345, ATOM)],\n        };\n\n        contract\n            .cw1_proxy()\n            .execute(vec![msg.clone().into()])\n            .with_funds(\u0026[coin(2345, ATOM)])\n            .call(admin)\n            .unwrap();\n\n        contract\n            .cw1_proxy()\n            .execute(vec![msg.into()])\n            .with_funds(\u0026[coin(2345, ATOM)])\n            .call(non_admin)\n            .unwrap_err();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","multitest.rs"],"content":"#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","responses.rs"],"content":"use crate::state::Permissions;\nuse cosmwasm_schema::schemars::JsonSchema;\nuse cosmwasm_std::Addr;\nuse cw_utils::{Expiration, NativeBalance};\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllAllowancesResponse {\n    pub allowances: Vec\u003cAllowanceInfo\u003e,\n}\n\n#[cfg(test)]\nimpl AllAllowancesResponse {\n    pub fn canonical(mut self) -\u003e Self {\n        self.allowances = self\n            .allowances\n            .into_iter()\n            .map(AllowanceInfo::canonical)\n            .collect();\n        self.allowances.sort_by(AllowanceInfo::cmp_by_spender);\n        self\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub struct AllowanceInfo {\n    pub spender: Addr,\n    pub balance: NativeBalance,\n    pub expires: Expiration,\n}\n\n#[cfg(test)]\nimpl AllowanceInfo {\n    /// Utility function providing some ordering to be used with `slice::sort_by`.\n    ///\n    /// Note, that this doesn't implement full ordering - items with same spender but differing on\n    /// permissions, would be considered equal, however as spender is a unique key in any valid\n    /// state this is enough for testing purposes.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw_utils::{Expiration, NativeBalance};\n    /// # use cw1_subkeys::msg::AllowanceInfo;\n    /// # use cosmwasm_schema::{cw_serde, QueryResponses};\n    /// # use cosmwasm_std::coin;\n    ///\n    /// let mut allows = vec![Allowance {\n    ///   spender: \"spender2\".to_owned(),\n    ///   balance: NativeBalance(vec![coin(1, \"token1\")]),\n    ///   expires: Expiration::Never {},\n    /// }, Allowance {\n    ///   spender: \"spender1\".to_owned(),\n    ///   balance: NativeBalance(vec![coin(2, \"token2\")]),\n    ///   expires: Expiration::Never {},\n    /// }];\n    ///\n    /// allows.sort_by(Allowance::cmp_by_spender);\n    ///\n    /// assert_eq!(\n    ///   allows.into_iter().map(|allow| allow.spender).collect::\u003cVec\u003c_\u003e\u003e(),\n    ///   vec![\"spender1\".to_owned(), \"spender2\".to_owned()]\n    /// );\n    /// ```\n    pub fn cmp_by_spender(left: \u0026Self, right: \u0026Self) -\u003e std::cmp::Ordering {\n        left.spender.cmp(\u0026right.spender)\n    }\n\n    pub fn canonical(mut self) -\u003e Self {\n        self.balance.normalize();\n        self\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, JsonSchema, Debug, Default)]\npub struct AllPermissionsResponse {\n    pub permissions: Vec\u003cPermissionsInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, JsonSchema, Debug)]\npub struct PermissionsInfo {\n    pub spender: Addr,\n    pub permissions: Permissions,\n}\n\n#[cfg(any(test, feature = \"test-utils\"))]\nimpl PermissionsInfo {\n    /// Utility function providing some ordering to be used with `slice::sort_by`.\n    ///\n    /// Note, that this doesn't implement full ordering - items with same spender but differing on\n    /// permissions, would be considered equal, however as spender is a unique key in any valid\n    /// state this is enough for testing purposes.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw1_subkeys::msg::PermissionsInfo;\n    /// # use cw1_subkeys::state::Permissions;\n    ///\n    /// let mut perms = vec![PermissionsInfo {\n    ///   spender: \"spender2\".to_owned(),\n    ///   permissions: Permissions::default(),\n    /// }, PermissionsInfo {\n    ///   spender: \"spender1\".to_owned(),\n    ///   permissions: Permissions::default(),\n    /// }];\n    ///\n    /// perms.sort_by(PermissionsInfo::cmp_by_spender);\n    ///\n    /// assert_eq!(\n    ///   perms.into_iter().map(|perm| perm.spender).collect::\u003cVec\u003c_\u003e\u003e(),\n    ///   vec![\"spender1\".to_owned(), \"spender2\".to_owned()]\n    /// );\n    /// ```\n    pub fn cmp_by_spender(left: \u0026Self, right: \u0026Self) -\u003e std::cmp::Ordering {\n        left.spender.cmp(\u0026right.spender)\n    }\n\n    pub fn spender(\u0026self) -\u003e \u0026str {\n        self.spender.as_ref()\n    }\n}\n","traces":[{"line":116,"address":[953888],"length":1,"stats":{"Line":1},"fn_name":"cmp_by_spender"},{"line":117,"address":[953902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[953920],"length":1,"stats":{"Line":0},"fn_name":"spender"},{"line":121,"address":[953925],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","state.rs"],"content":"use core::fmt;\n\nuse cw_utils::{Expiration, NativeBalance};\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n// Permissions struct defines users message execution permissions.\n// Could have implemented permissions for each cosmos module(StakingPermissions, GovPermissions etc...)\n// But that meant a lot of code for each module. Keeping the permissions inside one struct is more\n// optimal. Define other modules permissions here.\n#[derive(\n    Serialize, Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema, Default, Copy,\n)]\npub struct Permissions {\n    pub delegate: bool,\n    pub redelegate: bool,\n    pub undelegate: bool,\n    pub withdraw: bool,\n}\n\nimpl fmt::Display for Permissions {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"staking: {{ delegate: {}, redelegate: {}, undelegate: {}, withdraw: {} }}\",\n            self.delegate, self.redelegate, self.undelegate, self.withdraw\n        )\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema, Default)]\npub struct Allowance {\n    pub balance: NativeBalance,\n    pub expires: Expiration,\n}\n\n#[cfg(test)]\nimpl Allowance {\n    /// Utility function for converting message to its canonical form, so two messages with\n    /// different representation but same semantic meaning can be easily compared.\n    ///\n    /// It could be encapsulated in custom `PartialEq` implementation, but `PartialEq` is expected\n    /// to be fast, so it seems to be reasonable to keep it as representation-equality, and\n    /// canonicalize message only when it is needed\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw_utils::{Expiration, NativeBalance};\n    /// # use cw1_subkeys::state::Allowance;\n    /// # use cosmwasm_std::coin;\n    ///\n    /// let allow1 = Allowance {\n    ///   balance: NativeBalance(vec![coin(1, \"token1\"), coin(0, \"token2\"), coin(2, \"token1\"), coin(3, \"token3\")]),\n    ///   expires: Expiration::Never {},\n    /// };\n    ///\n    /// let allow2 = Allowance {\n    ///   balance: NativeBalance(vec![coin(3, \"token3\"), coin(3, \"token1\")]),\n    ///   expires: Expiration::Never {},\n    /// };\n    ///\n    /// assert_eq!(allow1.canonical(), allow2.canonical());\n    /// ```\n    pub fn canonical(mut self) -\u003e Self {\n        self.balance.normalize();\n        self\n    }\n}\n","traces":[{"line":22,"address":[751664],"length":1,"stats":{"Line":2},"fn_name":"fmt"},{"line":23,"address":[751697],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","whitelist.rs"],"content":"use cosmwasm_std::{Response, StdResult};\nuse cw1_whitelist::responses::AdminListResponse;\nuse cw1_whitelist::whitelist::{self, Whitelist};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw1SubkeysContract;\nuse crate::error::ContractError;\n\n// This can be skipped by tarpaulin as it's covered in cw1-whitelist\n#[cfg(not(tarpaulin_include))]\n#[contract]\n#[messages(whitelist as Whitelist)]\nimpl Whitelist for Cw1SubkeysContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn freeze(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e {\n        self.whitelist.freeze(ctx).map_err(From::from)\n    }\n\n    #[msg(exec)]\n    fn update_admins(\u0026self, ctx: ExecCtx, admins: Vec\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e {\n        self.whitelist\n            .update_admins(ctx, admins)\n            .map_err(From::from)\n    }\n\n    #[msg(query)]\n    fn admin_list(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cAdminListResponse\u003e {\n        self.whitelist.admin_list(ctx)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\n\nuse cw1_whitelist::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ContractExecMsg,\n        query: ContractQueryMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","contract.rs"],"content":"use crate::error::ContractError;\nuse crate::whitelist;\nuse cosmwasm_std::{Addr, Deps, Empty, Response};\n\nuse cw2::set_contract_version;\nuse cw_storage_plus::{Item, Map};\nuse sylvia::types::InstantiateCtx;\nuse sylvia::{contract, schemars};\n\n#[cfg(not(feature = \"library\"))]\nuse sylvia::entry_points;\n\nconst CONTRACT_NAME: \u0026str = env!(\"CARGO_PKG_NAME\");\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\npub struct Cw1WhitelistContract\u003c'a\u003e {\n    pub(crate) admins: Map\u003c'static, \u0026'a Addr, Empty\u003e,\n    pub(crate) mutable: Item\u003c'static, bool\u003e,\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_points)]\n#[contract]\n#[error(ContractError)]\n#[messages(cw1 as Cw1)]\n#[messages(whitelist as Whitelist)]\nimpl Cw1WhitelistContract\u003c'_\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            admins: Map::new(\"admins\"),\n            mutable: Item::new(\"mutable\"),\n        }\n    }\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        ctx: InstantiateCtx,\n        admins: Vec\u003cString\u003e,\n        mutable: bool,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        set_contract_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n        for admin in admins {\n            let admin = ctx.deps.api.addr_validate(\u0026admin)?;\n            self.admins.save(ctx.deps.storage, \u0026admin, \u0026Empty {})?;\n        }\n\n        self.mutable.save(ctx.deps.storage, \u0026mutable)?;\n\n        Ok(Response::new())\n    }\n\n    pub fn is_admin(\u0026self, deps: Deps, addr: \u0026Addr) -\u003e bool {\n        self.admins.has(deps.storage, addr)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::responses::AdminListResponse;\n    use crate::whitelist::{self, Whitelist};\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{coin, coins, to_binary, BankMsg, CosmosMsg, StakingMsg, SubMsg, WasmMsg};\n    use cw1::Cw1;\n\n    #[test]\n    fn instantiate_and_modify_config() {\n        let mut deps = mock_dependencies();\n\n        let alice = \"alice\";\n        let bob = \"bob\";\n        let carl = \"carl\";\n\n        let anyone = \"anyone\";\n\n        let contract = Cw1WhitelistContract::new();\n\n        // instantiate the contract\n        let info = mock_info(anyone, \u0026[]);\n        contract\n            .instantiate(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), bob.to_string(), carl.to_string()],\n                true,\n            )\n            .unwrap();\n\n        // ensure expected config\n        let expected = AdminListResponse {\n            admins: vec![alice.to_string(), bob.to_string(), carl.to_string()],\n            mutable: true,\n        };\n        assert_eq!(\n            contract\n                .admin_list((deps.as_ref(), mock_env()).into())\n                .unwrap(),\n            expected\n        );\n\n        // anyone cannot modify the contract\n        let info = mock_info(anyone, \u0026[]);\n        let err = contract\n            .update_admins(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![anyone.to_string()],\n            )\n            .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized);\n\n        // but alice can kick out carl\n        let info = mock_info(alice, \u0026[]);\n        contract\n            .update_admins(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), bob.to_string()],\n            )\n            .unwrap();\n\n        // ensure expected config\n        let expected = AdminListResponse {\n            admins: vec![alice.to_string(), bob.to_string()],\n            mutable: true,\n        };\n        assert_eq!(\n            contract\n                .admin_list((deps.as_ref(), mock_env()).into())\n                .unwrap(),\n            expected\n        );\n\n        // carl cannot freeze it\n        let info = mock_info(carl, \u0026[]);\n        let err = contract\n            .freeze((deps.as_mut(), mock_env(), info).into())\n            .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized);\n\n        // but bob can\n        let info = mock_info(bob, \u0026[]);\n        contract\n            .freeze((deps.as_mut(), mock_env(), info).into())\n            .unwrap();\n        let expected = AdminListResponse {\n            admins: vec![alice.to_string(), bob.to_string()],\n            mutable: false,\n        };\n        assert_eq!(\n            contract\n                .admin_list((deps.as_ref(), mock_env()).into())\n                .unwrap(),\n            expected\n        );\n\n        // and now alice cannot change it again\n        let info = mock_info(alice, \u0026[]);\n        let err = contract\n            .update_admins(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string()],\n            )\n            .unwrap_err();\n        assert_eq!(err, ContractError::ContractFrozen);\n    }\n\n    #[test]\n    fn execute_messages_has_proper_permissions() {\n        let mut deps = mock_dependencies();\n\n        let alice = \"alice\";\n        let bob = \"bob\";\n        let carl = \"carl\";\n\n        let contract = Cw1WhitelistContract::new();\n\n        // instantiate the contract\n        let info = mock_info(bob, \u0026[]);\n        contract\n            .instantiate(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), carl.to_string()],\n                false,\n            )\n            .unwrap();\n\n        let freeze = whitelist::ExecMsg::Freeze {};\n        let msgs = vec![\n            BankMsg::Send {\n                to_address: bob.to_string(),\n                amount: coins(10000, \"DAI\"),\n            }\n            .into(),\n            WasmMsg::Execute {\n                contract_addr: \"some contract\".into(),\n                msg: to_binary(\u0026freeze).unwrap(),\n                funds: vec![],\n            }\n            .into(),\n        ];\n\n        // bob cannot execute them\n        let info = mock_info(bob, \u0026[]);\n        let err = contract\n            .execute((deps.as_mut(), mock_env(), info).into(), msgs.clone())\n            .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized);\n\n        // but carl can\n        let info = mock_info(carl, \u0026[]);\n        let res = contract\n            .execute((deps.as_mut(), mock_env(), info).into(), msgs.clone())\n            .unwrap();\n        assert_eq!(\n            res.messages,\n            msgs.into_iter().map(SubMsg::new).collect::\u003cVec\u003c_\u003e\u003e()\n        );\n        assert_eq!(res.attributes, [(\"action\", \"execute\")]);\n    }\n\n    #[test]\n    fn can_execute_query_works() {\n        let mut deps = mock_dependencies();\n\n        let alice = \"alice\";\n        let bob = \"bob\";\n\n        let anyone = \"anyone\";\n\n        let contract = Cw1WhitelistContract::new();\n\n        // instantiate the contract\n        let info = mock_info(anyone, \u0026[]);\n        contract\n            .instantiate(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), bob.to_string()],\n                false,\n            )\n            .unwrap();\n\n        // let us make some queries... different msg types by owner and by other\n        let send_msg = CosmosMsg::Bank(BankMsg::Send {\n            to_address: anyone.to_string(),\n            amount: coins(12345, \"ushell\"),\n        });\n        let staking_msg = CosmosMsg::Staking(StakingMsg::Delegate {\n            validator: anyone.to_string(),\n            amount: coin(70000, \"ureef\"),\n        });\n\n        // owner can send\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                alice.to_string(),\n                send_msg.clone(),\n            )\n            .unwrap();\n        assert!(res.can_execute);\n\n        // owner can stake\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                bob.to_string(),\n                staking_msg.clone(),\n            )\n            .unwrap();\n        assert!(res.can_execute);\n\n        // anyone cannot send\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                anyone.to_string(),\n                send_msg,\n            )\n            .unwrap();\n        assert!(!res.can_execute);\n\n        // anyone cannot stake\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                anyone.to_string(),\n                staking_msg,\n            )\n            .unwrap();\n        assert!(!res.can_execute);\n    }\n\n    mod msgs {\n        use super::*;\n\n        use cosmwasm_std::{from_binary, from_slice, to_binary, BankMsg};\n\n        use crate::contract::{ContractExecMsg, ContractQueryMsg};\n\n        #[test]\n        fn freeze() {\n            let original = whitelist::ExecMsg::Freeze {};\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n\n            assert_eq!(ContractExecMsg::Whitelist(original), deserialized);\n\n            let json = br#\"{\n                \"freeze\": {}\n            }\"#;\n            let deserialized = from_slice(json).unwrap();\n\n            assert_eq!(\n                ContractExecMsg::Whitelist(whitelist::ExecMsg::Freeze {}),\n                deserialized\n            );\n        }\n\n        #[test]\n        fn update_admins() {\n            let original = whitelist::ExecMsg::UpdateAdmins {\n                admins: vec![\"admin1\".to_owned(), \"admin2\".to_owned()],\n            };\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n\n            assert_eq!(ContractExecMsg::Whitelist(original), deserialized);\n\n            let json = br#\"{\n                \"update_admins\": {\n                    \"admins\": [\"admin1\", \"admin3\"]\n                }\n            }\"#;\n            let deserialized = from_slice(json).unwrap();\n\n            assert_eq!(\n                ContractExecMsg::Whitelist(whitelist::ExecMsg::UpdateAdmins {\n                    admins: vec![\"admin1\".to_owned(), \"admin3\".to_owned()]\n                }),\n                deserialized\n            );\n        }\n\n        #[test]\n        fn admin_list() {\n            let original = whitelist::QueryMsg::AdminList {};\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n\n            assert_eq!(ContractQueryMsg::Whitelist(original), deserialized);\n\n            let json = br#\"{\n                \"admin_list\": {}\n            }\"#;\n            let deserialized = from_slice(json).unwrap();\n\n            assert_eq!(\n                ContractQueryMsg::Whitelist(whitelist::QueryMsg::AdminList {}),\n                deserialized\n            );\n        }\n\n        #[test]\n        fn execute() {\n            let original = cw1::ExecMsg::Execute {\n                msgs: vec![BankMsg::Send {\n                    to_address: \"admin1\".to_owned(),\n                    amount: vec![],\n                }\n                .into()],\n            };\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n            assert_eq!(ContractExecMsg::Cw1(original), deserialized);\n        }\n\n        #[test]\n        fn can_execute() {\n            let original = cw1::QueryMsg::CanExecute {\n                sender: \"admin\".to_owned(),\n                msg: BankMsg::Send {\n                    to_address: \"admin1\".to_owned(),\n                    amount: vec![],\n                }\n                .into(),\n            };\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n            assert_eq!(ContractQueryMsg::Cw1(original), deserialized);\n        }\n    }\n}\n","traces":[{"line":26,"address":[1328951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1860576],"length":1,"stats":{"Line":9},"fn_name":"new"},{"line":29,"address":[2687502],"length":1,"stats":{"Line":10},"fn_name":null},{"line":30,"address":[946010],"length":1,"stats":{"Line":9},"fn_name":null},{"line":34,"address":[2689273,2687600,2688851],"length":1,"stats":{"Line":4},"fn_name":"instantiate"},{"line":40,"address":[2687649,2687762,2687876],"length":1,"stats":{"Line":13},"fn_name":null},{"line":42,"address":[2688862,2687813,2687981],"length":1,"stats":{"Line":12},"fn_name":null},{"line":43,"address":[1861566,1861272,1861379],"length":1,"stats":{"Line":14},"fn_name":null},{"line":44,"address":[2609204,2608997,2609283],"length":1,"stats":{"Line":12},"fn_name":null},{"line":47,"address":[1861968,1862074],"length":1,"stats":{"Line":10},"fn_name":null},{"line":49,"address":[1862059,1862241],"length":1,"stats":{"Line":12},"fn_name":null},{"line":52,"address":[1862320],"length":1,"stats":{"Line":2},"fn_name":"is_admin"},{"line":53,"address":[1862340],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","cw1.rs"],"content":"use cosmwasm_std::{Addr, CosmosMsg, Response, StdResult};\nuse cw1::{CanExecuteResp, Cw1};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw1WhitelistContract;\nuse crate::error::ContractError;\n\n#[contract]\n#[messages(cw1 as Cw1)]\nimpl Cw1 for Cw1WhitelistContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn execute(\u0026self, ctx: ExecCtx, msgs: Vec\u003cCosmosMsg\u003e) -\u003e Result\u003cResponse, ContractError\u003e {\n        if !self.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender) {\n            return Err(ContractError::Unauthorized);\n        }\n\n        let resp = Response::new()\n            .add_messages(msgs)\n            .add_attribute(\"action\", \"execute\");\n        Ok(resp)\n    }\n\n    #[msg(query)]\n    fn can_execute(\n        \u0026self,\n        ctx: QueryCtx,\n        sender: String,\n        _msg: CosmosMsg,\n    ) -\u003e StdResult\u003cCanExecuteResp\u003e {\n        let resp = CanExecuteResp {\n            can_execute: self.is_admin(ctx.deps, \u0026Addr::unchecked(sender)),\n        };\n\n        Ok(resp)\n    }\n}\n","traces":[{"line":15,"address":[2701776,2702329],"length":1,"stats":{"Line":1},"fn_name":"execute"},{"line":16,"address":[1874688,1874767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[2622517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[2701941,2702142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[960591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1875068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1875426,1875200,1875528],"length":1,"stats":{"Line":1},"fn_name":"can_execute"},{"line":34,"address":[1875253,1875351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1875447],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Contract is frozen\")]\n    ContractFrozen,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","lib.rs"],"content":"pub mod contract;\nmod cw1;\npub mod error;\n#[cfg(any(test, feature = \"tests\"))]\npub mod multitest;\npub mod responses;\npub mod whitelist;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","multitest.rs"],"content":"#[cfg(test)]\nmod test {\n    use cosmwasm_std::{to_binary, WasmMsg};\n\n    use crate::contract::multitest_utils::CodeId;\n    use crate::cw1::test_utils::Cw1;\n    use crate::error::ContractError;\n    use crate::responses::AdminListResponse;\n    use crate::whitelist;\n    use crate::whitelist::test_utils::Whitelist;\n    use assert_matches::assert_matches;\n    use sylvia::multitest::App;\n\n    #[test]\n    fn proxy_freeze_message() {\n        let app = App::default();\n        let code_id = CodeId::store_code(\u0026app);\n\n        let owner = \"owner\";\n\n        let first_contract = code_id\n            .instantiate(vec![owner.to_owned()], true)\n            .with_label(\"First contract\")\n            .call(owner)\n            .unwrap();\n\n        let second_contract = code_id\n            .instantiate(vec![first_contract.contract_addr.to_string()], true)\n            .with_label(\"Second contract\")\n            .call(owner)\n            .unwrap();\n\n        let freeze = whitelist::ExecMsg::Freeze {};\n        let freeze = WasmMsg::Execute {\n            contract_addr: second_contract.contract_addr.to_string(),\n            msg: to_binary(\u0026freeze).unwrap(),\n            funds: vec![],\n        };\n\n        first_contract\n            .cw1_proxy()\n            .execute(vec![freeze.into()])\n            .call(owner)\n            .unwrap();\n\n        let resp = second_contract.whitelist_proxy().admin_list().unwrap();\n\n        assert_matches!(\n            resp,\n            AdminListResponse {\n                mutable,\n                ..\n            } if !mutable\n        );\n    }\n\n    #[test]\n    fn update_admins() {\n        let app = App::default();\n        let code_id = CodeId::store_code(\u0026app);\n\n        let owner = \"owner\";\n        let mut admins = vec![\"admin1\".to_owned(), \"admin2\".to_owned()];\n\n        let contract = code_id\n            .instantiate(admins.clone(), true)\n            .call(owner)\n            .unwrap();\n\n        let resp = contract.whitelist_proxy().admin_list().unwrap();\n        assert_eq!(resp.admins, admins);\n\n        admins.push(\"admin3\".to_owned());\n        contract\n            .whitelist_proxy()\n            .update_admins(admins.clone())\n            .call(\"admin1\")\n            .unwrap();\n\n        let resp = contract.whitelist_proxy().admin_list().unwrap();\n        assert_eq!(resp.admins, admins);\n    }\n\n    #[test]\n    fn unathorized_admin_update() {\n        let app = App::default();\n        let code_id = CodeId::store_code(\u0026app);\n\n        let owner = \"owner\";\n\n        let contract = code_id\n            .instantiate(vec![owner.to_string()], true)\n            .call(owner)\n            .unwrap();\n\n        let err = contract\n            .whitelist_proxy()\n            .update_admins(vec![owner.to_owned(), \"fake_admin\".to_owned()])\n            .call(\"fake_admin\")\n            .unwrap_err();\n\n        assert_eq!(err, ContractError::Unauthorized);\n\n        contract.whitelist_proxy().freeze().call(owner).unwrap();\n\n        let err = contract\n            .whitelist_proxy()\n            .update_admins(vec![owner.to_owned(), \"admin\".to_owned()])\n            .call(owner)\n            .unwrap_err();\n\n        assert_eq!(err, ContractError::ContractFrozen);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","responses.rs"],"content":"use serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, schemars::JsonSchema, Debug, Default)]\npub struct AdminListResponse {\n    pub admins: Vec\u003cString\u003e,\n    pub mutable: bool,\n}\n\n#[cfg(any(test, feature = \"test-utils\"))]\nimpl AdminListResponse {\n    /// Utility function forconverting message to its canonical form, so two messages with\n    /// different representation but same semantical meaning can be easly compared.\n    ///\n    /// It could be encapsulated in custom `PartialEq` implementation, but `PartialEq` is expected\n    /// to be quickly, so it seems to be reasonable to keep it as representation-equality, and\n    /// canonicalize message only when it is needed\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw1_whitelist::msg::AdminListResponse;\n    ///\n    /// let resp1 = AdminListResponse {\n    ///   admins: vec![\"admin1\".to_owned(), \"admin2\".to_owned()],\n    ///   mutable: true,\n    /// };\n    ///\n    /// let resp2 = AdminListResponse {\n    ///   admins: vec![\"admin2\".to_owned(), \"admin1\".to_owned(), \"admin2\".to_owned()],\n    ///   mutable: true,\n    /// };\n    ///\n    /// assert_eq!(resp1.canonical(), resp2.canonical());\n    /// ```\n    pub fn canonical(mut self) -\u003e Self {\n        self.admins.sort();\n        self.admins.dedup();\n        self\n    }\n}\n","traces":[{"line":36,"address":[635296,635442],"length":1,"stats":{"Line":0},"fn_name":"canonical"},{"line":37,"address":[635321,635375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[635386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[635407],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","whitelist.rs"],"content":"use cosmwasm_std::{Empty, Order, Response, StdResult};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{contract, interface, schemars};\n\nuse crate::contract::Cw1WhitelistContract;\nuse crate::error::ContractError;\nuse crate::responses::AdminListResponse;\n\n#[interface]\npub trait Whitelist {\n    type Error: From\u003ccosmwasm_std::StdError\u003e;\n\n    #[msg(exec)]\n    fn freeze(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn update_admins(\u0026self, ctx: ExecCtx, admins: Vec\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn admin_list(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cAdminListResponse\u003e;\n}\n\n#[contract]\nimpl Whitelist for Cw1WhitelistContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn freeze(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, ContractError\u003e {\n        if !self.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender) {\n            return Err(ContractError::Unauthorized);\n        }\n\n        self.mutable.save(ctx.deps.storage, \u0026false)?;\n\n        let resp = Response::new().add_attribute(\"action\", \"freeze\");\n        Ok(resp)\n    }\n\n    #[msg(exec)]\n    fn update_admins(\n        \u0026self,\n        ctx: ExecCtx,\n        mut admins: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        if !self.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender) {\n            return Err(ContractError::Unauthorized);\n        }\n\n        if !self.mutable.load(ctx.deps.storage)? {\n            return Err(ContractError::ContractFrozen);\n        }\n\n        admins.sort_unstable();\n        let mut low_idx = 0;\n\n        let to_remove: Vec\u003c_\u003e = self\n            .admins\n            .keys(ctx.deps.storage, None, None, Order::Ascending)\n            .filter(|addr| {\n                // This is a bit of optimization basing on the fact that both `admins` and queried\n                // keys range are sorted. Binary search would always return the index which is at\n                // most as big as searched item, so for next item there is no point in looking at\n                // lower indices. On the other hand - if we reached and of the sequence, we want to\n                // remove all following keys.\n                addr.as_ref()\n                    .map(|addr| {\n                        if low_idx \u003e= admins.len() {\n                            return true;\n                        }\n\n                        match admins[low_idx..].binary_search(\u0026addr.into()) {\n                            Ok(idx) =\u003e {\n                                low_idx = idx;\n                                false\n                            }\n                            Err(idx) =\u003e {\n                                low_idx = idx;\n                                true\n                            }\n                        }\n                    })\n                    .unwrap_or(true)\n            })\n            .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n\n        for addr in to_remove {\n            self.admins.remove(ctx.deps.storage, \u0026addr);\n        }\n\n        for admin in admins {\n            let admin = ctx.deps.api.addr_validate(\u0026admin)?;\n            self.admins.save(ctx.deps.storage, \u0026admin, \u0026Empty {})?;\n        }\n\n        let resp = Response::new().add_attribute(\"action\", \"update_admins\");\n        Ok(resp)\n    }\n\n    #[msg(query)]\n    fn admin_list(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cAdminListResponse\u003e {\n        let admins: Result\u003c_, _\u003e = self\n            .admins\n            .keys(ctx.deps.storage, None, None, Order::Ascending)\n            .map(|addr| addr.map(String::from))\n            .collect();\n\n        Ok(AdminListResponse {\n            admins: admins?,\n            mutable: self.mutable.load(ctx.deps.storage)?,\n        })\n    }\n}\n","traces":[{"line":28,"address":[1875552,1876088],"length":1,"stats":{"Line":1},"fn_name":"freeze"},{"line":29,"address":[1875600,1875654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[1875732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1875858,1875694,1875786],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[1875846,1875962],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[1876008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[1878701,1877489,1876128],"length":1,"stats":{"Line":1},"fn_name":"update_admins"},{"line":45,"address":[1876176,1876263],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[1876334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1876414,1876303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[1876596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1876574,1876656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[1876673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1876794,1877107,1876738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1876685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1561456],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":65,"address":[1561518,1561488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1561501,1561568,1561823],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":67,"address":[1561598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1561733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1561634,1561803],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[1561849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1561862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1561870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[1561877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1561890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1561898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1877185,1876972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[1877401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1878411,1877505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1877875,1877770,1878062],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[1878295,1878017,1878216],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[1878525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1878580],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1879321,1879632,1878720],"length":1,"stats":{"Line":1},"fn_name":"admin_list"},{"line":101,"address":[1878816,1878880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[1878763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1561920,1561948],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":107,"address":[1879361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1878917,1879125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1879284,1879091,1879342,1879488],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":40,"coverable":41},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","allowances.rs"],"content":"use cosmwasm_std::{Addr, Binary, Order, Response, StdError, StdResult, Uint128};\nuse cw20_allowances::responses::{\n    AllAccountsResponse, AllAllowancesResponse, AllSpenderAllowancesResponse, AllowanceInfo,\n    AllowanceResponse, SpenderAllowanceInfo,\n};\nuse cw20_allowances::Cw20Allowances;\nuse cw_storage_plus::{Bound, Bounder};\nuse cw_utils::Expiration;\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw20Base;\nuse crate::error::ContractError;\nuse crate::responses::Cw20ReceiveMsg;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\n#[contract]\n#[messages(cw20_allowances as Cw20Allowances)]\nimpl Cw20Allowances for Cw20Base\u003c'_\u003e {\n    type Error = ContractError;\n\n    /// Allows spender to access an additional amount tokens from the owner's (env.sender) account.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn increase_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let spender_addr = ctx.deps.api.addr_validate(\u0026spender)?;\n        if spender_addr == ctx.info.sender {\n            return Err(ContractError::CannotSetOwnAccount);\n        }\n\n        let update_fn = |allow: Option\u003cAllowanceResponse\u003e| -\u003e Result\u003c_, _\u003e {\n            let allow = allow.unwrap_or_default();\n            let allowance = allow.allowance + amount;\n            match expires {\n                Some(expires) if !expires.is_expired(\u0026ctx.env.block) =\u003e {\n                    Ok(AllowanceResponse { allowance, expires })\n                }\n                None =\u003e Ok(AllowanceResponse { allowance, ..allow }),\n                _ =\u003e Err(ContractError::InvalidExpiration),\n            }\n        };\n        self.allowances.update(\n            ctx.deps.storage,\n            (\u0026ctx.info.sender, \u0026spender_addr),\n            update_fn,\n        )?;\n        self.allowances_spender.update(\n            ctx.deps.storage,\n            (\u0026spender_addr, \u0026ctx.info.sender),\n            update_fn,\n        )?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"increase_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Lowers the spender's access of tokens from the owner's (env.sender) account by amount.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn decrease_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let spender_addr = Addr::unchecked(\u0026spender);\n        if spender_addr == ctx.info.sender {\n            return Err(ContractError::CannotSetOwnAccount);\n        }\n\n        let key = (\u0026ctx.info.sender, \u0026spender_addr);\n\n        let reverse = |(a, b)| (b, a);\n\n        // load value and delete if it hits 0, or update otherwise\n        let mut allowance = self.allowances.load(ctx.deps.storage, key)?;\n        if amount \u003c allowance.allowance {\n            // update the new amount\n            allowance.allowance = allowance\n                .allowance\n                .checked_sub(amount)\n                .map_err(StdError::overflow)?;\n            if let Some(exp) = expires {\n                if exp.is_expired(\u0026ctx.env.block) {\n                    return Err(ContractError::InvalidExpiration);\n                }\n                allowance.expires = exp;\n            }\n            self.allowances.save(ctx.deps.storage, key, \u0026allowance)?;\n            self.allowances_spender\n                .save(ctx.deps.storage, reverse(key), \u0026allowance)?;\n        } else {\n            self.allowances.remove(ctx.deps.storage, key);\n            self.allowances_spender\n                .remove(ctx.deps.storage, reverse(key));\n        }\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"decrease_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Transfers amount tokens from owner -\u003e recipient\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn transfer_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026recipient)?;\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n\n        // Avoid doing state update in case of self to self transfer\n        if rcpt_addr == owner_addr {\n            let resp = Response::new()\n                .add_attribute(\"action\", \"transfer_from\")\n                .add_attribute(\"from\", owner)\n                .add_attribute(\"to\", recipient)\n                .add_attribute(\"by\", ctx.info.sender)\n                .add_attribute(\"amount\", amount);\n            return Ok(resp);\n        }\n\n        if ctx.info.sender != owner {\n            // deduct allowance before doing anything else have enough allowance\n            self.deduct_allowance(\n                ctx.deps.storage,\n                \u0026owner_addr,\n                \u0026ctx.info.sender,\n                \u0026ctx.env.block,\n                amount,\n            )?;\n        }\n\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n                Ok(balance.unwrap_or_default().checked_sub(amount)?)\n            },\n        )?;\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026rcpt_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n        )?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"transfer_from\")\n            .add_attribute(\"from\", owner)\n            .add_attribute(\"to\", recipient)\n            .add_attribute(\"by\", ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Sends amount tokens from owner -\u003e contract\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn send_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026contract)?;\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n\n        // deduct allowance before doing anything else have enough allowance\n        self.deduct_allowance(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            \u0026ctx.info.sender,\n            \u0026ctx.env.block,\n            amount,\n        )?;\n\n        // move the tokens to the contract\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n                Ok(balance.unwrap_or_default().checked_sub(amount)?)\n            },\n        )?;\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026rcpt_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n        )?;\n\n        let resp = Response::new()\n            .add_attribute(\"action\", \"send_from\")\n            .add_attribute(\"from\", \u0026owner)\n            .add_attribute(\"to\", \u0026contract)\n            .add_attribute(\"by\", \u0026ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n\n        // create a send message\n        let msg = Cw20ReceiveMsg {\n            sender: ctx.info.sender.into(),\n            amount,\n            msg,\n        }\n        .into_cosmos_msg(contract)?;\n\n        let resp = resp.add_message(msg);\n        Ok(resp)\n    }\n\n    /// Destroys amount of tokens forever\n    #[msg(exec)]\n    fn burn_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n\n        // deduct allowance before doing anything else have enough allowance\n        self.deduct_allowance(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            \u0026ctx.info.sender,\n            \u0026ctx.env.block,\n            amount,\n        )?;\n\n        // lower balance\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n                Ok(balance.unwrap_or_default().checked_sub(amount)?)\n            },\n        )?;\n        // reduce total_supply\n        self.token_info\n            .update(ctx.deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n                meta.total_supply = meta.total_supply.checked_sub(amount)?;\n                Ok(meta)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"burn_from\")\n            .add_attribute(\"owner\", owner)\n            .add_attribute(\"spender\", ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Returns how much spender can use from owner account, 0 if unset.\n    #[msg(query)]\n    fn allowance(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        spender: String,\n    ) -\u003e StdResult\u003cAllowanceResponse\u003e {\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n        let spender_addr = ctx.deps.api.addr_validate(\u0026spender)?;\n        let allowance = self\n            .allowances\n            .may_load(ctx.deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n            .unwrap_or_default();\n        Ok(allowance)\n    }\n\n    /// Returns all allowances this owner has approved. Supports pagination.\n    #[msg(query)]\n    fn all_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n        let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n        let allowances = self\n            .allowances\n            .prefix(\u0026owner_addr)\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, allow)| AllowanceInfo {\n                    spender: addr.into(),\n                    allowance: allow.allowance,\n                    expires: allow.expires,\n                })\n            })\n            .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n        Ok(AllAllowancesResponse { allowances })\n    }\n\n    /// Returns all allowances this spender has been granted. Supports pagination.\n    #[msg(query)]\n    fn all_spender_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        spender: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllSpenderAllowancesResponse\u003e {\n        let spender_addr = ctx.deps.api.addr_validate(\u0026spender)?;\n        let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n        let start_after = start_after.map(Addr::unchecked);\n        let start = start_after.as_ref().and_then(Bounder::exclusive_bound);\n\n        let allowances = self\n            .allowances_spender\n            .prefix(\u0026spender_addr)\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, allow)| SpenderAllowanceInfo {\n                    owner: addr.into(),\n                    allowance: allow.allowance,\n                    expires: allow.expires,\n                })\n            })\n            .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n        Ok(AllSpenderAllowancesResponse { allowances })\n    }\n\n    /// Returns all allowances this spender has been granted. Supports pagination.\n    #[msg(query)]\n    fn all_accounts(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n        let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n        let accounts = self\n            .balances\n            .keys(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| item.map(Into::into))\n            .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n        Ok(AllAccountsResponse { accounts })\n    }\n}\n","traces":[{"line":28,"address":[1284555,1284655,1282752],"length":1,"stats":{"Line":1},"fn_name":"increase_allowance"},{"line":35,"address":[1282964,1283132,1282836],"length":1,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[1283101,1283287],"length":1,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[1283469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1283307],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[1706848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[1706858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1706924],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[1707148,1707064],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[1707175],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[1706964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1707097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1283815,1283387,1283348,1283552],"length":1,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[1283352],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[1283359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1283669,1284009,1283858,1283630],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[1283634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1283641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1284189,1283930,1284268,1284104],"length":1,"stats":{"Line":20},"fn_name":null},{"line":64,"address":[1284157],"length":1,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[1284237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1284361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1287284,1284736,1287184],"length":1,"stats":{"Line":1},"fn_name":"decrease_allowance"},{"line":80,"address":[1284838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1285003,1284935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[1285100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1285019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[1707264,1707283],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":90,"address":[1285050,1285186,1285321],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[1285416,1285282],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[1285746,1285469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1285682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1285643,1285778,1285945],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[1285810,1285907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[1285955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[1285913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1286008,1286177,1285847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[1286070,1286464,1286293],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[1286400,1286079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1285432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1286712,1286588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1286597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1286809,1286382,1286888,1286724],"length":1,"stats":{"Line":8},"fn_name":null},{"line":114,"address":[1286777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1286857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1286990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1289821,1287376],"length":1,"stats":{"Line":1},"fn_name":"transfer_from"},{"line":130,"address":[1287453,1287794,1287609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[1287751,1287965,1288132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[1288113,1288290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1288506,1288427,1288586,1288336],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[1288396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1288475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1288554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1288680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1288306,1289041,1288771],"length":1,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[1288876,1289115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1288858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1288865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1288872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1288787,1289363,1288814,1289142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[1288791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1288806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[1707536,1707413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[1289236,1289390,1289561,1289263],"length":1,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[1289240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1289255],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[1290186,1290027,1289482,1289943,1290106],"length":1,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[1289996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1290075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[1290154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[1290285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[1293705,1290688],"length":1,"stats":{"Line":1},"fn_name":"send_from"},{"line":188,"address":[1290977,1291165,1290793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1291564,1291119,1291336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[1291500,1291734,1291938],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[1291482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1291489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1291496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1292208,1291808,1291835,1291984],"length":1,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[1291812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1291827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1707829,1707952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1292406,1292105,1292235,1292078],"length":1,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[1292082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1292097],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[1292573,1292433,1292327],"length":1,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[1292569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1292664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1292672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1293290,1292911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1293124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1293879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1294352,1296340,1296440],"length":1,"stats":{"Line":1},"fn_name":"burn_from"},{"line":241,"address":[1294410,1294751,1294538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[1294699,1295110,1294915],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[1294681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1294688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[1294695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1294989,1295153,1295013,1295359],"length":1,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[1294993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1295005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[1708368,1708245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[1295402,1295782,1295267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[1295247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[1708529,1708657,1708458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[1708609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[1296056,1295885,1295976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[1295945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[1296024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[1296149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1296528,1297820,1297894],"length":1,"stats":{"Line":2},"fn_name":"allowance"},{"line":283,"address":[1296581,1296677,1296858],"length":1,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[1297250,1296816,1297025],"length":1,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[1297417,1297211,1297576,1297171],"length":1,"stats":{"Line":6},"fn_name":null},{"line":287,"address":[1297512,1297175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1297739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[1297920,1299079,1299492],"length":1,"stats":{"Line":2},"fn_name":"all_allowances"},{"line":301,"address":[1298124,1298288,1298004],"length":1,"stats":{"Line":4},"fn_name":null},{"line":302,"address":[1298269,1298448],"length":1,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[1298483],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[1298790,1298550,1299042,1298712],"length":1,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[1298623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[1708864],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":311,"address":[1708892,1709004,1708912,1708925],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":312,"address":[1708970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[1708984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[1708994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[1299299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[1299520,1301225,1300774],"length":1,"stats":{"Line":1},"fn_name":"all_spender_allowances"},{"line":330,"address":[1299736,1299900,1299604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[1300060,1299881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[1300095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[1300157,1300226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[1300405,1300246,1300737,1300485],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[1300316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[1709056],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":341,"address":[1709104,1709084,1709117,1709196],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":342,"address":[1709162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1709176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1709186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[1301013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[1301248,1302007],"length":1,"stats":{"Line":1},"fn_name":"all_accounts"},{"line":359,"address":[1301326,1301408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[1301443],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[1301575,1301504,1301945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[1301508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1709356,1709328],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":369,"address":[1301776],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":147,"coverable":149},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\n\nuse cw20_base::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ContractExecMsg,\n        query: ContractQueryMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","contract.rs"],"content":"use crate::error::ContractError;\nuse crate::responses::{BalanceResponse, Cw20Coin, Cw20ReceiveMsg, TokenInfoResponse};\nuse crate::validation::{validate_accounts, validate_msg, verify_logo};\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{\n    ensure, Addr, Binary, BlockInfo, DepsMut, Order, Response, StdError, StdResult, Storage,\n    Uint128,\n};\nuse cw2::set_contract_version;\nuse cw20_allowances::responses::AllowanceResponse;\nuse cw20_marketing::responses::{LogoInfo, MarketingInfoResponse};\nuse cw20_marketing::Logo;\nuse cw20_minting::responses::MinterResponse;\nuse cw_storage_plus::{Item, Map};\nuse cw_utils::ensure_from_older_version;\nuse sylvia::types::{ExecCtx, InstantiateCtx, MigrateCtx, QueryCtx};\nuse sylvia::{contract, schemars};\n\n#[cfg(not(feature = \"library\"))]\nuse sylvia::entry_points;\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:cw20-base\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cw_serde]\npub struct TokenInfo {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub total_supply: Uint128,\n    pub mint: Option\u003cMinterData\u003e,\n}\n\nimpl TokenInfo {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n}\n\n#[cw_serde]\npub struct MinterData {\n    pub minter: Addr,\n    /// cap is how many more tokens can be issued by the minter\n    pub cap: Option\u003cUint128\u003e,\n}\n\n#[cw_serde]\npub struct InstantiateMarketingInfo {\n    pub project: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub marketing: Option\u003cString\u003e,\n    pub logo: Option\u003cLogo\u003e,\n}\n\n#[cw_serde]\npub struct InstantiateMsgData {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cCw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n    pub marketing: Option\u003cInstantiateMarketingInfo\u003e,\n}\n\npub struct Cw20Base\u003c'a\u003e {\n    pub(crate) token_info: Item\u003c'static, TokenInfo\u003e,\n    pub(crate) marketing_info: Item\u003c'static, MarketingInfoResponse\u003e,\n    pub(crate) logo: Item\u003c'static, Logo\u003e,\n    pub(crate) balances: Map\u003c'static, \u0026'a Addr, Uint128\u003e,\n    pub(crate) allowances: Map\u003c'static, (\u0026'a Addr, \u0026'a Addr), AllowanceResponse\u003e,\n    // TODO: After https://github.com/CosmWasm/cw-plus/issues/670 is implemented, replace this with a `MultiIndex` over `ALLOWANCES`\n    pub(crate) allowances_spender: Map\u003c'static, (\u0026'a Addr, \u0026'a Addr), AllowanceResponse\u003e,\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_points)]\n#[contract]\n#[error(ContractError)]\n#[messages(cw20_allowances as Allowances)]\n#[messages(cw20_marketing as Marketing)]\n#[messages(cw20_minting as Minting)]\nimpl Cw20Base\u003c'_\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            token_info: Item::new(\"token_info\"),\n            marketing_info: Item::new(\"marketing_info\"),\n            logo: Item::new(\"logo\"),\n            balances: Map::new(\"balances\"),\n            allowances: Map::new(\"allowances\"),\n            allowances_spender: Map::new(\"allowances_spender\"),\n        }\n    }\n\n    pub fn create_accounts(\n        \u0026self,\n        deps: \u0026mut DepsMut,\n        accounts: \u0026[Cw20Coin],\n    ) -\u003e Result\u003cUint128, ContractError\u003e {\n        validate_accounts(accounts)?;\n\n        let mut total_supply = Uint128::zero();\n        for row in accounts {\n            let address = deps.api.addr_validate(\u0026row.address)?;\n            self.balances.save(deps.storage, \u0026address, \u0026row.amount)?;\n            total_supply += row.amount;\n        }\n\n        Ok(total_supply)\n    }\n\n    // this can be used to update a lower allowance - call bucket.update with proper keys\n    pub fn deduct_allowance(\n        \u0026self,\n        storage: \u0026mut dyn Storage,\n        owner: \u0026Addr,\n        spender: \u0026Addr,\n        block: \u0026BlockInfo,\n        amount: Uint128,\n    ) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n        let update_fn = |current: Option\u003cAllowanceResponse\u003e| -\u003e _ {\n            let allowance = current.ok_or(ContractError::NoAllowance)?;\n\n            if !allowance.expires.is_expired(block) {\n                // deduct the allowance if enough\n                let expires = allowance.expires;\n                let allowance = allowance\n                    .allowance\n                    .checked_sub(amount)\n                    .map_err(StdError::overflow)?;\n                Ok(AllowanceResponse { allowance, expires })\n            } else {\n                Err(ContractError::Expired)\n            }\n        };\n        self.allowances\n            .update(storage, (owner, spender), update_fn)?;\n        self.allowances_spender\n            .update(storage, (spender, owner), update_fn)\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        mut ctx: InstantiateCtx,\n        data: InstantiateMsgData,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let InstantiateMsgData {\n            name,\n            symbol,\n            decimals,\n            initial_balances,\n            mint,\n            marketing,\n        } = data;\n        set_contract_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n        // check valid token info\n        validate_msg(\u0026name, \u0026symbol, decimals)?;\n        // create initial accounts\n        let total_supply = self.create_accounts(\u0026mut ctx.deps, \u0026initial_balances)?;\n\n        ensure!(\n            !matches!(\n                mint.as_ref().and_then(|v| v.cap), Some(limit) if total_supply \u003e limit\n            ),\n            StdError::generic_err(\"Initial supply greater than cap\")\n        );\n\n        let mint = match mint {\n            Some(m) =\u003e Some(MinterData {\n                minter: ctx.deps.api.addr_validate(\u0026m.minter)?,\n                cap: m.cap,\n            }),\n            None =\u003e None,\n        };\n\n        // store token info\n        let data = TokenInfo {\n            name,\n            symbol,\n            decimals,\n            total_supply,\n            mint,\n        };\n        self.token_info.save(ctx.deps.storage, \u0026data)?;\n\n        if let Some(marketing) = marketing {\n            let logo = if let Some(logo) = marketing.logo {\n                verify_logo(\u0026logo)?;\n                self.logo.save(ctx.deps.storage, \u0026logo)?;\n\n                match logo {\n                    Logo::Url(url) =\u003e Some(LogoInfo::Url(url)),\n                    Logo::Embedded(_) =\u003e Some(LogoInfo::Embedded),\n                }\n            } else {\n                None\n            };\n\n            let data = MarketingInfoResponse {\n                project: marketing.project,\n                description: marketing.description,\n                marketing: marketing\n                    .marketing\n                    .map(|addr| ctx.deps.api.addr_validate(\u0026addr))\n                    .transpose()?,\n                logo,\n            };\n            self.marketing_info.save(ctx.deps.storage, \u0026data)?;\n        }\n\n        Ok(Response::default())\n    }\n\n    /// Transfer is a base message to move tokens to another account without triggering actions\n    #[msg(exec)]\n    fn transfer(\n        \u0026self,\n        ctx: ExecCtx,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(amount != Uint128::zero(), ContractError::InvalidZeroAmount);\n\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026recipient)?;\n\n        self.balances\n            .update(ctx.deps.storage, \u0026ctx.info.sender, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_sub(amount)?)\n            })?;\n        self.balances\n            .update(ctx.deps.storage, \u0026rcpt_addr, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_add(amount)?)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"transfer\")\n            .add_attribute(\"from\", ctx.info.sender)\n            .add_attribute(\"to\", recipient)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Burn is a base message to destroy tokens forever\n    #[msg(exec)]\n    fn burn(\u0026self, ctx: ExecCtx, amount: Uint128) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(amount != Uint128::zero(), ContractError::InvalidZeroAmount);\n\n        // lower balance\n        self.balances\n            .update(ctx.deps.storage, \u0026ctx.info.sender, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_sub(amount)?)\n            })?;\n        // reduce total_supply\n        self.token_info\n            .update(ctx.deps.storage, |mut info| -\u003e StdResult\u003c_\u003e {\n                info.total_supply = info.total_supply.checked_sub(amount)?;\n                Ok(info)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"burn\")\n            .add_attribute(\"from\", ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Send is a base message to transfer tokens to a contract and trigger an action\n    /// on the receiving contract.\n    #[msg(exec)]\n    fn send(\n        \u0026self,\n        ctx: ExecCtx,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(amount != Uint128::zero(), ContractError::InvalidZeroAmount);\n\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026contract)?;\n\n        // move the tokens to the contract\n        self.balances\n            .update(ctx.deps.storage, \u0026ctx.info.sender, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_sub(amount)?)\n            })?;\n        self.balances\n            .update(ctx.deps.storage, \u0026rcpt_addr, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_add(amount)?)\n            })?;\n        let res = Response::new()\n            .add_attribute(\"action\", \"send\")\n            .add_attribute(\"from\", \u0026ctx.info.sender)\n            .add_attribute(\"to\", \u0026contract)\n            .add_attribute(\"amount\", amount);\n\n        let msg = Cw20ReceiveMsg {\n            sender: ctx.info.sender.into(),\n            amount,\n            msg,\n        }\n        .into_cosmos_msg(contract)?;\n\n        let res = res.add_message(msg);\n        Ok(res)\n    }\n\n    /// Returns the current balance of the given address, 0 if unset.\n    #[msg(query)]\n    fn balance(\u0026self, ctx: QueryCtx, address: String) -\u003e StdResult\u003cBalanceResponse\u003e {\n        let address = ctx.deps.api.addr_validate(\u0026address)?;\n        let balance = self\n            .balances\n            .may_load(ctx.deps.storage, \u0026address)?\n            .unwrap_or_default();\n        Ok(BalanceResponse { balance })\n    }\n\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    #[msg(query)]\n    fn token_info(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n        let info = self.token_info.load(ctx.deps.storage)?;\n        let res = TokenInfoResponse {\n            name: info.name,\n            symbol: info.symbol,\n            decimals: info.decimals,\n            total_supply: info.total_supply,\n        };\n        Ok(res)\n    }\n\n    #[msg(migrate)]\n    fn migrate(\u0026self, ctx: MigrateCtx) -\u003e Result\u003cResponse, ContractError\u003e {\n        let original_version =\n            ensure_from_older_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n        if original_version \u003c \"0.14.0\".parse::\u003csemver::Version\u003e().unwrap() {\n            // Build reverse map of allowances per spender\n            let data = self\n                .allowances\n                .range(ctx.deps.storage, None, None, Order::Ascending)\n                .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            for ((owner, spender), allowance) in data {\n                self.allowances_spender\n                    .save(ctx.deps.storage, (\u0026spender, \u0026owner), \u0026allowance)?;\n            }\n        }\n        Ok(Response::default())\n    }\n}\n","traces":[{"line":36,"address":[1282720],"length":1,"stats":{"Line":1},"fn_name":"get_cap"},{"line":37,"address":[1282725],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[845895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1314928],"length":1,"stats":{"Line":9},"fn_name":"new"},{"line":85,"address":[1314951],"length":1,"stats":{"Line":10},"fn_name":null},{"line":86,"address":[1314974],"length":1,"stats":{"Line":9},"fn_name":null},{"line":87,"address":[1314997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1315022],"length":1,"stats":{"Line":11},"fn_name":null},{"line":89,"address":[1315049],"length":1,"stats":{"Line":9},"fn_name":null},{"line":90,"address":[1315076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1315200,1316102],"length":1,"stats":{"Line":10},"fn_name":"create_accounts"},{"line":99,"address":[1315285,1315392],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[1315338],"length":1,"stats":{"Line":10},"fn_name":null},{"line":102,"address":[1315453,1315545,1315369],"length":1,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[1315790,1315566],"length":1,"stats":{"Line":10},"fn_name":null},{"line":104,"address":[1315890,1315756,1315978],"length":1,"stats":{"Line":12},"fn_name":null},{"line":105,"address":[1315947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1315508],"length":1,"stats":{"Line":11},"fn_name":null},{"line":112,"address":[1316128],"length":1,"stats":{"Line":1},"fn_name":"deduct_allowance"},{"line":120,"address":[1250912],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":121,"address":[1250955,1251166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1251140,1251261,1251559],"length":1,"stats":{"Line":5},"fn_name":null},{"line":125,"address":[1251268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[1251310,1251337,1251595],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[1251326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[1251564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1251473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1251232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1316539,1316272,1316252],"length":1,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[1316256,1316511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[1316469,1316449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[1316453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[1322840,1316576,1318723],"length":1,"stats":{"Line":1},"fn_name":"instantiate"},{"line":148,"address":[1316631],"length":1,"stats":{"Line":11},"fn_name":null},{"line":149,"address":[1316735],"length":1,"stats":{"Line":9},"fn_name":null},{"line":150,"address":[1316767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1316787],"length":1,"stats":{"Line":10},"fn_name":null},{"line":152,"address":[1316811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[1316854],"length":1,"stats":{"Line":9},"fn_name":null},{"line":155,"address":[1317077,1317171,1316964],"length":1,"stats":{"Line":12},"fn_name":null},{"line":158,"address":[1317328,1317137,1317488],"length":1,"stats":{"Line":10},"fn_name":null},{"line":160,"address":[1317463,1317754,1317613],"length":1,"stats":{"Line":12},"fn_name":null},{"line":162,"address":[1318111,1318030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[1317961,1317911,1318013],"length":1,"stats":{"Line":13},"fn_name":null},{"line":164,"address":[1261744,1261753],"length":1,"stats":{"Line":16},"fn_name":"{closure#1}"},{"line":166,"address":[1318064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1318036],"length":1,"stats":{"Line":11},"fn_name":null},{"line":170,"address":[1318484,1318193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1318615,1318249,1318356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[1318460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[1318168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1319032,1319102,1319193],"length":1,"stats":{"Line":12},"fn_name":null},{"line":187,"address":[1319154,1322484,1319299],"length":1,"stats":{"Line":19},"fn_name":null},{"line":188,"address":[1319365,1319411],"length":1,"stats":{"Line":8},"fn_name":null},{"line":189,"address":[1319841,1319467,1319751],"length":1,"stats":{"Line":8},"fn_name":null},{"line":190,"address":[1319799,1320046,1319951],"length":1,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[1320003],"length":1,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[1320205],"length":1,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[1320371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[1319477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1319505],"length":1,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[1319545],"length":1,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[1320544,1320987,1320678,1319649,1319585],"length":1,"stats":{"Line":16},"fn_name":null},{"line":209,"address":[1321220,1321302,1320878],"length":1,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[1322516,1319401],"length":1,"stats":{"Line":12},"fn_name":null},{"line":217,"address":[1324638,1322864,1324538],"length":1,"stats":{"Line":1},"fn_name":"transfer"},{"line":223,"address":[1323103,1323145,1322914,1323014],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[1323069,1323422,1323217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[1323557,1323363,1323391,1323775],"length":1,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[1251824],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":229,"address":[1251909,1252032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1323651,1323821,1323675,1323992],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[1252096],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":233,"address":[1252304,1252181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1323913,1324087,1324251,1324172],"length":1,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[1324140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1324220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1324344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[1343378,1344011,1344674,1324720,1326098,1326159,1333384],"length":1,"stats":{"Line":2},"fn_name":"burn"},{"line":247,"address":[1324765,1324998,1324853,1324959],"length":1,"stats":{"Line":4},"fn_name":null},{"line":250,"address":[1324908,1324936,1325250,1325044],"length":1,"stats":{"Line":4},"fn_name":null},{"line":251,"address":[1252368],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":252,"address":[1252453,1252576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[1325670,1325158,1325293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1252640,1252950],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":257,"address":[1252666,1252865,1252737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[1252817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[1325810,1325718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[1325778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1325908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1328633,1326240],"length":1,"stats":{"Line":1},"fn_name":"send"},{"line":278,"address":[1326597,1326453,1326555,1326309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":280,"address":[1326520,1326670,1326878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[1327013,1327234,1326816,1326847],"length":1,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[1252992],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":285,"address":[1253200,1253077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[1327134,1327448,1327107,1327280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[1253264],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":289,"address":[1253349,1253472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[1327475,1327532,1327372],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[1327528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[1327663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[1327671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[1327904,1328278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1328115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1328801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[1334950,1356889,1334435,1330082,1330124,1356486,1329232,1356619],"length":1,"stats":{"Line":6},"fn_name":"balance"},{"line":311,"address":[1329376,1329551,1329280],"length":1,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[1330004,1329715,1329512,1329536,1329888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":314,"address":[1329516,1329824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[1330020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[1330144,1330898],"length":1,"stats":{"Line":2},"fn_name":"token_info"},{"line":322,"address":[1330177,1330252,1330777],"length":1,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[1330537],"length":1,"stats":{"Line":3},"fn_name":null},{"line":325,"address":[1330563],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[1330592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[1330600],"length":1,"stats":{"Line":5},"fn_name":null},{"line":329,"address":[1330698],"length":1,"stats":{"Line":5},"fn_name":null},{"line":333,"address":[1331492,1332846,1330928],"length":1,"stats":{"Line":1},"fn_name":"migrate"},{"line":334,"address":[1330963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[1331507,1331194,1332708,1331374],"length":1,"stats":{"Line":4},"fn_name":null},{"line":339,"address":[1331598,1331541,1331899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[1331545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[1331991,1332655,1331764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[1332400,1332543,1332268,1332311],"length":1,"stats":{"Line":3},"fn_name":null},{"line":345,"address":[1332479,1332272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[1331521,1332736],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":124,"coverable":127},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount,\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount,\n\n    #[error(\"Allowance is expired\")]\n    Expired,\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance,\n\n    #[error(\"Minting cannot exceed the cap\")]\n    CannotExceedCap,\n\n    #[error(\"Logo binary data exceeds 5KB limit\")]\n    LogoTooBig,\n\n    #[error(\"Invalid xml preamble for SVG\")]\n    InvalidXmlPreamble,\n\n    #[error(\"Invalid png header\")]\n    InvalidPngHeader,\n\n    #[error(\"Invalid expiration value\")]\n    InvalidExpiration,\n\n    #[error(\"Duplicate initial balance addresses\")]\n    DuplicateInitialBalanceAddresses,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","lib.rs"],"content":"pub mod allowances;\npub mod contract;\npub mod error;\npub mod marketing;\npub mod minting;\npub mod responses;\npub mod validation;\n\n#[cfg(test)]\nmod multitest;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","marketing.rs"],"content":"use crate::contract::Cw20Base;\nuse crate::error::ContractError;\nuse crate::validation::verify_logo;\nuse cosmwasm_std::{Response, StdError, StdResult};\nuse cw20_marketing::responses::{DownloadLogoResponse, LogoInfo, MarketingInfoResponse};\nuse cw20_marketing::{Cw20Marketing, EmbeddedLogo, Logo};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\n#[contract]\n#[messages(cw20_marketing as Cw20Marketing)]\nimpl Cw20Marketing for Cw20Base\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn update_marketing(\n        \u0026self,\n        ctx: ExecCtx,\n        project: Option\u003cString\u003e,\n        description: Option\u003cString\u003e,\n        marketing: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let mut marketing_info = self\n            .marketing_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        if marketing_info\n            .marketing\n            .as_ref()\n            .ok_or(ContractError::Unauthorized)?\n            != \u0026ctx.info.sender\n        {\n            return Err(ContractError::Unauthorized);\n        }\n\n        match project {\n            Some(empty) if empty.trim().is_empty() =\u003e marketing_info.project = None,\n            Some(project) =\u003e marketing_info.project = Some(project),\n            None =\u003e (),\n        }\n\n        match description {\n            Some(empty) if empty.trim().is_empty() =\u003e marketing_info.description = None,\n            Some(description) =\u003e marketing_info.description = Some(description),\n            None =\u003e (),\n        }\n\n        match marketing {\n            Some(empty) if empty.trim().is_empty() =\u003e marketing_info.marketing = None,\n            Some(marketing) =\u003e {\n                marketing_info.marketing = Some(ctx.deps.api.addr_validate(\u0026marketing)?)\n            }\n            None =\u003e (),\n        }\n\n        if marketing_info.project.is_none()\n            \u0026\u0026 marketing_info.description.is_none()\n            \u0026\u0026 marketing_info.marketing.is_none()\n            \u0026\u0026 marketing_info.logo.is_none()\n        {\n            self.marketing_info.remove(ctx.deps.storage);\n        } else {\n            self.marketing_info\n                .save(ctx.deps.storage, \u0026marketing_info)?;\n        }\n\n        let res = Response::new().add_attribute(\"action\", \"update_marketing\");\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    fn upload_logo(\u0026self, ctx: ExecCtx, logo: Logo) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let mut marketing_info = self\n            .marketing_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        verify_logo(\u0026logo)?;\n\n        if marketing_info\n            .marketing\n            .as_ref()\n            .ok_or(ContractError::Unauthorized)?\n            != \u0026ctx.info.sender\n        {\n            return Err(ContractError::Unauthorized);\n        }\n\n        self.logo.save(ctx.deps.storage, \u0026logo)?;\n\n        let logo_info = match logo {\n            Logo::Url(url) =\u003e LogoInfo::Url(url),\n            Logo::Embedded(_) =\u003e LogoInfo::Embedded,\n        };\n\n        marketing_info.logo = Some(logo_info);\n        self.marketing_info\n            .save(ctx.deps.storage, \u0026marketing_info)?;\n\n        let res = Response::new().add_attribute(\"action\", \"upload_logo\");\n        Ok(res)\n    }\n\n    #[msg(query)]\n    fn marketing_info(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cMarketingInfoResponse\u003e {\n        Ok(self\n            .marketing_info\n            .may_load(ctx.deps.storage)?\n            .unwrap_or_default())\n    }\n\n    #[msg(query)]\n    fn download_logo(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cDownloadLogoResponse\u003e {\n        let logo = self.logo.load(ctx.deps.storage)?;\n        match logo {\n            Logo::Embedded(EmbeddedLogo::Svg(logo)) =\u003e Ok(DownloadLogoResponse {\n                mime_type: \"image/svg+xml\".to_owned(),\n                data: logo,\n            }),\n            Logo::Embedded(EmbeddedLogo::Png(logo)) =\u003e Ok(DownloadLogoResponse {\n                mime_type: \"image/png\".to_owned(),\n                data: logo,\n            }),\n            Logo::Url(_) =\u003e Err(StdError::not_found(\"logo\")),\n        }\n    }\n}\n","traces":[{"line":16,"address":[1370608,1372458,1375175],"length":1,"stats":{"Line":4},"fn_name":"update_marketing"},{"line":23,"address":[1371184,1370836,1371020,1370749,1371543,1370682,1371102],"length":1,"stats":{"Line":20},"fn_name":null},{"line":25,"address":[1371038,1370734],"length":1,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[1371479,1370985],"length":1,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[1371649,1371453,1371850,1371903,1371764],"length":1,"stats":{"Line":16},"fn_name":null},{"line":31,"address":[1371622,1371786],"length":1,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[1371736],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[1371952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1371917],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[1372052,1372266],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[1372469,1372173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1372010],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[1372647,1372831],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[1373023,1372738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1372605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1373185,1373369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1373284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1373625,1373315,1373895],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[1373151,1374028,1374071,1374175,1374123],"length":1,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[1374044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1374100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1374160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1374260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1374237,1374422,1374210,1374298],"length":1,"stats":{"Line":11},"fn_name":null},{"line":65,"address":[1374214,1374358],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[1374288,1374799],"length":1,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[1374855],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[1377690,1375200,1377817],"length":1,"stats":{"Line":3},"fn_name":"upload_logo"},{"line":74,"address":[1375243,1375278,1375358,1375696,1376037,1375621,1375542],"length":1,"stats":{"Line":10},"fn_name":null},{"line":76,"address":[1375557,1375263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[1375507,1375973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1376121,1376178,1375958],"length":1,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[1376509,1376429,1376317,1376153],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[1376445,1376290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1376401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1376592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1376561,1376642,1376730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[1376699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1376826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1376920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1376932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1377139,1377163,1377309],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[1377245,1377143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[1377230,1377446],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[1377499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1377840,1378263],"length":1,"stats":{"Line":4},"fn_name":"marketing_info"},{"line":107,"address":[1378188,1377891,1377950,1378237,1377872],"length":1,"stats":{"Line":16},"fn_name":null},{"line":109,"address":[1378124,1377876],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[1379151,1379681,1378304],"length":1,"stats":{"Line":4},"fn_name":"download_logo"},{"line":115,"address":[1378635,1378337,1378437],"length":1,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[1378790,1378598],"length":1,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[1378798,1379320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[1378832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1379272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1378862,1379020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1378896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1378972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1378756,1379484],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":54,"coverable":58},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","minting.rs"],"content":"use crate::contract::{Cw20Base, MinterData};\nuse crate::error::ContractError;\nuse cosmwasm_std::{Response, StdResult, Uint128};\nuse cw20_minting::responses::MinterResponse;\nuse cw20_minting::Cw20Minting;\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\n#[contract]\n#[messages(cw20_minting as Cw20Minting)]\nimpl Cw20Minting for Cw20Base\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn mint(\n        \u0026self,\n        ctx: ExecCtx,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        if amount == Uint128::zero() {\n            return Err(ContractError::InvalidZeroAmount);\n        }\n\n        let mut config = self\n            .token_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        if config\n            .mint\n            .as_ref()\n            .ok_or(ContractError::Unauthorized)?\n            .minter\n            != ctx.info.sender\n        {\n            return Err(ContractError::Unauthorized);\n        }\n\n        // update supply and enforce cap\n        config.total_supply += amount;\n        if let Some(limit) = config.get_cap() {\n            if config.total_supply \u003e limit {\n                return Err(ContractError::CannotExceedCap);\n            }\n        }\n        self.token_info.save(ctx.deps.storage, \u0026config)?;\n\n        // add amount to recipient balance\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026recipient)?;\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026rcpt_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n        )?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"mint\")\n            .add_attribute(\"to\", recipient)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    fn update_minter(\n        \u0026self,\n        ctx: ExecCtx,\n        new_minter: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let mut config = self\n            .token_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        let mint = config.mint.as_ref().ok_or(ContractError::Unauthorized)?;\n        if mint.minter != ctx.info.sender {\n            return Err(ContractError::Unauthorized);\n        }\n\n        let minter_data = new_minter\n            .map(|new_minter| ctx.deps.api.addr_validate(\u0026new_minter))\n            .transpose()?\n            .map(|minter| MinterData {\n                minter,\n                cap: mint.cap,\n            });\n\n        config.mint = minter_data;\n\n        self.token_info.save(ctx.deps.storage, \u0026config)?;\n\n        let resp = Response::new()\n            .add_attribute(\"action\", \"update_minter\")\n            .add_attribute(\n                \"new_minter\",\n                config\n                    .mint\n                    .map(|m| m.minter.into_string())\n                    .unwrap_or_else(|| \"None\".to_string()),\n            );\n        Ok(resp)\n    }\n\n    #[msg(query)]\n    fn minter(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cOption\u003cMinterResponse\u003e\u003e {\n        let meta = self.token_info.load(ctx.deps.storage)?;\n        let minter = match meta.mint {\n            Some(m) =\u003e Some(MinterResponse {\n                minter: m.minter.into(),\n                cap: m.cap,\n            }),\n            None =\u003e None,\n        };\n        Ok(minter)\n    }\n}\n","traces":[{"line":15,"address":[1382582,1382642,1379696],"length":1,"stats":{"Line":1},"fn_name":"mint"},{"line":21,"address":[1379752,1379848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[1379938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1380294,1379926,1380018,1380218,1380722],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[1380230,1379911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1380658,1380183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1380638,1380901,1380821,1380985,1381031],"length":1,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[1380794,1380921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1380897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1381077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1381037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1381132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1381311,1381236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1381322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1381277,1381372,1381473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[1381434,1381583,1381795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1381729,1381756,1381930,1382101],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[1381733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[751767,751696],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":57,"address":[1382289,1382022,1382205],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[1382258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1382388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1385453,1385271,1382672],"length":1,"stats":{"Line":2},"fn_name":"update_minter"},{"line":70,"address":[1382715,1383034,1383110,1383177,1382834,1383555,1382770],"length":1,"stats":{"Line":11},"fn_name":null},{"line":72,"address":[1382755,1383046],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[1382999,1383491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[1383631,1383762,1383471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[1383738,1383869],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[1383984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1383885,1383940,1384034,1384153,1384253],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[751840,751875],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":83,"address":[752032,752059],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":85,"address":[752043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1384298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1384482,1384550,1384625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[1384610,1384984,1384794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[1384977,1384850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[752107,752096],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":99,"address":[752172,752160],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":101,"address":[1385048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1386093,1386366,1385472],"length":1,"stats":{"Line":1},"fn_name":"minter"},{"line":106,"address":[1385709,1385504,1385586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1385676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1385842,1386009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1385889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1385985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1385825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1386181],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":47,"coverable":48},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","allowances_tests.rs"],"content":"use cosmwasm_std::{Binary, StdError, Timestamp, Uint128};\nuse cw20_allowances::responses::{\n    AllAllowancesResponse, AllSpenderAllowancesResponse, AllowanceInfo, AllowanceResponse,\n    SpenderAllowanceInfo,\n};\nuse cw_multi_test::next_block;\nuse cw_utils::Expiration;\nuse sylvia::multitest::App;\n\nuse crate::allowances::test_utils::Cw20Allowances;\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::InstantiateMsgData;\nuse crate::error::ContractError;\nuse crate::multitest::receiver_contract::multitest_utils::CodeId as ReceiverCodeId;\nuse crate::responses::Cw20Coin;\n\n#[test]\nfn increase_decrease_allowances() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: Uint128::new(12340000),\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let allowances = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowances, AllowanceResponse::default());\n\n    // set allowance with height expiration\n    let allowance = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // decrease it a bit with no expire set - stays the same\n    let lower = Uint128::new(4444);\n    let allowance = allowance.checked_sub(lower).unwrap();\n    contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(spender.to_string(), lower, None)\n        .call(owner)\n        .unwrap();\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // increase it some more and override the expires\n    let raise = Uint128::new(87654);\n    let allowance = allowance + raise;\n    let expires = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), raise, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // decrease it below 0\n    contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(spender.to_string(), Uint128::new(99988647623876347), None)\n        .call(owner)\n        .unwrap();\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse::default());\n}\n\n#[test]\nfn allowances_independent() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let spender2 = \"addr0003\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: Uint128::new(12340000),\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse::default());\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse::default());\n\n    // set allowance with height expiration\n    let allowance = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // set other allowance with no expiration\n    let allowance2 = Uint128::new(87654);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), allowance2, None)\n        .call(owner)\n        .unwrap();\n\n    // check they are proper\n    let expect_one = AllowanceResponse { allowance, expires };\n    let expect_two = AllowanceResponse {\n        allowance: allowance2,\n        expires: Expiration::Never {},\n    };\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_one);\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_two);\n\n    // also allow spender -\u003e spender2 with no interference\n    let allowance3 = Uint128::new(1821);\n    let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), allowance3, Some(expires3))\n        .call(spender)\n        .unwrap();\n\n    let expect_three = AllowanceResponse {\n        allowance: allowance3,\n        expires: expires3,\n    };\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_one);\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_two);\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(spender.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_three);\n}\n\n#[test]\nfn no_self_allowance() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: Uint128::new(12340000),\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // self-allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(owner.to_string(), Uint128::new(7777), None)\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotSetOwnAccount);\n\n    // decrease self-allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(owner.to_string(), Uint128::new(7777), None)\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotSetOwnAccount);\n}\n\n#[test]\nfn transfer_from_self_to_self() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // valid transfer of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), owner.to_string(), transfer)\n        .call(owner)\n        .unwrap();\n\n    // make sure amount of money is the same\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(balance_resp.balance, amount);\n}\n\n#[test]\nfn transfer_from_owner_requires_no_allowance() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let rcpt = \"addr0003\";\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // valid transfer of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), transfer)\n        .call(owner)\n        .unwrap();\n\n    // make sure money arrived\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    let balance_resp = contract.balance(rcpt.to_string()).unwrap();\n    assert_eq!(balance_resp.balance, transfer);\n}\n\n#[test]\nfn transfer_from_respects_limits() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let rcpt = \"addr0003\";\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // provide an allowance\n    let allowance = Uint128::new(77777);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // valid transfer of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), transfer)\n        .call(spender)\n        .unwrap();\n\n    // make sure money arrived\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    let balance_resp = contract.balance(rcpt.to_string()).unwrap();\n    assert_eq!(balance_resp.balance, transfer);\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {}\n        }\n    );\n\n    // cannot send more than the allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // let us increase limit, but set the expiration to expire in the next block\n    let next_block_height = app.app.borrow().block_info().height + 1;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(\n            spender.to_string(),\n            Uint128::new(1000),\n            Some(Expiration::AtHeight(next_block_height)),\n        )\n        .call(owner)\n        .unwrap();\n\n    // move to next block\n    app.app.borrow_mut().update_block(next_block);\n\n    // we should now get the expiration error\n    let err = contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Expired));\n}\n\n#[test]\nfn burn_from_respects_limits() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // provide an allowance\n    let allowance = Uint128::new(77777);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // valid burn of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .burn_from(owner.to_string(), transfer)\n        .call(spender)\n        .unwrap();\n\n    // make sure money burnt\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {}\n        }\n    );\n\n    // cannot burn more than the allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .burn_from(owner.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // let us increase limit, but set the expiration to expire in the next block\n    let next_block_height = app.app.borrow().block_info().height + 1;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(\n            spender.to_string(),\n            Uint128::new(1000),\n            Some(Expiration::AtHeight(next_block_height)),\n        )\n        .call(owner)\n        .unwrap();\n\n    // move to next block\n    app.app.borrow_mut().update_block(next_block);\n\n    // we should now get the expiration error\n    let err = contract\n        .cw20_allowances_proxy()\n        .burn_from(owner.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Expired));\n}\n\n// Ignoring currently due to some issue with unsupported msg being sent in send_from\n#[test]\nfn send_from_respects_limits() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let owner2 = \"addr0003\";\n    let spender = \"addr0002\";\n    let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n    let receiver_code_id = ReceiverCodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let receiver_contract = receiver_code_id\n        .instantiate()\n        .with_label(\"cool-dex\")\n        .call(owner2)\n        .unwrap();\n\n    // provide an allowance\n    let allowance = Uint128::new(77777);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // valid send of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .send_from(\n            owner.to_string(),\n            receiver_contract.contract_addr.to_string(),\n            transfer,\n            send_msg.clone(),\n        )\n        .call(spender)\n        .unwrap();\n\n    // make sure money burnt\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {}\n        }\n    );\n\n    // cannot send more than the allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .send_from(\n            owner.to_string(),\n            receiver_contract.contract_addr.to_string(),\n            Uint128::new(33443),\n            send_msg.clone(),\n        )\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // let us increase limit, but set the expiration to expire in the next block\n    let next_block_height = app.app.borrow().block_info().height + 1;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(\n            spender.to_string(),\n            Uint128::new(1000),\n            Some(Expiration::AtHeight(next_block_height)),\n        )\n        .call(owner)\n        .unwrap();\n\n    // move to next block\n    app.app.borrow_mut().update_block(next_block);\n\n    // we should now get the expiration error\n    let err = contract\n        .cw20_allowances_proxy()\n        .send_from(\n            owner.to_string(),\n            receiver_contract.contract_addr.to_string(),\n            Uint128::new(33443),\n            send_msg,\n        )\n        .call(spender)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Expired));\n}\n\n#[test]\nfn no_past_expiration() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let start_amount = Uint128::new(999999);\n    let allowance = Uint128::new(7777);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // set allowance with height expiration at current block height\n    let block_height = app.app.borrow().block_info().height;\n    let expires = Expiration::AtHeight(block_height);\n\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap_err();\n\n    // ensure it is rejected\n    assert_eq!(ContractError::InvalidExpiration, err);\n\n    // set allowance with time expiration in the past\n    let block_time = app.app.borrow().block_info().time;\n    let expires = Expiration::AtTime(block_time.minus_seconds(1));\n\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap_err();\n\n    // ensure it is rejected\n    assert_eq!(ContractError::InvalidExpiration, err);\n\n    // set allowance with height expiration at next block height\n    let block_height = app.app.borrow().block_info().height + 1;\n    let expires = Expiration::AtHeight(block_height);\n\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // set allowance with time expiration in the future\n    let block_time = app.app.borrow().block_info().time;\n    let expires = Expiration::AtTime(block_time.plus_seconds(10));\n\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance + allowance, // we increased twice\n            expires\n        }\n    );\n\n    // decrease with height expiration at current block height\n    let block_height = app.app.borrow().block_info().height;\n    let expires = Expiration::AtHeight(block_height);\n\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap_err();\n\n    // ensure it is rejected\n    assert_eq!(ContractError::InvalidExpiration, err);\n\n    // decrease with height expiration at next block height\n    let block_height = app.app.borrow().block_info().height + 1;\n    let expires = Expiration::AtHeight(block_height);\n\n    contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n}\n\n#[test]\nfn query_allowances() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let spender2 = \"addr0003\";\n    let start_amount = Uint128::new(999999);\n    let allowance = Uint128::new(7777);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // check all allowances\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse { allowances: vec![] }\n    );\n\n    // increase spender allowances\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // check all allowances\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender.to_string(),\n                allowance,\n                expires: Expiration::Never {}\n            }]\n        }\n    );\n\n    // check spender allowances\n    let all_spender_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_spender_allowances_resp,\n        AllSpenderAllowancesResponse {\n            allowances: vec![SpenderAllowanceInfo {\n                owner: owner.to_string(),\n                allowance,\n                expires: Expiration::Never {}\n            }]\n        }\n    );\n\n    // increase spender2 allowances\n    let increased_allowances = allowance + allowance;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), increased_allowances, None)\n        .call(owner)\n        .unwrap();\n\n    // check all allowances\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse {\n            allowances: vec![\n                AllowanceInfo {\n                    spender: spender.to_string(),\n                    allowance,\n                    expires: Expiration::Never {}\n                },\n                AllowanceInfo {\n                    spender: spender2.to_string(),\n                    allowance: increased_allowances,\n                    expires: Expiration::Never {}\n                }\n            ]\n        }\n    );\n\n    // check all allowances with limit\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, Some(1))\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender.to_string(),\n                allowance,\n                expires: Expiration::Never {}\n            },]\n        }\n    );\n}\n\n#[test]\nfn query_all_allowances_works() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let spender2 = \"addr0003\";\n    let start_amount = Uint128::new(12340000);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances, vec![]);\n\n    // set allowance with height expiration\n    let allow1 = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow1, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // set allowance with no expiration\n    let allow2 = Uint128::new(54321);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), allow2, None)\n        .call(owner)\n        .unwrap();\n\n    // query list gets 2\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances.len(), 2);\n\n    // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, Some(1))\n        .unwrap();\n    assert_eq!(\n        resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender.to_string(),\n                allowance: allow1,\n                expires\n            }]\n        }\n    );\n\n    // next one is spender2\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), Some(spender.to_string()), Some(10000))\n        .unwrap();\n    assert_eq!(\n        resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender2.to_string(),\n                allowance: allow2,\n                expires: Expiration::Never {}\n            }]\n        }\n    );\n}\n\n#[test]\nfn all_spender_allowances_on_two_contracts() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let owner2 = \"addr0003\";\n    let spender = \"addr0002\";\n    let start_amount = Uint128::new(12340000);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances, vec![]);\n\n    // set allowance with height expiration\n    let allow1 = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow1, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // set allowance with no expiration, from the other owner\n    let contract2 = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner2)\n        .unwrap();\n\n    let allow2 = Uint128::new(54321);\n    contract2\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow2, None)\n        .call(owner2)\n        .unwrap();\n\n    // query list on both contracts\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances.len(), 1);\n\n    let resp = contract2\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances.len(), 1);\n}\n\n#[test]\nfn query_all_accounts_works() {\n    let app = App::default();\n\n    // insert order and lexicographical order are different\n    let owner = \"owner\";\n    let acct2 = \"zebra\";\n    let acct3 = \"nice\";\n    let acct4 = \"aaaardvark\";\n    let start_amount = Uint128::new(12340000);\n    let expected_order = [\n        acct4.to_string(),\n        acct3.to_string(),\n        owner.to_string(),\n        acct2.to_string(),\n    ];\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // put money everywhere (to create balanaces)\n    contract\n        .transfer(acct2.to_string(), Uint128::new(222222))\n        .call(owner)\n        .unwrap();\n    contract\n        .transfer(acct3.to_string(), Uint128::new(333333))\n        .call(owner)\n        .unwrap();\n    contract\n        .transfer(acct4.to_string(), Uint128::new(444444))\n        .call(owner)\n        .unwrap();\n\n    // make sure we get the proper results\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(None, None)\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order);\n\n    // let's do pagination\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(None, Some(2))\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order[0..2].to_vec());\n\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(Some(resp.accounts[1].clone()), Some(1))\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order[2..3].to_vec());\n\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(Some(resp.accounts[0].clone()), Some(777))\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order[3..].to_vec());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","base_tests.rs"],"content":"use cosmwasm_std::{Addr, Binary, StdError, Uint128};\nuse cw20_allowances::responses::{AllAllowancesResponse, SpenderAllowanceInfo};\nuse cw_utils::Expiration;\nuse sylvia::multitest::App;\n\nuse crate::allowances::test_utils::Cw20Allowances;\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::InstantiateMsgData;\nuse crate::error::ContractError;\nuse crate::multitest::receiver_contract::multitest_utils::CodeId as ReceiverCodeId;\nuse crate::responses::{BalanceResponse, Cw20Coin, TokenInfoResponse};\n\n#[test]\nfn basic() {\n    let app = App::default();\n\n    let amount = Uint128::from(11223344u128);\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.token_info().unwrap();\n\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            total_supply: amount,\n        }\n    );\n\n    let resp = contract.balance(owner.to_string()).unwrap();\n\n    assert_eq!(resp, BalanceResponse { balance: amount });\n}\n\n#[test]\nfn instantiate_multiple_accounts() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let amount1 = Uint128::from(11223344u128);\n    let addr1 = \"addr0001\";\n    let amount2 = Uint128::from(7890987u128);\n    let addr2 = \"addr0002\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    // Fails with duplicate addresses\n    let err = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 6,\n            initial_balances: vec![\n                Cw20Coin {\n                    address: addr1.to_owned(),\n                    amount: amount1,\n                },\n                Cw20Coin {\n                    address: addr1.to_owned(),\n                    amount: amount2,\n                },\n            ],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::DuplicateInitialBalanceAddresses);\n\n    // Works with unique addresses\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Bash Token\".to_string(),\n            symbol: \"BASH\".to_string(),\n            decimals: 6,\n            initial_balances: vec![\n                Cw20Coin {\n                    address: addr1.into(),\n                    amount: amount1,\n                },\n                Cw20Coin {\n                    address: addr2.into(),\n                    amount: amount2,\n                },\n            ],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.token_info().unwrap();\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Bash Token\".to_string(),\n            symbol: \"BASH\".to_string(),\n            decimals: 6,\n            total_supply: amount1 + amount2,\n        }\n    );\n    let resp = contract.balance(addr1.to_string()).unwrap();\n    assert_eq!(resp.balance, amount1);\n    let resp = contract.balance(addr2.to_string()).unwrap();\n    assert_eq!(resp.balance, amount2);\n}\n\n#[test]\nfn queries_work() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let amount = Uint128::from(12340000u128);\n    let addr = Addr::unchecked(\"addr0001\");\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.token_info().unwrap();\n\n    // Check meta query\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            total_supply: amount\n        }\n    );\n\n    // Check owner balance\n    let resp = contract.balance(owner.to_string()).unwrap();\n\n    assert_eq!(resp.balance, amount);\n\n    // Check addr balance (Empty)\n    let resp = contract.balance(addr.to_string()).unwrap();\n\n    assert_eq!(resp.balance, Uint128::zero());\n}\n\n#[test]\nfn transfer() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let addr = \"addr0001\";\n    let amount = Uint128::from(12340000u128);\n    let transfer = Uint128::from(76543u128);\n    let too_much = Uint128::from(12340321u128);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // cannot transfer nothing\n    let err = contract\n        .transfer(addr.to_string(), Uint128::zero())\n        .call(owner)\n        .unwrap_err();\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // cannot send more than we have\n    let err = contract\n        .transfer(addr.to_string(), too_much)\n        .call(owner)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // cannot send from empty account\n    let err = contract\n        .transfer(owner.to_string(), transfer)\n        .call(addr)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // valid transfer\n    contract\n        .transfer(addr.to_string(), transfer)\n        .call(owner)\n        .unwrap();\n\n    // Check balance\n    let remainder = amount.checked_sub(transfer).unwrap();\n\n    let resp = contract.balance(addr.to_string()).unwrap();\n    assert_eq!(resp.balance, transfer);\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, remainder);\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n}\n\n#[test]\nfn burn() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let addr = \"addr0001\";\n    let amount = Uint128::from(12340000u128);\n    let burn = Uint128::from(76543u128);\n    let too_much = Uint128::from(12340321u128);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // cannot burn nothing\n    let err = contract.burn(Uint128::zero()).call(owner).unwrap_err();\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n\n    // cannot burn more than we have\n    let err = contract.burn(too_much).call(owner).unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n\n    // cannot send from empty account\n    let err = contract.burn(burn).call(addr).unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // valid burn reduces total supply\n    contract.burn(burn).call(owner).unwrap();\n\n    // check balance\n    let remainder = amount.checked_sub(burn).unwrap();\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, remainder);\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, remainder);\n}\n\n#[test]\nfn send() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let amount = Uint128::from(12340000u128);\n    let too_much = Uint128::from(12340321u128);\n    let transfer = Uint128::from(76543u128);\n    let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    // Receiver contract\n    let receiver_code_id = ReceiverCodeId::store_code(\u0026app);\n    let receiver_contract = receiver_code_id\n        .instantiate()\n        .with_label(\"cool-dex\")\n        .call(owner)\n        .unwrap();\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .send(\n            receiver_contract.contract_addr.to_string(),\n            Uint128::zero(),\n            send_msg.clone(),\n        )\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // cannot send more than we have\n    let err = contract\n        .send(\n            receiver_contract.contract_addr.to_string(),\n            too_much,\n            send_msg.clone(),\n        )\n        .call(owner)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // valid transfer\n    contract\n        .send(\n            receiver_contract.contract_addr.to_string(),\n            transfer,\n            send_msg,\n        )\n        .call(owner)\n        .unwrap();\n\n    // ensure balance is properly transferred\n    let remainder = amount.checked_sub(transfer).unwrap();\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, remainder);\n    let resp = contract\n        .balance(receiver_contract.contract_addr.to_string())\n        .unwrap();\n    assert_eq!(resp.balance, transfer);\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n}\n\n#[test]\nfn migrate() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let spender = \"addr0001\";\n    let code_id = CodeId::store_code(\u0026app);\n    let amount = Uint128::new(100);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Token\".to_string(),\n            symbol: \"TOKEN\".to_string(),\n            decimals: 6,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .with_admin(Some(owner))\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp, AllAllowancesResponse::default());\n\n    // Set allowance\n    let allow1 = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow1, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // Now migrate\n    contract.migrate().call(owner, code_id.code_id()).unwrap();\n\n    // Smoke check that the contract still works.\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, Uint128::new(100));\n\n    // Confirm that the allowance per spender is there\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(\n        resp.allowances,\n        \u0026[SpenderAllowanceInfo {\n            owner: owner.to_string(),\n            allowance: allow1,\n            expires\n        }]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","marketing_tests.rs"],"content":"use cosmwasm_std::{Addr, StdError};\nuse cw20_marketing::responses::{DownloadLogoResponse, LogoInfo, MarketingInfoResponse};\nuse cw20_marketing::{EmbeddedLogo, Logo};\nuse sylvia::multitest::App;\n\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::{InstantiateMarketingInfo, InstantiateMsgData};\nuse crate::error::ContractError;\nuse crate::marketing::test_utils::Cw20Marketing;\n\nconst PNG_HEADER: [u8; 8] = [0x89, b'P', b'N', b'G', 0x0d, 0x0a, 0x1a, 0x0a];\n\n#[test]\nfn update_unauthorised() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(\"marketing\".to_owned()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .update_marketing(\n            Some(\"New project\".to_owned()),\n            Some(\"Better description\".to_owned()),\n            Some(\"creator\".to_owned()),\n        )\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::Unauthorized);\n\n    // Ensure marketing didn't change\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(\"marketing\")),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_project() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(Some(\"New project\".to_owned()), None, None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"New project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn clear_project() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(Some(\"\".to_owned()), None, None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: None,\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_description() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, Some(\"Better description\".to_owned()), None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Better description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn clear_description() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, Some(\"\".to_owned()), None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: None,\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_marketing() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, None, Some(\"marketing\".to_owned()))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(\"marketing\")),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_marketing_invalid() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, None, Some(\"m\".to_owned()))\n        .call(owner)\n        .unwrap_err();\n\n    assert!(\n        matches!(err, ContractError::Std(_)),\n        \"Expected Std error, received: {}\",\n        err\n    );\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn clear_marketing() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, None, Some(\"\".to_owned()))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: None,\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_url() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Url(\"new_url\".to_owned()))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"new_url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_png() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Png(PNG_HEADER.into())))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Embedded),\n        }\n    );\n\n    let resp = contract.cw20_marketing_proxy().download_logo().unwrap();\n    assert_eq!(\n        resp,\n        DownloadLogoResponse {\n            mime_type: \"image/png\".to_owned(),\n            data: PNG_HEADER.into(),\n        }\n    );\n}\n\n#[test]\nfn update_logo_svg() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = \"\u003c?xml version=\\\"1.0\\\"?\u003e\u003csvg\u003e\u003c/svg\u003e\".as_bytes();\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Svg(img.into())))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Embedded),\n        }\n    );\n\n    let resp = contract.cw20_marketing_proxy().download_logo().unwrap();\n    assert_eq!(\n        resp,\n        DownloadLogoResponse {\n            mime_type: \"image/svg+xml\".to_owned(),\n            data: img.into(),\n        }\n    );\n}\n\n#[test]\nfn update_logo_png_oversized() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = [\u0026PNG_HEADER[..], \u0026[1; 6000][..]].concat();\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Png(img.into())))\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::LogoTooBig);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_svg_oversized() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = [\n        \"\u003c?xml version=\\\"1.0\\\"?\u003e\u003csvg\u003e\",\n        std::str::from_utf8(\u0026[b'x'; 6000]).unwrap(),\n        \"\u003c/svg\u003e\",\n    ]\n    .concat()\n    .into_bytes();\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Svg(img.into())))\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::LogoTooBig);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_png_invalid() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = \u0026[1];\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Png(img.into())))\n        .call(owner)\n        .unwrap_err();\n    assert_eq!(err, ContractError::InvalidPngHeader);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_svg_invalid() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = \u0026[1];\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Svg(img.into())))\n        .call(owner)\n        .unwrap_err();\n    assert_eq!(err, ContractError::InvalidXmlPreamble);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","minting_tests.rs"],"content":"use cosmwasm_std::{StdError, Uint128};\nuse cw20_minting::responses::MinterResponse;\nuse sylvia::multitest::App;\n\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::InstantiateMsgData;\nuse crate::error::ContractError;\nuse crate::minting::test_utils::Cw20Minting;\nuse crate::responses::{Cw20Coin, TokenInfoResponse};\n\n#[test]\nfn mintable() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let amount = Uint128::new(11223344);\n    let limit = Uint128::new(511223344);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // read token info\n    let resp = contract.token_info().unwrap();\n\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            total_supply: amount,\n        }\n    );\n\n    // get owner balance\n    let resp = contract.balance(owner.to_string()).unwrap();\n\n    assert_eq!(resp.balance, Uint128::new(11223344));\n\n    // get minter balance\n    let resp = contract.balance(minter.to_string()).unwrap();\n\n    assert_eq!(resp.balance, Uint128::new(0));\n\n    // get minter\n    let resp = contract.cw20_minting_proxy().minter().unwrap();\n\n    assert_eq!(\n        resp,\n        Some(MinterResponse {\n            minter: minter.to_string(),\n            cap: Some(limit),\n        })\n    );\n}\n\n#[test]\nfn mintable_over_cap() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let amount = Uint128::new(11223344);\n    let limit = Uint128::new(11223300);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let err = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Initial supply greater than cap\").into()\n    );\n}\n\n#[test]\nfn can_mint_by_minter() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let winner = \"lucky\";\n    let prize = Uint128::new(222_222_222);\n    let limit = Uint128::new(511223344);\n    let amount = Uint128::new(11223344);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // minter can mint coins to some winner\n    contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), prize)\n        .call(minter)\n        .unwrap();\n\n    // but cannot mint nothing\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::zero())\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // but if it exceeds cap (even over multiple rounds), it fails\n    // cap is enforced\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::new(333_222_222))\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotExceedCap);\n}\n\n#[test]\nfn others_cannot_mint() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let winner = \"lucky\";\n    let prize = Uint128::new(222_222_222);\n    let limit = Uint128::new(511223344);\n    let amount = Uint128::new(1234);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // minter can mint coins to some winner\n    contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), prize)\n        .call(minter)\n        .unwrap();\n\n    // but cannot mint nothing\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::zero())\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // but if it exceeds cap (even over multiple rounds), it fails\n    // cap is enforced\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::new(333_222_222))\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotExceedCap);\n}\n\n#[test]\nfn minter_can_update_minter_but_not_cap() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let new_minter = \"new_minter\";\n    let amount = Uint128::new(1234);\n    let cap = Some(Uint128::from(3000000u128));\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap,\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // minter can mint coins to some winner\n    contract\n        .cw20_minting_proxy()\n        .update_minter(Some(new_minter.to_string()))\n        .call(minter)\n        .unwrap();\n\n    let resp = contract.cw20_minting_proxy().minter().unwrap().unwrap();\n    assert_eq!(\n        resp,\n        MinterResponse {\n            minter: new_minter.to_string(),\n            cap\n        }\n    );\n}\n\n#[test]\nfn others_cannot_update_minter() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let new_minter = \"new_minter\";\n    let amount = Uint128::new(1234);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_minting_proxy()\n        .update_minter(Some(new_minter.to_string()))\n        .call(new_minter)\n        .unwrap_err();\n    assert_eq!(err, ContractError::Unauthorized);\n}\n\n#[test]\nfn unset_minter() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let winner = \"lucky\";\n    let amount = Uint128::new(1234);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // Unset minter\n    contract\n        .cw20_minting_proxy()\n        .update_minter(None)\n        .call(minter)\n        .unwrap();\n\n    let resp = contract.cw20_minting_proxy().minter().unwrap();\n    assert_eq!(resp, None);\n\n    // Old minter can no longer mint\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), amount)\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::Unauthorized);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","receiver.rs"],"content":"use cosmwasm_std::{Binary, Response, StdError, Uint128};\nuse sylvia::types::ExecCtx;\nuse sylvia::{contract, interface, schemars};\n\nuse super::receiver_contract::ReceiverContract;\n\n#[interface]\npub trait Receiver {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn receive(\n        \u0026self,\n        ctx: ExecCtx,\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n}\n\n#[contract]\nimpl Receiver for ReceiverContract {\n    type Error = StdError;\n\n    #[msg(exec)]\n    fn receive(\n        \u0026self,\n        _ctx: ExecCtx,\n        _sender: String,\n        _amount: cosmwasm_std::Uint128,\n        _msg: cosmwasm_std::Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        Ok(Response::default())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","receiver_contract.rs"],"content":"use cosmwasm_std::{Response, StdResult};\nuse sylvia::{contract, schemars, types::InstantiateCtx};\n\nuse super::receiver;\npub struct ReceiverContract {}\n\n#[contract]\n#[messages(receiver as Receiver)]\nimpl ReceiverContract {\n    pub const fn new() -\u003e Self {\n        Self {}\n    }\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest.rs"],"content":"mod allowances_tests;\nmod base_tests;\nmod marketing_tests;\nmod minting_tests;\nmod receiver;\nmod receiver_contract;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{to_binary, Addr, Binary, CosmosMsg, StdResult, Uint128, WasmMsg};\nuse std::fmt;\n\n/// Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg\n#[cw_serde]\npub struct Cw20ReceiveMsg {\n    pub sender: String,\n    pub amount: Uint128,\n    pub msg: Binary,\n}\n\nimpl Cw20ReceiveMsg {\n    /// serializes the message\n    pub fn into_binary(self) -\u003e StdResult\u003cBinary\u003e {\n        let msg = ReceiverExecuteMsg::Receive(self);\n        to_binary(\u0026msg)\n    }\n\n    /// creates a cosmos_msg sending this struct to the named contract\n    pub fn into_cosmos_msg\u003cT: Into\u003cString\u003e\u003e(self, contract_addr: T) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let msg = self.into_binary()?;\n        let execute = WasmMsg::Execute {\n            contract_addr: contract_addr.into(),\n            msg,\n            funds: vec![],\n        };\n        Ok(execute.into())\n    }\n}\n\n// This is just a helper to properly serialize the above message\n#[cw_serde]\nenum ReceiverExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n}\n\n#[cw_serde]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\nimpl Cw20Coin {\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.amount == Uint128::zero()\n    }\n}\n\nimpl fmt::Display for Cw20Coin {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"address: {}, amount: {}\", self.address, self.amount)\n    }\n}\n\n#[cw_serde]\npub struct Cw20CoinVerified {\n    pub address: Addr,\n    pub amount: Uint128,\n}\n\nimpl Cw20CoinVerified {\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.amount == Uint128::zero()\n    }\n}\n\nimpl fmt::Display for Cw20CoinVerified {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"address: {}, amount: {}\", self.address, self.amount)\n    }\n}\n\n#[cw_serde]\npub struct BalanceResponse {\n    pub balance: Uint128,\n}\n\n#[cw_serde]\npub struct TokenInfoResponse {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub total_supply: Uint128,\n}\n","traces":[{"line":15,"address":[1830608,1830715],"length":1,"stats":{"Line":1},"fn_name":"into_binary"},{"line":16,"address":[2432380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1830660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1239984,1240650,1240738],"length":1,"stats":{"Line":1},"fn_name":"into_cosmos_msg\u003calloc::string::String\u003e"},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1691077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[1830752],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":46,"address":[1830766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1830816],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":52,"address":[1830846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1830976],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":64,"address":[1830990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1831040],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":70,"address":[1831070],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":16},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","validation.rs"],"content":"use cosmwasm_std::{StdError, StdResult};\nuse cw20_marketing::{EmbeddedLogo, Logo};\n\nuse crate::error::ContractError;\nuse crate::responses::Cw20Coin;\n\nconst LOGO_SIZE_CAP: usize = 5 * 1024;\n\npub fn validate_msg(name: \u0026str, symbol: \u0026str, decimals: u8) -\u003e StdResult\u003c()\u003e {\n    // Check name, symbol, decimals\n    if !has_valid_name(name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n        ));\n    }\n    if !has_valid_symbol(symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n        ));\n    }\n    if decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n    Ok(())\n}\n\npub fn validate_accounts(accounts: \u0026[Cw20Coin]) -\u003e Result\u003c(), ContractError\u003e {\n    let mut addresses = accounts.iter().map(|c| \u0026c.address).collect::\u003cVec\u003c_\u003e\u003e();\n    addresses.sort();\n    addresses.dedup();\n\n    if addresses.len() != accounts.len() {\n        Err(ContractError::DuplicateInitialBalanceAddresses)\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks if passed logo is correct, and if not, returns an error\npub fn verify_logo(logo: \u0026Logo) -\u003e Result\u003c(), ContractError\u003e {\n    match logo {\n        Logo::Embedded(EmbeddedLogo::Svg(logo)) =\u003e verify_xml_logo(logo),\n        Logo::Embedded(EmbeddedLogo::Png(logo)) =\u003e verify_png_logo(logo),\n        Logo::Url(_) =\u003e Ok(()), // Any reasonable url validation would be regex based, probably not worth it\n    }\n}\n\nfn has_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn has_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n/// Validates XML logo\nfn verify_xml_logo(logo: \u0026[u8]) -\u003e Result\u003c(), ContractError\u003e {\n    verify_xml_preamble(logo)?;\n\n    if logo.len() \u003e LOGO_SIZE_CAP {\n        Err(ContractError::LogoTooBig)\n    } else {\n        Ok(())\n    }\n}\n\n/// Validates png logo\nfn verify_png_logo(logo: \u0026[u8]) -\u003e Result\u003c(), ContractError\u003e {\n    // PNG header format:\n    // 0x89 - magic byte, out of ASCII table to fail on 7-bit systems\n    // \"PNG\" ascii representation\n    // [0x0d, 0x0a] - dos style line ending\n    // 0x1a - dos control character, stop displaying rest of the file\n    // 0x0a - unix style line ending\n    const HEADER: [u8; 8] = [0x89, b'P', b'N', b'G', 0x0d, 0x0a, 0x1a, 0x0a];\n    if logo.len() \u003e LOGO_SIZE_CAP {\n        Err(ContractError::LogoTooBig)\n    } else if !logo.starts_with(\u0026HEADER) {\n        Err(ContractError::InvalidPngHeader)\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks if data starts with XML preamble\nfn verify_xml_preamble(data: \u0026[u8]) -\u003e Result\u003c(), ContractError\u003e {\n    // The easiest way to perform this check would be just match on regex, however regex\n    // compilation is heavy and probably not worth it.\n\n    let preamble = data\n        .split_inclusive(|c| *c == b'\u003e')\n        .next()\n        .ok_or(ContractError::InvalidXmlPreamble)?;\n\n    const PREFIX: \u0026[u8] = b\"\u003c?xml \";\n    const POSTFIX: \u0026[u8] = b\"?\u003e\";\n\n    if !(preamble.starts_with(PREFIX) \u0026\u0026 preamble.ends_with(POSTFIX)) {\n        Err(ContractError::InvalidXmlPreamble)\n    } else {\n        Ok(())\n    }\n\n    // Additionally attributes format could be validated as they are well defined, as well as\n    // comments presence inside of preable, but it is probably not worth it.\n}\n","traces":[{"line":9,"address":[840528],"length":1,"stats":{"Line":2},"fn_name":"validate_msg"},{"line":11,"address":[840627],"length":1,"stats":{"Line":10},"fn_name":null},{"line":12,"address":[840661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[840648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[840727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[840721],"length":1,"stats":{"Line":10},"fn_name":null},{"line":22,"address":[840791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[840783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[840848,841082],"length":1,"stats":{"Line":10},"fn_name":"validate_accounts"},{"line":28,"address":[840907],"length":1,"stats":{"Line":13},"fn_name":null},{"line":29,"address":[840946,841007],"length":1,"stats":{"Line":11},"fn_name":null},{"line":30,"address":[841019],"length":1,"stats":{"Line":10},"fn_name":null},{"line":32,"address":[841119,841031],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[841126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[841113],"length":1,"stats":{"Line":10},"fn_name":null},{"line":40,"address":[841184],"length":1,"stats":{"Line":4},"fn_name":"verify_logo"},{"line":41,"address":[841247,841208],"length":1,"stats":{"Line":7},"fn_name":null},{"line":42,"address":[841258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[841293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[841234],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[841344],"length":1,"stats":{"Line":1},"fn_name":"has_valid_name"},{"line":49,"address":[841392],"length":1,"stats":{"Line":9},"fn_name":null},{"line":50,"address":[841402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[841446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[841439],"length":1,"stats":{"Line":10},"fn_name":null},{"line":56,"address":[841472],"length":1,"stats":{"Line":9},"fn_name":"has_valid_symbol"},{"line":57,"address":[841535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[841545],"length":1,"stats":{"Line":10},"fn_name":null},{"line":59,"address":[841623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[841645,841593,841694],"length":1,"stats":{"Line":13},"fn_name":null},{"line":62,"address":[841708],"length":1,"stats":{"Line":10},"fn_name":null},{"line":63,"address":[841829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[841687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[841840],"length":1,"stats":{"Line":2},"fn_name":"verify_xml_logo"},{"line":71,"address":[841878,841940],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[842048,842012,841930],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[842019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[842006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[842064],"length":1,"stats":{"Line":1},"fn_name":"verify_png_logo"},{"line":89,"address":[842107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[842157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[842126,842204,842234],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[842211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[842198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[842240],"length":1,"stats":{"Line":2},"fn_name":"verify_xml_preamble"},{"line":103,"address":[842456,842273,842313],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[2362576,2362589],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":106,"address":[842428,842302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[842560,842596,842404,842489],"length":1,"stats":{"Line":5},"fn_name":null},{"line":112,"address":[842567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[842554],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":51},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw1","src","lib.rs"],"content":"use cosmwasm_std::{CosmosMsg, Response, StdError, StdResult};\nuse serde::{Deserialize, Serialize};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[derive(\n    Serialize, Deserialize, Clone, PartialEq, Eq, sylvia::schemars::JsonSchema, Debug, Default,\n)]\npub struct CanExecuteResp {\n    pub can_execute: bool,\n}\n\n#[interface]\npub trait Cw1 {\n    type Error: From\u003cStdError\u003e;\n\n    /// Execute requests the contract to re-dispatch all these messages with the\n    /// contract's address as sender. Every implementation has it's own logic to\n    /// determine in\n    #[msg(exec)]\n    fn execute(\u0026self, ctx: ExecCtx, msgs: Vec\u003cCosmosMsg\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Checks permissions of the caller on this proxy.\n    /// If CanExecute returns true then a call to `Execute` with the same message,\n    /// from the given sender, before any further state changes, should also succeed.\n    #[msg(query)]\n    fn can_execute(\n        \u0026self,\n        ctx: QueryCtx,\n        sender: String,\n        msg: CosmosMsg,\n    ) -\u003e StdResult\u003cCanExecuteResp\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use cosmwasm_std::{coins, from_binary, from_slice, to_binary, BankMsg};\n\n    use super::*;\n\n    #[test]\n    fn execute() {\n        let original = ExecMsg::Execute {\n            msgs: vec![BankMsg::Send {\n                to_address: \"receiver\".to_owned(),\n                amount: coins(10, \"atom\"),\n            }\n            .into()],\n        };\n\n        let serialized = to_binary(\u0026original).unwrap();\n        let deserialized = from_binary(\u0026serialized).unwrap();\n\n        assert_eq!(original, deserialized);\n    }\n\n    #[test]\n    fn execute_from_slice() {\n        let deserialized = from_slice(br#\"{\"execute\": { \"msgs\": [] }}\"#).unwrap();\n        assert_eq!(ExecMsg::Execute { msgs: vec![] }, deserialized);\n    }\n\n    #[test]\n    fn query() {\n        let original = QueryMsg::CanExecute {\n            sender: \"sender\".to_owned(),\n            msg: BankMsg::Send {\n                to_address: \"receiver\".to_owned(),\n                amount: coins(10, \"atom\"),\n            }\n            .into(),\n        };\n\n        let serialized = to_binary(\u0026original).unwrap();\n        let deserialized = from_binary(\u0026serialized).unwrap();\n\n        assert_eq!(original, deserialized);\n    }\n\n    #[test]\n    fn query_from_slice() {\n        let deserialized = from_slice(\n            br#\"{\"can_execute\": {\n                \"sender\": \"address\",\n                \"msg\": {\n                    \"bank\": {\n                        \"send\": {\n                            \"to_address\": \"receiver\",\n                            \"amount\": [\n                                {\n                                    \"amount\": \"10\",\n                                    \"denom\": \"atom\"\n                                }\n                            ]\n                        }\n                    }\n                }\n            }}\"#,\n        )\n        .unwrap();\n        assert_eq!(\n            QueryMsg::CanExecute {\n                sender: \"address\".to_owned(),\n                msg: BankMsg::Send {\n                    to_address: \"receiver\".to_owned(),\n                    amount: coins(10, \"atom\"),\n                }\n                .into()\n            },\n            deserialized\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-allowances","src","lib.rs"],"content":"pub mod responses;\n\nuse cosmwasm_std::{Binary, Response, StdError, StdResult, Uint128};\nuse cw_utils::Expiration;\nuse responses::{\n    AllAccountsResponse, AllAllowancesResponse, AllSpenderAllowancesResponse, AllowanceResponse,\n};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[interface]\npub trait Cw20Allowances {\n    type Error: From\u003cStdError\u003e;\n\n    /// Allows spender to access an additional amount tokens from the owner's (env.sender) account.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn increase_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Lowers the spender's access of tokens from the owner's (env.sender) account by amount.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn decrease_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Transfers amount tokens from owner -\u003e recipient\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn transfer_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Sends amount tokens from owner -\u003e contract\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn send_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Destroys amount of tokens forever\n    #[msg(exec)]\n    fn burn_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Returns how much spender can use from owner account, 0 if unset.\n    #[msg(query)]\n    fn allowance(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        spender: String,\n    ) -\u003e StdResult\u003cAllowanceResponse\u003e;\n\n    /// Returns all allowances this owner has approved. Supports pagination.\n    #[msg(query)]\n    fn all_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAllowancesResponse\u003e;\n\n    /// Returns all allowances this spender has been granted. Supports pagination.\n    #[msg(query)]\n    fn all_spender_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        spender: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllSpenderAllowancesResponse\u003e;\n\n    /// Returns all accounts that have balances. Supports pagination.\n    #[msg(query)]\n    fn all_accounts(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAccountsResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-allowances","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::Uint128;\nuse cw_utils::Expiration;\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct AllowanceResponse {\n    pub allowance: Uint128,\n    pub expires: Expiration,\n}\n\n#[cw_serde]\npub struct AllowanceInfo {\n    pub spender: String,\n    pub allowance: Uint128,\n    pub expires: Expiration,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct AllAllowancesResponse {\n    pub allowances: Vec\u003cAllowanceInfo\u003e,\n}\n\n#[cw_serde]\npub struct SpenderAllowanceInfo {\n    pub owner: String,\n    pub allowance: Uint128,\n    pub expires: Expiration,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct AllSpenderAllowancesResponse {\n    pub allowances: Vec\u003cSpenderAllowanceInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, schemars::JsonSchema, Debug, Default)]\npub struct AllAccountsResponse {\n    pub accounts: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-marketing","src","lib.rs"],"content":"pub mod responses;\n\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Binary, Response, StdError, StdResult};\nuse responses::{DownloadLogoResponse, MarketingInfoResponse};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n/// This is used for uploading logo data, or setting it in InstantiateData\n#[cw_serde]\npub enum Logo {\n    /// A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.\n    Url(String),\n    /// Logo content stored on the blockchain. Enforce maximum size of 5KB on all variants\n    Embedded(EmbeddedLogo),\n}\n\n/// This is used to store the logo on the blockchain in an accepted format.\n/// Enforce maximum size of 5KB on all variants.\n#[cw_serde]\npub enum EmbeddedLogo {\n    /// Store the Logo as an SVG file. The content must conform to the spec\n    /// at https://en.wikipedia.org/wiki/Scalable_Vector_Graphics\n    /// (The contract should do some light-weight sanity-check validation)\n    Svg(Binary),\n    /// Store the Logo as a PNG file. This will likely only support up to 64x64 or so\n    /// within the 5KB limit.\n    Png(Binary),\n}\n\n#[interface]\npub trait Cw20Marketing {\n    type Error: From\u003cStdError\u003e;\n\n    /// If authorized, updates marketing metadata.\n    /// Setting None/null for any of these will leave it unchanged.\n    /// Setting Some(\"\") will clear this field on the contract storage\n    /// `project` - A URL pointing to the project behind this token.\n    /// `description` - A longer description of the token and it's utility. Designed for tooltips or such\n    /// `marketing` - The address (if any) who can update this data structure\n    #[msg(exec)]\n    fn update_marketing(\n        \u0026self,\n        ctx: ExecCtx,\n        project: Option\u003cString\u003e,\n        description: Option\u003cString\u003e,\n        marketing: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// If set as the \"marketing\" role on the contract, upload a new URL, SVG, or PNG for the token\n    #[msg(exec)]\n    fn upload_logo(\u0026self, ctx: ExecCtx, logo: Logo) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    #[msg(query)]\n    fn marketing_info(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cMarketingInfoResponse\u003e;\n\n    /// Downloads the embedded logo data (if stored on chain). Errors if no logo data is stored for this\n    /// contract.\n    #[msg(query)]\n    fn download_logo(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cDownloadLogoResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-marketing","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Binary};\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n/// This is used to display logo info, provide a link or inform there is one\n/// that can be downloaded from the blockchain itself\n#[cw_serde]\npub enum LogoInfo {\n    /// A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.\n    Url(String),\n    /// There is an embedded logo on the chain, make another call to download it.\n    Embedded,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct MarketingInfoResponse {\n    /// A URL pointing to the project behind this token.\n    pub project: Option\u003cString\u003e,\n    /// A longer description of the token and it's utility. Designed for tooltips or such\n    pub description: Option\u003cString\u003e,\n    /// A link to the logo, or a comment there is an on-chain logo stored\n    pub logo: Option\u003cLogoInfo\u003e,\n    /// The address (if any) who can update this data structure\n    pub marketing: Option\u003cAddr\u003e,\n}\n\n/// When we download an embedded logo, we get this response type.\n/// We expect a SPA to be able to accept this info and display it.\n#[cw_serde]\npub struct DownloadLogoResponse {\n    pub mime_type: String,\n    pub data: Binary,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-minting","src","lib.rs"],"content":"pub mod responses;\n\nuse cosmwasm_std::{Response, StdError, StdResult, Uint128};\nuse responses::MinterResponse;\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[interface]\npub trait Cw20Minting {\n    type Error: From\u003cStdError\u003e;\n\n    /// If authorized, creates amount new tokens and adds to the recipient balance.\n    #[msg(exec)]\n    fn mint(\n        \u0026self,\n        ctx: ExecCtx,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// The current minter may set a new minter.\n    /// Setting the minter to None will remove the token's minter forever.\n    #[msg(exec)]\n    fn update_minter(\n        \u0026self,\n        ctx: ExecCtx,\n        new_minter: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    #[msg(query)]\n    fn minter(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cOption\u003cMinterResponse\u003e\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-minting","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::Uint128;\n\n#[cw_serde]\npub struct MinterResponse {\n    pub minter: String,\n    /// cap is a hard cap on total supply that can be achieved by minting.\n    /// Note that this refers to total_supply.\n    /// If None, there is unlimited cap.\n    pub cap: Option\u003cUint128\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw4","src","lib.rs"],"content":"use cosmwasm_std::{Response, StdError};\n\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[interface]\npub trait Cw4 {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn update_admin(\u0026self, ctx: ExecCtx, admin: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn update_members(\u0026self, ctx: ExecCtx, members: Vec\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn add_hook(\u0026self, ctx: ExecCtx, hook: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn remove_hook(\u0026self, ctx: ExecCtx, hook: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn member(\u0026self, ctx: QueryCtx, member: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn list_members(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn total_weight(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn admin(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn hooks(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use cosmwasm_std::{from_binary, from_slice, to_binary};\n\n    use super::*;\n\n    #[test]\n    fn execute() {\n        let original_msg = Cw4ExecMsg::UpdateAdmin {\n            admin: \"admin_name\".to_owned(),\n        };\n\n        let serialized_msg = to_binary(\u0026original_msg).unwrap();\n        let serialized_msg: Cw4ExecMsg = from_binary(\u0026serialized_msg).unwrap();\n\n        assert_eq!(serialized_msg, original_msg);\n    }\n\n    #[test]\n    fn query() {\n        let original_msg = Cw4QueryMsg::Admin {};\n\n        let serialized_msg = to_binary(\u0026original_msg).unwrap();\n        let serialized_msg: Cw4QueryMsg = from_binary(\u0026serialized_msg).unwrap();\n\n        assert_eq!(serialized_msg, original_msg);\n    }\n\n    #[test]\n    fn execute_from_slice() {\n        let deserialized: Cw4ExecMsg =\n            from_slice(br#\"{\"update_admin\": {\"admin\": \"admin_name\"}}\"#).unwrap();\n        assert_eq!(\n            deserialized,\n            Cw4ExecMsg::UpdateAdmin {\n                admin: \"admin_name\".to_owned()\n            }\n        );\n    }\n\n    #[test]\n    fn query_from_slice() {\n        let deserialized: Cw4QueryMsg = from_slice(br#\"{\"admin\": {}}\"#).unwrap();\n        assert_eq!(deserialized, Cw4QueryMsg::Admin {});\n    }\n\n    #[test]\n    fn exec_msgs() {\n        assert_eq!(\n            Cw4ExecMsg::messages(),\n            [\"add_hook\", \"remove_hook\", \"update_admin\", \"update_members\"]\n        );\n    }\n\n    #[test]\n    fn query_msgs() {\n        assert_eq!(\n            Cw4QueryMsg::messages(),\n            [\"admin\", \"hooks\", \"list_members\", \"member\", \"total_weight\"]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","examples","basic.rs"],"content":"use anyhow::Error;\nuse cosmwasm_std::{Addr, Response, StdError};\nuse cw_storage_plus::{Item, Map};\nuse sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};\nuse sylvia::{contract, interface};\n\n#[derive(\n    sylvia::serde::Serialize,\n    sylvia::serde::Deserialize,\n    Clone,\n    Debug,\n    PartialEq,\n    Eq,\n    sylvia::schemars::JsonSchema,\n)]\npub struct Member {\n    addr: String,\n    weight: u64,\n}\n\n#[derive(\n    sylvia::serde::Serialize,\n    sylvia::serde::Deserialize,\n    Clone,\n    Debug,\n    PartialEq,\n    Eq,\n    sylvia::schemars::JsonSchema,\n)]\npub struct MemberResp {\n    weight: u64,\n}\n\nmod group {\n    use super::*;\n\n    #[interface]\n    pub trait Group {\n        type Error: From\u003cStdError\u003e;\n\n        #[msg(exec)]\n        fn update_admin(\n            \u0026self,\n            ctx: ExecCtx,\n            admin: Option\u003cString\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n        #[msg(exec)]\n        fn update_members(\n            \u0026self,\n            ctx: ExecCtx,\n            remove: Vec\u003cString\u003e,\n            add: Vec\u003cMember\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n        #[msg(query)]\n        fn member(\u0026self, ctx: QueryCtx, addr: String) -\u003e Result\u003cMemberResp, Self::Error\u003e;\n    }\n\n    #[contract]\n    impl Group for GroupContract {\n        type Error = Error;\n\n        #[msg(exec)]\n        fn update_admin(\n            \u0026self,\n            _ctx: ExecCtx,\n            _admin: Option\u003cString\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e {\n            todo!()\n        }\n\n        #[msg(exec)]\n        fn update_members(\n            \u0026self,\n            _ctx: ExecCtx,\n            _remove: Vec\u003cString\u003e,\n            _add: Vec\u003cMember\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e {\n            todo!()\n        }\n\n        #[msg(query)]\n        fn member(\u0026self, _ctx: QueryCtx, _addr: String) -\u003e Result\u003cMemberResp, Self::Error\u003e {\n            todo!()\n        }\n    }\n}\n\npub struct GroupContract {\n    admin: Item\u003c'static, Addr\u003e,\n    _members: Map\u003c'static, Addr, u64\u003e,\n}\n\nimpl Default for GroupContract {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[contract(module=contract)]\n#[error(Error)]\n#[messages(group as Group)]\nimpl GroupContract {\n    pub const fn new() -\u003e Self {\n        Self {\n            admin: Item::new(\"admin\"),\n            _members: Map::new(\"members\"),\n        }\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        ctx: InstantiateCtx,\n        admin: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Error\u003e {\n        if let Some(admin) = admin {\n            let admin = ctx.deps.api.addr_validate(\u0026admin)?;\n            self.admin.save(ctx.deps.storage, \u0026admin)?;\n        }\n\n        Ok(Response::new())\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","examples","generics.rs"],"content":"use cosmwasm_std::{CosmosMsg, Response};\n\nuse sylvia::types::ExecCtx;\nuse sylvia_derive::interface;\n\n#[interface(module=msg)]\npub trait Cw1\u003cMsg\u003e\nwhere\n    Msg: std::fmt::Debug + PartialEq + Clone + schemars::JsonSchema,\n{\n    type Error;\n\n    #[msg(exec)]\n    fn execute(\u0026self, ctx: ExecCtx, msgs: Vec\u003cCosmosMsg\u003cMsg\u003e\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","lib.rs"],"content":"//! Framework for creating CosmWasm Smart Contract with high-level abstraction layer\n//!\n//! Most of implementation lies in `cw-derive-ng` crate which is reexported here\n\n#[cfg(feature = \"mt\")]\npub mod multitest;\npub mod types;\npub mod utils;\n\n#[cfg(feature = \"mt\")]\npub use anyhow;\npub use cosmwasm_std as cw_std;\n#[cfg(feature = \"mt\")]\npub use cw_multi_test;\n#[cfg(feature = \"mt\")]\npub use derivative;\npub use schemars;\npub use serde;\npub use serde_cw_value as serde_value;\npub use serde_json_wasm as serde_json;\npub use sylvia_derive::{contract, entry_points, interface};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","multitest.rs"],"content":"use std::cell::{Ref, RefCell, RefMut};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{Addr, BlockInfo, Coin};\nuse cw_multi_test::Executor;\nuse serde::Serialize;\n\n#[derive(Default)]\npub struct App {\n    pub app: RefCell\u003ccw_multi_test::App\u003e,\n}\n\nimpl App {\n    pub fn new(app: cw_multi_test::App) -\u003e Self {\n        Self {\n            app: RefCell::new(app),\n        }\n    }\n\n    pub fn app(\u0026self) -\u003e Ref\u003c'_, cw_multi_test::App\u003e {\n        Ref::map(self.app.borrow(), |app| app)\n    }\n\n    pub fn app_mut(\u0026self) -\u003e RefMut\u003c'_, cw_multi_test::App\u003e {\n        RefMut::map(self.app.borrow_mut(), |app| app)\n    }\n\n    pub fn block_info(\u0026self) -\u003e BlockInfo {\n        self.app.borrow().block_info()\n    }\n\n    pub fn set_block(\u0026self, block: BlockInfo) {\n        self.app.borrow_mut().set_block(block)\n    }\n\n    pub fn update_block\u003cF: Fn(\u0026mut BlockInfo)\u003e(\u0026self, action: F) {\n        self.app.borrow_mut().update_block(action)\n    }\n}\n\n#[must_use]\npub struct ExecProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    funds: \u0026'a [Coin],\n    contract_addr: \u0026'a Addr,\n    msg: Msg,\n    app: \u0026'app App,\n    phantom: PhantomData\u003cError\u003e,\n}\n\nimpl\u003c'a, 'app, Error, Msg\u003e ExecProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    pub fn new(contract_addr: \u0026'a Addr, msg: Msg, app: \u0026'app App) -\u003e Self {\n        Self {\n            funds: \u0026[],\n            contract_addr,\n            msg,\n            app,\n            phantom: PhantomData,\n        }\n    }\n    pub fn with_funds(self, funds: \u0026'a [Coin]) -\u003e Self {\n        Self { funds, ..self }\n    }\n\n    #[track_caller]\n    pub fn call(self, sender: \u0026'a str) -\u003e Result\u003ccw_multi_test::AppResponse, Error\u003e {\n        self.app\n            .app\n            .borrow_mut()\n            .execute_contract(\n                Addr::unchecked(sender),\n                Addr::unchecked(self.contract_addr),\n                \u0026self.msg,\n                self.funds,\n            )\n            .map_err(|err| err.downcast().unwrap())\n    }\n}\n\n#[must_use]\npub struct MigrateProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    contract_addr: \u0026'a Addr,\n    msg: Msg,\n    app: \u0026'app App,\n    phantom: PhantomData\u003cError\u003e,\n}\n\nimpl\u003c'a, 'app, Error, Msg\u003e MigrateProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    pub fn new(contract_addr: \u0026'a Addr, msg: Msg, app: \u0026'app App) -\u003e Self {\n        Self {\n            contract_addr,\n            msg,\n            app,\n            phantom: PhantomData,\n        }\n    }\n\n    #[track_caller]\n    pub fn call(self, sender: \u0026str, new_code_id: u64) -\u003e Result\u003ccw_multi_test::AppResponse, Error\u003e {\n        self.app\n            .app\n            .borrow_mut()\n            .migrate_contract(\n                Addr::unchecked(sender),\n                Addr::unchecked(self.contract_addr),\n                \u0026self.msg,\n                new_code_id,\n            )\n            .map_err(|err| err.downcast().unwrap())\n    }\n}\n","traces":[{"line":14,"address":[529984],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":16,"address":[530000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[530048],"length":1,"stats":{"Line":1},"fn_name":"app"},{"line":21,"address":[1479072,1479084],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":24,"address":[530080],"length":1,"stats":{"Line":0},"fn_name":"app_mut"},{"line":25,"address":[1349360,1349372],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":28,"address":[530246,530112],"length":1,"stats":{"Line":1},"fn_name":"block_info"},{"line":29,"address":[530219,530142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[530496,530272,530480],"length":1,"stats":{"Line":0},"fn_name":"set_block"},{"line":33,"address":[530425,530362,530286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[691584],"length":1,"stats":{"Line":12},"fn_name":"new\u003ccosmwasm_std::errors::std_error::StdError, dispatching::InterfaceExecMsg\u003e"},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[631134,631216,631646,631699,630704,631187],"length":1,"stats":{"Line":17},"fn_name":"call\u003ccw1_whitelist::error::ContractError, cw1_whitelist::whitelist::WhitelistExecMsg\u003e"},{"line":74,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":22,"coverable":32},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","types.rs"],"content":"use cosmwasm_std::{Deps, DepsMut, Env, MessageInfo};\n\npub struct MigrateCtx\u003c'a\u003e {\n    pub deps: DepsMut\u003c'a\u003e,\n    pub env: Env,\n}\n\npub struct ExecCtx\u003c'a\u003e {\n    pub deps: DepsMut\u003c'a\u003e,\n    pub env: Env,\n    pub info: MessageInfo,\n}\n\npub type InstantiateCtx\u003c'a\u003e = ExecCtx\u003c'a\u003e;\n\npub struct QueryCtx\u003c'a\u003e {\n    pub deps: Deps\u003c'a\u003e,\n    pub env: Env,\n}\n\nimpl ExecCtx\u003c'_\u003e {\n    pub fn branch(\u0026'_ mut self) -\u003e ExecCtx\u003c'_\u003e {\n        ExecCtx {\n            deps: self.deps.branch(),\n            env: self.env.clone(),\n            info: self.info.clone(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c(DepsMut\u003c'a\u003e, Env)\u003e for MigrateCtx\u003c'a\u003e {\n    fn from((deps, env): (DepsMut\u003c'a\u003e, Env)) -\u003e Self {\n        Self { deps, env }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c(DepsMut\u003c'a\u003e, Env, MessageInfo)\u003e for ExecCtx\u003c'a\u003e {\n    fn from((deps, env, info): (DepsMut\u003c'a\u003e, Env, MessageInfo)) -\u003e Self {\n        Self { deps, env, info }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c(Deps\u003c'a\u003e, Env)\u003e for QueryCtx\u003c'a\u003e {\n    fn from((deps, env): (Deps\u003c'a\u003e, Env)) -\u003e Self {\n        Self { deps, env }\n    }\n}\n","traces":[{"line":22,"address":[1396717,1396512],"length":1,"stats":{"Line":5},"fn_name":"branch"},{"line":24,"address":[534162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[534172],"length":1,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[534191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[1346342,1346320],"length":1,"stats":{"Line":41},"fn_name":"from"},{"line":44,"address":[],"length":0,"stats":{"Line":17},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","utils.rs"],"content":"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\nenum State {\n    // Ongoing arrays can be compared to other arrays.\n    Ongoing(usize),\n    // Finished arrays can only be used by other arrays to be compared to.\n    Finished(usize),\n    // There can be empty arrays provided and we want to secure ourselves from \"index out of bounds\"\n    Empty,\n}\n\n/// # Examples\n///\n/// Compile time intersection assert.\n/// Will panic! in case duplicated messages were provided.\n/// Requires sorted arrays to work.\n/// ```\n///     const _: () = {\n///         let msgs: [\u0026[\u0026str]; 2] = [\u0026[\"msg_a\", \"msg_b\"], \u0026[\"msg_c\", \"msg_d\"]];\n///         sylvia::utils::assert_no_intersection(msgs);\n///     };\n/// ```\npub const fn assert_no_intersection\u003cconst N: usize\u003e(msgs: [\u0026[\u0026str]; N]) {\n    let mut states = init_states(\u0026msgs);\n\n    while !should_end(\u0026states) {\n        // Get index of array with alphabetically smallest value.\n        // This will always be one which state is Ongoing.\n        let index = get_next_alphabetical_index(\u0026msgs, \u0026states);\n\n        // Compare all elements at current indexes\n        verify_no_collissions(\u0026msgs, \u0026states, \u0026index);\n\n        // Increment index of alaphabeticaly first element\n        states[index] = match states[index] {\n            State::Ongoing(wi) =\u003e {\n                if msgs[index].len() == wi + 1 {\n                    State::Finished(wi)\n                } else {\n                    State::Ongoing(wi + 1)\n                }\n            }\n            _ =\u003e unreachable!(),\n        };\n    }\n}\n\nconst fn init_states\u003cconst N: usize\u003e(msgs: \u0026[\u0026[\u0026str]; N]) -\u003e [State; N] {\n    let mut states = [State::Ongoing(0); N];\n    konst::for_range! {i in 0..N =\u003e\n        if msgs[i].is_empty() {\n            states[i] = State::Empty;\n        }\n\n    }\n    states\n}\n\n// Finds index of array which is Ongoing and which current value\n// is alphabetically smallest\nconst fn get_next_alphabetical_index\u003cconst N: usize\u003e(\n    msgs: \u0026[\u0026[\u0026str]; N],\n    states: \u0026[State; N],\n) -\u003e usize {\n    let mut output_index = 0;\n    konst::for_range! {i in 0..N =\u003e\n        if let State::Ongoing(outer_i) = states[i] {\n            match states[output_index] {\n                State::Ongoing(inner_i) =\u003e {\n                    if let std::cmp::Ordering::Greater =\n                        konst::cmp_str(msgs[output_index][inner_i], msgs[i][outer_i])\n                    {\n                        output_index = i;\n                    }\n                }\n                _ =\u003e output_index = i,\n            }\n        }\n    }\n    output_index\n}\n\n// Compare values at current indexes saved in states.\n// All comparisions are made with value at index which point to alphabetically smallest\n// and values in each other arrays at their current position.\n//\n// Because arrays are sorted we don't have to compare each value with each other\n// and can just compare values in alphabetical ordering.\nconst fn verify_no_collissions\u003cconst N: usize\u003e(\n    msgs: \u0026[\u0026[\u0026str]; N],\n    states: \u0026[State; N],\n    index: \u0026usize,\n) {\n    let mut i = 0;\n    while i \u003c N {\n        if i == *index {\n            i += 1;\n            continue;\n        }\n        match states[i] {\n            State::Ongoing(outer_i) | State::Finished(outer_i) =\u003e {\n                if let State::Ongoing(inner_i) = states[*index] {\n                    if konst::eq_str(msgs[i][outer_i], msgs[*index][inner_i]) {\n                        panic!(\"Message overlaps between interface and contract impl!\");\n                    }\n                }\n            }\n            _ =\u003e (),\n        }\n        i += 1;\n    }\n}\n\nconst fn should_end\u003cconst N: usize\u003e(states: \u0026[State; N]) -\u003e bool {\n    konst::for_range! {i in 0..N =\u003e\n        if let State::Ongoing(..) = states[i] {\n            return false;\n        }\n    }\n    true\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn should_not_end() {\n        let states = [State::Empty, State::Ongoing(3), State::Finished(5)];\n        assert!(!super::should_end(\u0026states));\n    }\n\n    #[test]\n    fn should_end() {\n        let states = [State::Empty, State::Finished(3), State::Finished(5)];\n        assert!(super::should_end(\u0026states));\n    }\n\n    #[test]\n    fn init_states() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[\"msg\", \"msg\"], \u0026[], \u0026[\"msg\"]];\n        let states = [State::Ongoing(0), State::Empty, State::Ongoing(0)];\n        assert_eq!(super::init_states(\u0026msgs), states);\n    }\n\n    #[test]\n    fn aquire_index_when_two_states_ongoing() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[\"msg_b\", \"msg_c\"], \u0026[], \u0026[\"msg_a\"]];\n        let states = [State::Ongoing(1), State::Empty, State::Ongoing(0)];\n        assert_eq!(get_next_alphabetical_index(\u0026msgs, \u0026states), 2);\n    }\n\n    #[test]\n    fn aquire_index_when_mixed_state() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[\"msg_b\", \"msg_c\"], \u0026[], \u0026[\"msg_a\"]];\n        let states = [State::Ongoing(1), State::Empty, State::Finished(0)];\n        assert_eq!(get_next_alphabetical_index(\u0026msgs, \u0026states), 0);\n    }\n\n    #[test]\n    fn aquire_index_when_first_array_empty() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[], \u0026[\"msg_b\", \"msg_c\"], \u0026[\"msg_a\"]];\n        let states = [State::Empty, State::Ongoing(1), State::Finished(0)];\n        assert_eq!(get_next_alphabetical_index(\u0026msgs, \u0026states), 1);\n    }\n\n    #[test]\n    fn verify_no_collissions() {\n        let msgs: [\u0026[\u0026str]; 4] = [\u0026[], \u0026[\"msg_b\", \"msg_c\"], \u0026[\"msg_a\"], \u0026[\"msg_d\", \"msg_a\"]];\n        let states = [\n            State::Empty,\n            State::Ongoing(1),\n            State::Finished(0),\n            State::Ongoing(0),\n        ];\n\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00261);\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00263);\n\n        let states = [\n            State::Empty,\n            State::Ongoing(1),\n            State::Finished(0),\n            State::Ongoing(1),\n        ];\n\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00261);\n    }\n\n    #[test]\n    #[should_panic]\n    fn verify_collissions() {\n        let msgs: [\u0026[\u0026str]; 4] = [\u0026[], \u0026[\"msg_b\", \"msg_c\"], \u0026[\"msg_a\"], \u0026[\"msg_d\", \"msg_a\"]];\n        let states = [\n            State::Empty,\n            State::Ongoing(1),\n            State::Finished(0),\n            State::Ongoing(1),\n        ];\n\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00263);\n    }\n\n    #[test]\n    fn no_intersection() {\n        let msgs: [\u0026[\u0026str]; 5] = [\n            \u0026[\"msg_b\", \"msg_c\"],\n            \u0026[\"msg_d\", \"msg_e\", \"msg_f\"],\n            \u0026[\"msg_a\"],\n            \u0026[\"msg_g\", \"msg_h\", \"msg_i\", \"msg_j\"],\n            \u0026[],\n        ];\n\n        assert_no_intersection(msgs);\n    }\n\n    #[test]\n    #[should_panic]\n    fn intersection() {\n        let msgs: [\u0026[\u0026str]; 5] = [\n            \u0026[\"msg_b\", \"msg_c\", \"msg_i\"],\n            \u0026[\"msg_d\", \"msg_e\", \"msg_f\"],\n            \u0026[\"msg_a\"],\n            \u0026[\"msg_g\", \"msg_h\", \"msg_i\", \"msg_j\"],\n            \u0026[],\n        ];\n\n        assert_no_intersection(msgs);\n    }\n\n    #[test]\n    fn single_interface_with_no_contract_msgs() {\n        let msgs: [\u0026[\u0026str]; 2] = [\u0026[\"msg_a\", \"msg_b\"], \u0026[]];\n\n        assert_no_intersection(msgs);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[545552,546368,544736],"length":1,"stats":{"Line":5},"fn_name":"get_next_alphabetical_index\u003c5\u003e"},{"line":64,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[547184,548144,549104],"length":1,"stats":{"Line":5},"fn_name":"verify_no_collissions\u003c4\u003e"},{"line":93,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":41,"coverable":46},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","dispatching.rs"],"content":"use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\nuse cosmwasm_std::{from_binary, Addr, Decimal, Response, StdError};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse sylvia::{contract, interface};\n\n#[interface]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        ctx: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, ctx: QueryCtx) -\u003e Result\u003cEmptyQueryResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, ctx: QueryCtx, user: Addr) -\u003e Result\u003cQueryResponse, Self::Error\u003e;\n}\n\n#[derive(Default)]\nstruct Contract {\n    execs: RefCell\u003cu64\u003e,\n    queries: RefCell\u003cu64\u003e,\n\n    data: RefCell\u003cHashMap\u003cAddr, QueryResponse\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct EmptyQueryResponse {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct QueryResponse {\n    coef: Decimal,\n    desc: String,\n}\n\n#[contract]\nimpl Interface for Contract {\n    type Error = StdError;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, _: ExecCtx) -\u003e Result\u003cResponse, StdError\u003e {\n        *self.execs.borrow_mut() += 1;\n        Ok(Response::new())\n    }\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        _: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        *self.execs.borrow_mut() += 1;\n\n        self.data\n            .borrow_mut()\n            .insert(addr, QueryResponse { coef, desc });\n        Ok(Response::new())\n    }\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, _: QueryCtx) -\u003e Result\u003cEmptyQueryResponse, StdError\u003e {\n        *self.queries.borrow_mut() += 1;\n        Ok(dbg!(EmptyQueryResponse {}))\n    }\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, _: QueryCtx, user: Addr) -\u003e Result\u003cQueryResponse, Self::Error\u003e {\n        *self.queries.borrow_mut() += 1;\n        Ok(self.data.borrow().get(\u0026user).unwrap().clone())\n    }\n}\n\n#[test]\nfn dispatch() {\n    let contract = Contract::default();\n\n    let mut deps = mock_dependencies();\n    let env = mock_env();\n    let info = mock_info(\"owner\", \u0026[]);\n\n    let resp = ExecMsg::NoArgsExecution {}\n        .dispatch(\u0026contract, (deps.as_mut(), env.clone(), info.clone()))\n        .unwrap();\n    assert_eq!(resp, Response::new());\n\n    let resp = ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"addr1\"),\n        coef: Decimal::percent(30),\n        desc: \"True\".to_owned(),\n    }\n    .dispatch(\u0026contract, (deps.as_mut(), env.clone(), info.clone()))\n    .unwrap();\n    assert_eq!(resp, Response::new());\n\n    let resp = ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"addr2\"),\n        coef: Decimal::percent(70),\n        desc: \"False\".to_owned(),\n    }\n    .dispatch(\u0026contract, (deps.as_mut(), env.clone(), info))\n    .unwrap();\n    assert_eq!(resp, Response::new());\n\n    let resp = QueryMsg::NoArgsQuery {}\n        .dispatch(\u0026contract, (deps.as_ref(), env.clone()))\n        .unwrap();\n    let _resp: EmptyQueryResponse = from_binary(\u0026resp).unwrap();\n\n    let resp = QueryMsg::ArgumentedQuery {\n        user: Addr::unchecked(\"addr2\"),\n    }\n    .dispatch(\u0026contract, (deps.as_ref(), env))\n    .unwrap();\n    let resp: QueryResponse = from_binary(\u0026resp).unwrap();\n    assert_eq!(\n        resp,\n        QueryResponse {\n            coef: Decimal::percent(70),\n            desc: \"False\".to_owned()\n        }\n    );\n\n    assert_eq!(*contract.execs.borrow(), 3);\n    assert_eq!(*contract.queries.borrow(), 2);\n}\n","traces":[{"line":58,"address":[843008,843344,843262],"length":1,"stats":{"Line":1},"fn_name":"no_args_execution"},{"line":59,"address":[843122,843051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[843278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[843699,844156,843360],"length":1,"stats":{"Line":1},"fn_name":"argumented_execution"},{"line":71,"address":[843447,843554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[843986,843715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[843796,844001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[844031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[844496,845956,844176],"length":1,"stats":{"Line":1},"fn_name":"no_args_query"},{"line":81,"address":[844324,844234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[845026,844507,845256,845486,845716],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[845984,846256,846587],"length":1,"stats":{"Line":1},"fn_name":"argumented_query"},{"line":87,"address":[846032,846111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[846272,846396],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","messages_generation.rs"],"content":"use cosmwasm_std::{Addr, Decimal, Response, StdError, StdResult};\n\nuse sylvia::types::{ExecCtx, InstantiateCtx, MigrateCtx, QueryCtx};\nuse sylvia::{contract, interface};\n\n#[derive(\n    serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema,\n)]\npub struct QueryResult;\n\n#[interface(module=interface)]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        ctx: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        #[serde(default)] desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, ctx: QueryCtx) -\u003e Result\u003cQueryResult, Self::Error\u003e;\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, ctx: QueryCtx, user: Addr) -\u003e Result\u003cQueryResult, Self::Error\u003e;\n}\n\npub struct Contract {}\n\n#[cfg(not(tarpaulin_include))]\n// Ignoring coverage of test implementation\n#[contract(module=contract)]\nimpl Contract {\n    #[allow(clippy::new_without_default)]\n    pub const fn new() -\u003e Self {\n        Self {}\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(migrate)]\n    pub fn migrate(\u0026self, _ctx: MigrateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, _ctx: ExecCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        _ctx: ExecCtx,\n        _addr: Addr,\n        #[serde(default)] _coef: Decimal,\n        #[serde(default)] _desc: String,\n    ) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, _ctx: QueryCtx) -\u003e StdResult\u003cQueryResult\u003e {\n        Ok(QueryResult {})\n    }\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, _ctx: QueryCtx, _user: Addr) -\u003e StdResult\u003cQueryResult\u003e {\n        Ok(QueryResult {})\n    }\n}\n\n#[test]\nfn interface_messages_constructible() {\n    let no_args_exec = interface::ExecMsg::NoArgsExecution {};\n    let _argumented_exec = interface::ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"owner\"),\n        coef: Decimal::percent(10),\n        desc: \"Some description\".to_owned(),\n    };\n    let no_args_query = interface::QueryMsg::NoArgsQuery {};\n    let _argumented_query = interface::QueryMsg::ArgumentedQuery {\n        user: Addr::unchecked(\"owner\"),\n    };\n\n    // Ensure no extra variants are generated\n    match no_args_exec {\n        interface::ExecMsg::NoArgsExecution {} =\u003e (),\n        interface::ExecMsg::ArgumentedExecution { .. } =\u003e (),\n    }\n\n    match no_args_query {\n        interface::QueryMsg::NoArgsQuery {} =\u003e (),\n        interface::QueryMsg::ArgumentedQuery { .. } =\u003e (),\n    }\n}\n\n#[test]\nfn contract_messages_constructible() {\n    let no_args_exec = contract::ExecMsg::NoArgsExecution {};\n    let _argumented_exec = contract::ExecMsg::ArgumentedExecution {\n        _addr: Addr::unchecked(\"owner\"),\n        _coef: Decimal::percent(10),\n        _desc: \"Some description\".to_owned(),\n    };\n    let no_args_query = contract::QueryMsg::NoArgsQuery {};\n    let _argumented_query = contract::QueryMsg::ArgumentedQuery {\n        _user: Addr::unchecked(\"owner\"),\n    };\n    let _ = contract::InstantiateMsg {};\n    let _ = contract::MigrateMsg {};\n\n    // Ensure no extra variants are generated\n    match no_args_exec {\n        contract::ExecMsg::NoArgsExecution {} =\u003e (),\n        contract::ExecMsg::ArgumentedExecution { .. } =\u003e (),\n    }\n\n    match no_args_query {\n        contract::QueryMsg::NoArgsQuery {} =\u003e (),\n        contract::QueryMsg::ArgumentedQuery { .. } =\u003e (),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","query_returns.rs"],"content":"use cosmwasm_std::{Response, StdError, StdResult};\n\nuse sylvia::types::{InstantiateCtx, QueryCtx};\nuse sylvia::{contract, interface};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n}\n\n#[derive(\n    serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema,\n)]\npub struct QueryResponse;\n\ntype QueryResult\u003cE\u003e = Result\u003cQueryResponse, E\u003e;\n\n#[interface(module=msg)]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(query, resp=QueryResponse)]\n    fn query(\u0026self, ctx: QueryCtx, #[serde(default)] name: String) -\u003e QueryResult\u003cSelf::Error\u003e;\n}\n\npub struct SomeContract {}\n\n#[contract]\n#[error(ContractError)]\nimpl SomeContract {\n    #[allow(clippy::new_without_default)]\n    pub const fn new() -\u003e Self {\n        Self {}\n    }\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(query, resp=QueryResponse)]\n    fn contract_query(\n        \u0026self,\n        _ctx: QueryCtx,\n        #[serde(default)] _name: String,\n    ) -\u003e QueryResult\u003cContractError\u003e {\n        Ok(QueryResponse {})\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_interface_query() {\n        let _ = msg::InterfaceQueryMsg::Query {\n            name: \"some_name\".to_owned(),\n        };\n    }\n\n    #[test]\n    fn generate_contract_query() {\n        let _ = QueryMsg::ContractQuery {\n            _name: \"some_name\".to_owned(),\n        };\n    }\n}\n","traces":[{"line":32,"address":[965943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[734928],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":38,"address":[735079,734944],"length":1,"stats":{"Line":0},"fn_name":"instantiate"},{"line":39,"address":[734979,735025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[735120,735220],"length":1,"stats":{"Line":0},"fn_name":"contract_query"},{"line":48,"address":[735155],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","remote.rs"],"content":"use cosmwasm_std::{Response, StdResult};\nuse sylvia::{contract, types::InstantiateCtx};\n\npub struct SomeContract {}\n\npub mod some_interface {\n    use cosmwasm_std::StdError;\n    use sylvia::interface;\n\n    #[interface]\n    pub trait SomeInterface {\n        type Error: From\u003cStdError\u003e;\n    }\n\n    impl SomeInterface for super::SomeContract {\n        type Error = StdError;\n    }\n}\n\n#[contract]\n#[messages(some_interface as SomeInterface)]\nimpl SomeContract {\n    #[allow(clippy::new_without_default)]\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use cosmwasm_std::Addr;\n\n    use crate::some_interface;\n\n    #[test]\n    fn remote_generation() {\n        // interface\n        let _ = some_interface::Remote::new(Addr::unchecked(\"some_interface\"));\n        let addr = Addr::unchecked(\"some_interface\");\n        let _ = some_interface::Remote::borrowed(\u0026addr);\n\n        // contract\n        let new_remote = crate::Remote::new(Addr::unchecked(\"some_contract\"));\n        let addr = Addr::unchecked(\"some_contract\");\n        let borrowed_remote = crate::Remote::borrowed(\u0026addr);\n\n        let _ = some_interface::Remote::from(\u0026borrowed_remote);\n        let _ = some_interface::Remote::from(\u0026new_remote);\n    }\n}\n","traces":[{"line":22,"address":[984615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[700256],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":29,"address":[700407,700272],"length":1,"stats":{"Line":0},"fn_name":"instantiate"},{"line":30,"address":[700353,700307],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","separate_module.rs"],"content":"use cosmwasm_std::{Addr, Decimal, Response, StdError};\n\nuse sylvia::interface;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\n#[derive(\n    serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema,\n)]\npub struct QueryResult;\n\n#[interface(module=msg)]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        ctx: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, ctx: QueryCtx) -\u003e Result\u003cQueryResult, Self::Error\u003e;\n\n    #[msg(query)]\n    fn argumented_query(\n        \u0026self,\n        ctx: QueryCtx,\n        user: Addr,\n    ) -\u003e Result\u003cOption\u003cQueryResult\u003e, Self::Error\u003e;\n}\n\n#[test]\nfn messages_constructible() {\n    let _no_args_exec = msg::ExecMsg::NoArgsExecution {};\n    let _argumented_exec = msg::ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"owner\"),\n        coef: Decimal::percent(10),\n        desc: \"Some description\".to_owned(),\n    };\n    let _no_args_query = msg::QueryMsg::NoArgsQuery {};\n    let _argumented_query = msg::QueryMsg::ArgumentedQuery {\n        user: Addr::unchecked(\"owner\"),\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","check_generics.rs"],"content":"use syn::visit::Visit;\nuse syn::GenericParam;\n\npub struct CheckGenerics\u003c'g\u003e {\n    generics: \u0026'g [\u0026'g GenericParam],\n    used: Vec\u003c\u0026'g GenericParam\u003e,\n}\n\nimpl\u003c'g\u003e CheckGenerics\u003c'g\u003e {\n    pub fn new(generics: \u0026'g [\u0026'g GenericParam]) -\u003e Self {\n        Self {\n            generics,\n            used: vec![],\n        }\n    }\n\n    pub fn used(self) -\u003e Vec\u003c\u0026'g GenericParam\u003e {\n        self.used\n    }\n\n    /// Returns split between used and unused generics\n    pub fn used_unused(self) -\u003e (Vec\u003c\u0026'g GenericParam\u003e, Vec\u003c\u0026'g GenericParam\u003e) {\n        let unused = self\n            .generics\n            .iter()\n            .filter(|gen| !self.used.contains(*gen))\n            .copied()\n            .collect();\n\n        (self.used, unused)\n    }\n}\n\nimpl\u003c'ast, 'g\u003e Visit\u003c'ast\u003e for CheckGenerics\u003c'g\u003e {\n    fn visit_path(\u0026mut self, p: \u0026'ast syn::Path) {\n        if let Some(p) = p.get_ident() {\n            if let Some(gen) = self\n                .generics\n                .iter()\n                .find(|gen| matches!(gen, GenericParam::Type(ty) if ty.ident == *p))\n            {\n                if !self.used.contains(gen) {\n                    self.used.push(gen);\n                }\n            }\n        }\n\n        // Default visit implementation - visiting path deeper\n        for el in \u0026p.segments {\n            self.visit_path_segment(el);\n        }\n    }\n}\n","traces":[{"line":10,"address":[2068448],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2068560],"length":1,"stats":{"Line":0},"fn_name":"used"},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2068592,2068909],"length":1,"stats":{"Line":1},"fn_name":"used_unused"},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[1751056,1751074],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":30,"address":[2068761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2069370,2068944],"length":1,"stats":{"Line":1},"fn_name":"visit_path"},{"line":36,"address":[2068984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2069153,2069079,2069044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[1751120,1751143],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":42,"address":[2069171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2069214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2069130,2069345,2069228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[2069358],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":12,"coverable":18},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","input.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::{parse_quote, GenericParam, Ident, ItemImpl, ItemTrait, TraitItem, Type};\n\nuse crate::crate_module;\nuse crate::message::{ContractEnumMessage, EnumMessage, GlueMessage, StructMessage};\nuse crate::multitest::{MultitestHelpers, TraitMultitestHelpers};\nuse crate::parser::{ContractArgs, ContractErrorAttr, InterfaceArgs, MsgType};\nuse crate::remote::Remote;\n\n/// Preprocessed `interface` macro input\npub struct TraitInput\u003c'a\u003e {\n    attributes: \u0026'a InterfaceArgs,\n    item: \u0026'a ItemTrait,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n}\n\n/// Preprocessed `contract` macro input for non-trait impl block\npub struct ImplInput\u003c'a\u003e {\n    attributes: \u0026'a ContractArgs,\n    error: Type,\n    item: \u0026'a ItemImpl,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n}\n\nimpl\u003c'a\u003e TraitInput\u003c'a\u003e {\n    #[cfg(not(tarpaulin_include))]\n    // This requires invalid implementation which would fail at compile time and making it impossible to test\n    pub fn new(attributes: \u0026'a InterfaceArgs, item: \u0026'a ItemTrait) -\u003e Self {\n        let generics = item.generics.params.iter().collect();\n\n        if !item\n            .items\n            .iter()\n            .any(|item| matches!(item, TraitItem::Type(ty) if ty.ident == Ident::new(\"Error\", ty.ident.span())))\n        {\n            emit_error!(\n                item.ident.span(), \"Missing `Error` type defined for trait.\";\n                note = \"Error is an error type returned by generated types dispatch function. Messages handling function have to return an error type convertible to this Error type.\";\n                note = \"A trait error type should be bound to implement `From\u003ccosmwasm_std::StdError\u003e`.\";\n            );\n        }\n\n        Self {\n            attributes,\n            item,\n            generics,\n        }\n    }\n\n    pub fn process(\u0026self) -\u003e TokenStream {\n        let messages = self.emit_messages();\n        let multitest_helpers = self.emit_helpers();\n        let remote = Remote::for_interface().emit();\n\n        if let Some(module) = \u0026self.attributes.module {\n            #[cfg(not(tarpaulin_include))]\n            quote! {\n                pub mod #module {\n                    use super::*;\n\n                    #messages\n\n                    #multitest_helpers\n\n                    #remote\n                }\n            }\n        } else {\n            #[cfg(not(tarpaulin_include))]\n            quote! {\n                #messages\n\n                #multitest_helpers\n\n                #remote\n            }\n        }\n    }\n\n    fn emit_helpers(\u0026self) -\u003e TokenStream {\n        if cfg!(feature = \"mt\") {\n            let multitest_helpers = TraitMultitestHelpers::new(self.item);\n            multitest_helpers.emit()\n        } else {\n            quote! {}\n        }\n    }\n\n    fn emit_messages(\u0026self) -\u003e TokenStream {\n        let exec = self.emit_msg(\n            \u0026Ident::new(\"ExecMsg\", Span::mixed_site()),\n            MsgType::Exec,\n            self.attributes,\n        );\n        let query = self.emit_msg(\n            \u0026Ident::new(\"QueryMsg\", Span::mixed_site()),\n            MsgType::Query,\n            self.attributes,\n        );\n\n        #[cfg(not(tarpaulin_include))]\n        quote! {\n            #exec\n\n            #query\n        }\n    }\n\n    fn emit_msg(\u0026self, name: \u0026Ident, msg_ty: MsgType, args: \u0026InterfaceArgs) -\u003e TokenStream {\n        EnumMessage::new(name, self.item, msg_ty, \u0026self.generics, args).emit()\n    }\n}\n\nimpl\u003c'a\u003e ImplInput\u003c'a\u003e {\n    pub fn new(attributes: \u0026'a ContractArgs, item: \u0026'a ItemImpl) -\u003e Self {\n        let sylvia = crate_module();\n\n        let generics = item.generics.params.iter().collect();\n\n        let error = item\n            .attrs\n            .iter()\n            .find(|attr| attr.path.is_ident(\"error\"))\n            .and_then(\n                |attr| match ContractErrorAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(error) =\u003e Some(error.error),\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        None\n                    }\n                },\n            )\n            .unwrap_or_else(|| parse_quote! { #sylvia ::cw_std::StdError });\n\n        Self {\n            attributes,\n            item,\n            generics,\n            error,\n        }\n    }\n\n    pub fn process(\u0026self) -\u003e TokenStream {\n        let is_trait = self.item.trait_.is_some();\n\n        let multitest_helpers = if cfg!(feature = \"mt\") {\n            MultitestHelpers::new(self.item, is_trait, \u0026self.error, \u0026self.generics).emit()\n        } else {\n            quote! {}\n        };\n\n        if is_trait {\n            return multitest_helpers;\n        }\n\n        let messages = self.emit_messages();\n        let remote = Remote::for_contract(self.item).emit();\n\n        #[cfg(not(tarpaulin_include))]\n        let code = quote! {\n            #messages\n\n            #multitest_helpers\n\n            #remote\n        };\n\n        if let Some(module) = \u0026self.attributes.module {\n            #[cfg(not(tarpaulin_include))]\n            quote! {\n                pub mod #module {\n                    use super::*;\n\n                    #code\n                }\n            }\n        } else {\n            code\n        }\n    }\n\n    fn emit_messages(\u0026self) -\u003e TokenStream {\n        let instantiate = self.emit_struct_msg(MsgType::Instantiate);\n        let migrate = self.emit_struct_msg(MsgType::Migrate);\n        let exec_impl =\n            self.emit_enum_msg(\u0026Ident::new(\"ExecMsg\", Span::mixed_site()), MsgType::Exec);\n        let query_impl =\n            self.emit_enum_msg(\u0026Ident::new(\"QueryMsg\", Span::mixed_site()), MsgType::Query);\n        let exec = self.emit_glue_msg(\u0026Ident::new(\"ExecMsg\", Span::mixed_site()), MsgType::Exec);\n        let query = self.emit_glue_msg(\u0026Ident::new(\"QueryMsg\", Span::mixed_site()), MsgType::Query);\n\n        #[cfg(not(tarpaulin_include))]\n        quote! {\n            #instantiate\n\n            #exec_impl\n\n            #query_impl\n\n            #migrate\n\n            #exec\n\n            #query\n        }\n    }\n\n    fn emit_struct_msg(\u0026self, msg_ty: MsgType) -\u003e TokenStream {\n        StructMessage::new(self.item, msg_ty, \u0026self.generics).map_or(quote! {}, |msg| msg.emit())\n    }\n\n    fn emit_enum_msg(\u0026self, name: \u0026Ident, msg_ty: MsgType) -\u003e TokenStream {\n        ContractEnumMessage::new(name, self.item, msg_ty, \u0026self.generics, \u0026self.error).emit()\n    }\n\n    fn emit_glue_msg(\u0026self, name: \u0026Ident, msg_ty: MsgType) -\u003e TokenStream {\n        GlueMessage::new(name, self.item, msg_ty, \u0026self.error).emit()\n    }\n}\n","traces":[{"line":54,"address":[2480052,2478960,2479183],"length":1,"stats":{"Line":1},"fn_name":"process"},{"line":55,"address":[2478995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2479010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2479066,2479124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[2480007,2479240],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2479508,2479280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2479302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2480080],"length":1,"stats":{"Line":1},"fn_name":"emit_helpers"},{"line":86,"address":[2480099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[2480118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[2480297,2480144],"length":1,"stats":{"Line":1},"fn_name":"emit_messages"},{"line":94,"address":[2480236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[2480174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2480226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2480437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2480361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2480416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2480553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2480906,2480688],"length":1,"stats":{"Line":1},"fn_name":"emit_msg"},{"line":114,"address":[2480765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[2480944,2481499],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":120,"address":[2480992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[2481002,2481089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2481101,2481273,2481173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2622766,2622752],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":129,"address":[2622816,2622846,2623254],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":130,"address":[2622900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[2622982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2623008,2623075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2623231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2481265],"length":1,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[2481536,2481741],"length":1,"stats":{"Line":1},"fn_name":"process"},{"line":148,"address":[2481566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[2481608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2481735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[2481792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[2481780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[2481883,2481962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[2482919,2482280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[2482468,2482326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2482350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[2483291,2483008,2484212],"length":1,"stats":{"Line":1},"fn_name":"emit_messages"},{"line":187,"address":[2483048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[2483068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[2483116,2483173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2483343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2483533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[2483720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2483915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[2484464,2484240,2484491],"length":1,"stats":{"Line":1},"fn_name":"emit_struct_msg"},{"line":213,"address":[2484289,2484484],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[2484723,2484512],"length":1,"stats":{"Line":1},"fn_name":"emit_enum_msg"},{"line":217,"address":[2484576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[2484894,2484752],"length":1,"stats":{"Line":1},"fn_name":"emit_glue_msg"},{"line":221,"address":[2484798],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":52,"coverable":86},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","lib.rs"],"content":"use input::{ImplInput, TraitInput};\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse proc_macro_error::proc_macro_error;\nuse quote::quote;\nuse syn::fold::Fold;\nuse syn::{parse2, parse_quote, ItemImpl, ItemTrait, Path};\n\npub(crate) mod check_generics;\nmod input;\nmod message;\nmod multitest;\nmod parser;\nmod remote;\nmod strip_generics;\nmod strip_input;\nmod utils;\n\nuse strip_input::StripInput;\n\nuse crate::message::EntryPoints;\n\n#[cfg(not(test))]\npub(crate) fn crate_module() -\u003e Path {\n    use proc_macro_crate::{crate_name, FoundCrate};\n\n    match crate_name(\"sylvia\").expect(\"sylvia is not found in Cargo.toml\") {\n        FoundCrate::Itself =\u003e parse_quote!(sylvia),\n        FoundCrate::Name(name) =\u003e {\n            let ident = syn::Ident::new(\u0026name, proc_macro2::Span::mixed_site());\n            parse_quote!(#ident)\n        }\n    }\n}\n\n#[cfg(test)]\npub(crate) fn crate_module() -\u003e Path {\n    parse_quote!(sylvia)\n}\n\n/// Macro generating messages from contract trait.\n///\n/// ## Example usage\n/// ```ignore\n/// # use cosmwasm_std::Response;\n///\n/// # struct Ctx;\n/// # struct Error;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct Member;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct AdminQueryResponse;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct MemberQueryResponse;\n///\n/// #[sylvia::interface(module=msg)]\n/// trait Cw4 {\n///     type Error: From\u003cStdError\u003e;\n///\n///     #[msg(exec)]\n///     fn update_admin(\u0026self, ctx: (DepsMut, Env, MessageInfo), admin: Option\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n///\n///     #[msg(exec)]\n///     fn update_members(\u0026self, ctx: (DepsMut, Env, MessageInfo), remove: Vec\u003cString\u003e, add: Vec\u003cMember\u003e)\n///         -\u003e Result\u003cResponse, Self::Error\u003e;\n///\n///     #[msg(query)]\n///     fn admin(\u0026self, ctx: (Deps, Env)) -\u003e Result\u003cAdminQueryResponse, Error\u003e;\n///\n///     #[msg(query)]\n///     fn member(\u0026self, ctx: (Deps, Env), addr: String, at_height: Option\u003cu64\u003e) -\u003e Result\u003cMemberQueryResponse, Error\u003e;\n/// }\n/// ```\n///\n/// This would generate output like:\n///\n/// ```ignore\n/// pub mod msg {\n///     # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     # struct Member;\n///\n///     #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     #[serde(rename_all = \"snake_case\")]\n///     pub enum ExecMsg {\n///         UpdateAdmin { admin: Option\u003cString\u003e },\n///         UpdateMembers {\n///             remove: Vec\u003cString\u003e,\n///             add: Vec\u003cMember\u003e,\n///         },\n///         AddHook { addr: String },\n///         RemoveHook { addr: String },\n///     }\n///\n///     impl ExecMsg {\n///         pub fn dispatch\u003cC: Cw4\u003e(contract: \u0026C, ctx: (DepsMut, Env, MessageInfo))\n///             -\u003e Result\u003cResponse, C::Error\u003e\n///         {\n///             // Some dispatching implementation\n///         }\n///     }\n/// }\n///\n/// And similar `Query` structure for handling queries.\n/// ```\n///\n/// ## Parameters\n///\n/// `interface` attribute takes optional parameters:\n/// * `module` - defines module name, where all generated messages would be encapsulated; no\n/// additional module would be created if not provided\n///\n/// ## Attributes\n///\n/// Messages structures are generated basing on interface trait method attributed with\n/// `#[msg(msg_type, ...)`. Msg attribute takes as its first argument type of message it is\n/// supposed to handle:\n///   * `exec` - this is execute message variant\n///   * `query` - this is query message variant\n///\n/// In case of query it is possible to pass second argument which is it's `ResponseType`.\n/// This is required in case of aliased results wrapping their `ResponseType`.\n/// Example for member query\n///\n/// ```ignore\n///     #[msg(query, resp=MemberQueryResponse)]\n///     fn member(\u0026self, ctx: (Deps, Env), addr: String, at_height: Option\u003cu64\u003e) -\u003e Result\u003cMemberQueryResponse, Error\u003e;\n/// ```\n///\n/// For now `#[msg(...)]` attribute doesn't support anymore data on `#[interface]`\n/// elements, but it may be extended in future.\n#[cfg(not(tarpaulin_include))]\n#[proc_macro_error]\n#[proc_macro_attribute]\npub fn interface(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    interface_impl(attr.into(), item.into()).into()\n}\n\nfn interface_impl(attr: TokenStream2, item: TokenStream2) -\u003e TokenStream2 {\n    fn inner(attr: TokenStream2, item: TokenStream2) -\u003e syn::Result\u003cTokenStream2\u003e {\n        let attrs: parser::InterfaceArgs = parse2(attr)?;\n        let input: ItemTrait = parse2(item)?;\n\n        let expanded = TraitInput::new(\u0026attrs, \u0026input).process();\n        let input = StripInput.fold_item_trait(input);\n\n        Ok(quote! {\n            #input\n\n            #expanded\n        })\n    }\n\n    inner(attr, item).unwrap_or_else(syn::Error::into_compile_error)\n}\n\n/// Macro generating messages from contract impl block.\n///\n/// ## Example usage\n/// ```ignore\n/// # use cosmwasm_std::Response;\n///\n/// # struct Ctx;\n/// # struct Error;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct Cw4Group;\n///\n/// #[cw_derive::contract(module=msg)]\n/// impl Cw4Group {\n///     #[msg(instantiate, name=\"Instantiate\")]\n///     fn instantiate(\u0026self, ctx: (DepsMut, Env, MessageInfo), admin: Option\u003cString\u003e)\n///         -\u003e Result\u003cResponse, Error\u003e;\n/// }\n/// ```\n///\n/// This would generate output like:\n///\n/// ```ignore\n/// pub mod msg {\n///     # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     # struct Cw4Group;\n///\n///     #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     #[serde(rename_all = \"snake_case\")]\n///     pub struct Instantiate {\n///         admin: Option\u003cString\u003e,\n///     }\n///\n///     impl Instantiate {\n///         fn dispatch(contract: \u0026Cw4Group, ctx: (DepsMut, Env, MessageInfo), admin: Option\u003cString\u003e)\n///             -\u003e Result\u003cResponse, Error\u003e\n///         {\n///             contract.instantiate(ctx, admin)\n///         }\n///     }\n/// }\n/// ```\n///\n/// ## Parameters\n///\n/// `contract` attribute takes optional parameters:\n/// * `module` - defines module name, where all generated messages would be encapsulated; no\n/// additional module would be created if not provided\n///\n/// ## Attributes\n///\n/// Messages structures are generated basing on specific implemented methods attributed with\n/// `#[msg(msg_type, ...)`. Msg attribute takes as its first argument type of message it is\n/// supposed to handle:\n/// * `instantiate` - this is instantiation message handler. There should be always exactly one\n/// * `exec` - this is execute message variant\n/// * `query` - this is query message variant\n/// * `migrate` - this is migrate message variant\n/// handler for this kind of message.\n/// In case of query it is possible to pass second argument which is it's `ResponseType`.\n/// This is required in case of aliased results wrapping their `ResponseType`.\n/// Example for member query\n///\n/// ```ignore\n///     #[msg(query, resp=MemberQueryResponse)]\n///     fn member(\u0026self, ctx: (Deps, Env), addr: String, at_height: Option\u003cu64\u003e) -\u003e Result\u003cMemberQueryResponse, Error\u003e\n/// ```\n#[cfg(not(tarpaulin_include))]\n#[proc_macro_error]\n#[proc_macro_attribute]\npub fn contract(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    contract_impl(attr.into(), item.into()).into()\n}\n\nfn contract_impl(attr: TokenStream2, item: TokenStream2) -\u003e TokenStream2 {\n    fn inner(attr: TokenStream2, item: TokenStream2) -\u003e syn::Result\u003cTokenStream2\u003e {\n        let attrs: parser::ContractArgs = parse2(attr)?;\n        let input: ItemImpl = parse2(item)?;\n\n        let expanded = ImplInput::new(\u0026attrs, \u0026input).process();\n        let input = StripInput.fold_item_impl(input);\n\n        Ok(quote! {\n            #input\n\n            #expanded\n        })\n    }\n\n    inner(attr, item).unwrap_or_else(syn::Error::into_compile_error)\n}\n\n#[cfg(not(tarpaulin_include))]\n#[proc_macro_error]\n#[proc_macro_attribute]\npub fn entry_points(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    entry_points_impl(attr.into(), item.into()).into()\n}\n\nfn entry_points_impl(attr: TokenStream2, item: TokenStream2) -\u003e TokenStream2 {\n    fn inner(_attr: TokenStream2, item: TokenStream2) -\u003e syn::Result\u003cTokenStream2\u003e {\n        let input: ItemImpl = parse2(item)?;\n        let expanded = EntryPoints::new(\u0026input).emit();\n\n        Ok(quote! {\n            #input\n\n            #expanded\n        })\n    }\n\n    inner(attr, item).unwrap_or_else(syn::Error::into_compile_error)\n}\n\n#[cfg(test)]\nmod test {\n    use std::{env, fs};\n\n    use sylvia_runtime_macros::emulate_attribute_expansion_fallible;\n\n    use crate::{contract_impl, interface_impl};\n\n    // Test expanding macros in sylvia crate tests, to calculate generating code coverage\n    #[test]\n    fn sylvia_test_cov() {\n        let mut path = env::current_dir().unwrap();\n        path.push(\"..\");\n        path.push(\"sylvia\");\n        path.push(\"tests\");\n\n        for entry in fs::read_dir(path).unwrap() {\n            let entry = entry.unwrap();\n\n            if entry.file_type().unwrap().is_file() {\n                let file = fs::File::open(entry.path()).unwrap();\n                emulate_attribute_expansion_fallible(file, \"interface\", interface_impl).unwrap();\n\n                let file = fs::File::open(entry.path()).unwrap();\n                emulate_attribute_expansion_fallible(file, \"contract\", contract_impl).unwrap();\n            }\n        }\n    }\n}\n","traces":[{"line":37,"address":[1696336,1696492],"length":1,"stats":{"Line":1},"fn_name":"crate_module"},{"line":38,"address":[1696349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1696528],"length":1,"stats":{"Line":1},"fn_name":"interface_impl"},{"line":142,"address":[1697796,1697361,1696576],"length":1,"stats":{"Line":1},"fn_name":"inner"},{"line":143,"address":[1696694,1696598,1696858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1697138,1696799,1696990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[1697302,1697123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1697416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1697550,1697487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[1696541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1697840],"length":1,"stats":{"Line":1},"fn_name":"contract_impl"},{"line":234,"address":[1698645,1699078,1697888],"length":1,"stats":{"Line":1},"fn_name":"inner"},{"line":235,"address":[1698003,1698148,1697910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[1698274,1698089,1698422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1698407,1698586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1698700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1698769,1698832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1697853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1699120],"length":1,"stats":{"Line":0},"fn_name":"entry_points_impl"},{"line":259,"address":[1699168,1699890,1699605],"length":1,"stats":{"Line":0},"fn_name":"inner"},{"line":260,"address":[1699275,1699407,1699211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1699392,1699546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1699660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1699133],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":24},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","message.rs"],"content":"use crate::check_generics::CheckGenerics;\nuse crate::crate_module;\nuse crate::parser::{\n    parse_struct_message, ContractErrorAttr, ContractMessageAttr, InterfaceArgs, MsgAttr, MsgType,\n};\nuse crate::strip_generics::StripGenerics;\nuse crate::utils::{extract_return_type, filter_wheres, process_fields};\nuse convert_case::{Case, Casing};\nuse proc_macro2::{Span, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::fold::Fold;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::visit::Visit;\nuse syn::{\n    parse_quote, Attribute, GenericParam, Ident, ImplItem, ItemImpl, ItemTrait, Pat, PatType,\n    ReturnType, Signature, TraitItem, Type, WhereClause, WherePredicate,\n};\n\n/// Representation of single struct message\npub struct StructMessage\u003c'a\u003e {\n    contract_type: \u0026'a Type,\n    fields: Vec\u003cMsgField\u003c'a\u003e\u003e,\n    function_name: \u0026'a Ident,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n    unused_generics: Vec\u003c\u0026'a GenericParam\u003e,\n    wheres: Vec\u003c\u0026'a WherePredicate\u003e,\n    full_where: Option\u003c\u0026'a WhereClause\u003e,\n    result: \u0026'a ReturnType,\n    msg_attr: MsgAttr,\n}\n\nimpl\u003c'a\u003e StructMessage\u003c'a\u003e {\n    /// Creates new struct message of given type from impl block\n    pub fn new(\n        source: \u0026'a ItemImpl,\n        ty: MsgType,\n        generics: \u0026'a [\u0026'a GenericParam],\n    ) -\u003e Option\u003cStructMessage\u003c'a\u003e\u003e {\n        let mut generics_checker = CheckGenerics::new(generics);\n\n        let contract_type = \u0026source.self_ty;\n\n        let parsed = parse_struct_message(source, ty);\n        let Some((method, msg_attr)) = parsed else {\n            return None;\n        };\n\n        let function_name = \u0026method.sig.ident;\n        let fields = process_fields(\u0026method.sig, \u0026mut generics_checker);\n        let (used_generics, unused_generics) = generics_checker.used_unused();\n        let wheres = filter_wheres(\u0026source.generics.where_clause, generics, \u0026used_generics);\n\n        Some(Self {\n            contract_type,\n            fields,\n            function_name,\n            generics: used_generics,\n            unused_generics,\n            wheres,\n            full_where: source.generics.where_clause.as_ref(),\n            result: \u0026method.sig.output,\n            msg_attr,\n        })\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        use MsgAttr::*;\n\n        match \u0026self.msg_attr {\n            Instantiate { name } =\u003e self.emit_struct(name),\n            Migrate { name } =\u003e self.emit_struct(name),\n            _ =\u003e {\n                emit_error!(Span::mixed_site(), \"Invalid message type\");\n                quote! {}\n            }\n        }\n    }\n\n    pub fn emit_struct(\u0026self, name: \u0026Ident) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            contract_type,\n            fields,\n            function_name,\n            generics,\n            unused_generics,\n            wheres,\n            full_where,\n            result,\n            msg_attr,\n        } = self;\n\n        let where_clause = if !wheres.is_empty() {\n            quote! {\n                where #(#wheres,)*\n            }\n        } else {\n            quote! {}\n        };\n\n        let ctx_type = msg_attr.msg_type().emit_ctx_type();\n        let fields_names: Vec\u003c_\u003e = fields.iter().map(MsgField::name).collect();\n        let parameters = fields.iter().map(|field| {\n            let name = field.name;\n            let ty = field.ty;\n            quote! { #name : #ty}\n        });\n        let fields = fields.iter().map(MsgField::emit);\n\n        let generics = if generics.is_empty() {\n            quote! {}\n        } else {\n            quote! {\n                \u003c#(#generics,)*\u003e\n            }\n        };\n\n        let unused_generics = if unused_generics.is_empty() {\n            quote! {}\n        } else {\n            quote! {\n                \u003c#(#unused_generics,)*\u003e\n            }\n        };\n\n        quote! {\n            #[allow(clippy::derive_partial_eq_without_eq)]\n            #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n            #[serde(rename_all=\"snake_case\")]\n            pub struct #name #generics #where_clause {\n                #(pub #fields,)*\n            }\n\n            impl #generics #name #generics #where_clause {\n                pub fn new(#(#parameters,)*) -\u003e Self {\n                    Self { #(#fields_names,)* }\n                }\n\n                pub fn dispatch #unused_generics(self, contract: \u0026#contract_type, ctx: #ctx_type)\n                    #result #full_where\n                {\n                    let Self { #(#fields_names,)* } = self;\n                    contract.#function_name(Into::into(ctx), #(#fields_names,)*).map_err(Into::into)\n                }\n            }\n        }\n    }\n}\n\n/// Representation of single enum message\npub struct EnumMessage\u003c'a\u003e {\n    name: \u0026'a Ident,\n    trait_name: \u0026'a Ident,\n    variants: Vec\u003cMsgVariant\u003c'a\u003e\u003e,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n    unused_generics: Vec\u003c\u0026'a GenericParam\u003e,\n    all_generics: \u0026'a [\u0026'a GenericParam],\n    wheres: Vec\u003c\u0026'a WherePredicate\u003e,\n    full_where: Option\u003c\u0026'a WhereClause\u003e,\n    msg_ty: MsgType,\n    args: \u0026'a InterfaceArgs,\n}\n\nimpl\u003c'a\u003e EnumMessage\u003c'a\u003e {\n    pub fn new(\n        name: \u0026'a Ident,\n        source: \u0026'a ItemTrait,\n        ty: MsgType,\n        generics: \u0026'a [\u0026'a GenericParam],\n        args: \u0026'a InterfaceArgs,\n    ) -\u003e Self {\n        let trait_name = \u0026source.ident;\n\n        let mut generics_checker = CheckGenerics::new(generics);\n        let variants: Vec\u003c_\u003e = source\n            .items\n            .iter()\n            .filter_map(|item| match item {\n                TraitItem::Method(method) =\u003e {\n                    let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n                    let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                        Ok(attr) =\u003e attr,\n                        Err(err) =\u003e {\n                            emit_error!(method.span(), err);\n                            return None;\n                        }\n                    };\n\n                    if attr == ty {\n                        Some(MsgVariant::new(\n                            \u0026method.sig,\n                            \u0026mut generics_checker,\n                            name,\n                            attr,\n                        ))\n                    } else {\n                        None\n                    }\n                }\n                _ =\u003e None,\n            })\n            .collect();\n\n        let (used_generics, unused_generics) = generics_checker.used_unused();\n        let wheres = filter_wheres(\u0026source.generics.where_clause, generics, \u0026used_generics);\n\n        Self {\n            name,\n            trait_name,\n            variants,\n            generics: used_generics,\n            unused_generics,\n            all_generics: generics,\n            wheres,\n            full_where: source.generics.where_clause.as_ref(),\n            msg_ty: ty,\n            args,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            name,\n            trait_name,\n            variants,\n            generics,\n            unused_generics,\n            all_generics,\n            wheres,\n            full_where,\n            msg_ty,\n            args,\n        } = self;\n\n        let match_arms = variants\n            .iter()\n            .map(|variant| variant.emit_dispatch_leg(*msg_ty));\n        let mut msgs: Vec\u003cString\u003e = variants\n            .iter()\n            .map(|var| var.name.to_string().to_case(Case::Snake))\n            .collect();\n        msgs.sort();\n        let msgs_cnt = msgs.len();\n        let variants_constructors = variants.iter().map(MsgVariant::emit_variants_constructors);\n        let variants = variants.iter().map(MsgVariant::emit);\n        let where_clause = if !wheres.is_empty() {\n            quote! {\n                where #(#wheres,)*\n            }\n        } else {\n            quote! {}\n        };\n\n        let ctx_type = msg_ty.emit_ctx_type();\n        let dispatch_type = msg_ty.emit_result_type(\u0026args.msg_type, \u0026parse_quote!(C::Error));\n\n        let all_generics = if all_generics.is_empty() {\n            quote! {}\n        } else {\n            quote! { \u003c#(#all_generics,)*\u003e }\n        };\n\n        let generics = if generics.is_empty() {\n            quote! {}\n        } else {\n            quote! { \u003c#(#generics,)*\u003e }\n        };\n\n        let unique_enum_name = Ident::new(\u0026format!(\"{}{}\", trait_name, name), name.span());\n\n        let enum_declaration = match name.to_string().as_str() {\n            \"QueryMsg\" =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema, cosmwasm_schema::QueryResponses)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #unique_enum_name #generics #where_clause {\n                    #(#variants,)*\n                }\n                pub type #name #generics = #unique_enum_name #generics;\n            },\n            _ =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #unique_enum_name #generics #where_clause {\n                    #(#variants,)*\n                }\n                pub type #name #generics = #unique_enum_name #generics;\n            },\n        };\n\n        quote! {\n            #enum_declaration\n\n            impl #generics #unique_enum_name #generics #where_clause {\n                pub fn dispatch\u003cC: #trait_name #all_generics, #(#unused_generics,)*\u003e(self, contract: \u0026C, ctx: #ctx_type)\n                    -\u003e #dispatch_type #full_where\n                {\n                    use #unique_enum_name::*;\n\n                    match self {\n                        #(#match_arms,)*\n                    }\n                }\n                pub const fn messages() -\u003e [\u0026'static str; #msgs_cnt] {\n                    [#(#msgs,)*]\n                }\n                #(#variants_constructors)*\n            }\n        }\n    }\n}\n\n/// Representation of single enum message\npub struct ContractEnumMessage\u003c'a\u003e {\n    name: \u0026'a Ident,\n    variants: Vec\u003cMsgVariant\u003c'a\u003e\u003e,\n    msg_ty: MsgType,\n    contract: \u0026'a Type,\n    error: \u0026'a Type,\n}\n\nimpl\u003c'a\u003e ContractEnumMessage\u003c'a\u003e {\n    pub fn new(\n        name: \u0026'a Ident,\n        source: \u0026'a ItemImpl,\n        ty: MsgType,\n        generics: \u0026'a [\u0026'a GenericParam],\n        error: \u0026'a Type,\n    ) -\u003e Self {\n        let mut generics_checker = CheckGenerics::new(generics);\n        let variants: Vec\u003c_\u003e = source\n            .items\n            .iter()\n            .filter_map(|item| match item {\n                ImplItem::Method(method) =\u003e {\n                    let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n                    let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                        Ok(attr) =\u003e attr,\n                        Err(err) =\u003e {\n                            emit_error!(method.span(), err);\n                            return None;\n                        }\n                    };\n\n                    if attr == ty {\n                        Some(MsgVariant::new(\n                            \u0026method.sig,\n                            \u0026mut generics_checker,\n                            name,\n                            attr,\n                        ))\n                    } else {\n                        None\n                    }\n                }\n                _ =\u003e None,\n            })\n            .collect();\n\n        Self {\n            name,\n            variants,\n            msg_ty: ty,\n            contract: \u0026source.self_ty,\n            error,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            name,\n            variants,\n            msg_ty,\n            contract,\n            error,\n        } = self;\n\n        let match_arms = variants\n            .iter()\n            .map(|variant| variant.emit_dispatch_leg(*msg_ty));\n        let mut msgs: Vec\u003cString\u003e = variants\n            .iter()\n            .map(|var| var.name.to_string().to_case(Case::Snake))\n            .collect();\n        msgs.sort();\n        let msgs_cnt = msgs.len();\n        let variants_constructors = variants.iter().map(MsgVariant::emit_variants_constructors);\n        let variants = variants.iter().map(MsgVariant::emit);\n\n        let ctx_type = msg_ty.emit_ctx_type();\n        let contract = StripGenerics.fold_type((*contract).clone());\n        let ret_type = msg_ty.emit_result_type(\u0026None, error);\n\n        let enum_declaration = match name.to_string().as_str() {\n            \"QueryMsg\" =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema, cosmwasm_schema::QueryResponses)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #name {\n                    #(#variants,)*\n                }\n            },\n            _ =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #name {\n                    #(#variants,)*\n                }\n            },\n        };\n\n        quote! {\n            #enum_declaration\n\n            impl #name {\n                pub fn dispatch(self, contract: \u0026#contract, ctx: #ctx_type) -\u003e #ret_type {\n                    use #name::*;\n\n                    match self {\n                        #(#match_arms,)*\n                    }\n                }\n                pub const fn messages() -\u003e [\u0026'static str; #msgs_cnt] {\n                    [#(#msgs,)*]\n                }\n\n                #(#variants_constructors)*\n            }\n        }\n    }\n}\n\n/// Representation of whole message variant\npub struct MsgVariant\u003c'a\u003e {\n    name: Ident,\n    function_name: \u0026'a Ident,\n    // With https://github.com/rust-lang/rust/issues/63063 this could be just an iterator over\n    // `MsgField\u003c'a\u003e`\n    fields: Vec\u003cMsgField\u003c'a\u003e\u003e,\n    return_type: TokenStream,\n    message_type: \u0026'a Ident,\n}\n\nimpl\u003c'a\u003e MsgVariant\u003c'a\u003e {\n    /// Creates new message variant from trait method\n    pub fn new(\n        sig: \u0026'a Signature,\n        generics_checker: \u0026mut CheckGenerics,\n        message_type: \u0026'a Ident,\n        msg_attr: MsgAttr,\n    ) -\u003e MsgVariant\u003c'a\u003e {\n        let function_name = \u0026sig.ident;\n\n        let name = Ident::new(\n            \u0026function_name.to_string().to_case(Case::UpperCamel),\n            function_name.span(),\n        );\n        let fields = process_fields(sig, generics_checker);\n\n        let return_type = if let MsgAttr::Query { resp_type } = msg_attr {\n            match resp_type {\n                Some(resp_type) =\u003e quote! {#resp_type},\n                None =\u003e {\n                    let return_type = extract_return_type(\u0026sig.output);\n                    quote! {#return_type}\n                }\n            }\n        } else {\n            quote! {}\n        };\n\n        Self {\n            name,\n            function_name,\n            fields,\n            return_type,\n            message_type,\n        }\n    }\n\n    /// Emits message variant\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self { name, fields, .. } = self;\n        let fields = fields.iter().map(MsgField::emit);\n        let return_type = \u0026self.return_type;\n\n        if self.message_type == \"QueryMsg\" {\n            quote! {\n                #[returns(#return_type)]\n                #name {\n                    #(#fields,)*\n                }\n            }\n        } else {\n            quote! {\n                #name {\n                    #(#fields,)*\n                }\n            }\n        }\n    }\n\n    /// Emits match leg dispatching against this variant. Assumes enum variants are imported into the\n    /// scope. Dispatching is performed by calling the function this variant is build from on the\n    /// `contract` variable, with `ctx` as its first argument - both of them should be in scope.\n    pub fn emit_dispatch_leg(\u0026self, msg_attr: MsgType) -\u003e TokenStream {\n        use MsgType::*;\n\n        let Self {\n            name,\n            fields,\n            function_name,\n            ..\n        } = self;\n        let args = fields\n            .iter()\n            .zip(1..)\n            .map(|(field, num)| Ident::new(\u0026format!(\"field{}\", num), field.name.span()));\n\n        let fields = fields\n            .iter()\n            .map(|field| field.name)\n            .zip(args.clone())\n            .map(|(field, num_field)| quote!(#field : #num_field));\n\n        match msg_attr {\n            Exec =\u003e quote! {\n                #name {\n                    #(#fields,)*\n                } =\u003e contract.#function_name(Into::into(ctx), #(#args),*).map_err(Into::into)\n            },\n            Query =\u003e quote! {\n                #name {\n                    #(#fields,)*\n                } =\u003e cosmwasm_std::to_binary(\u0026contract.#function_name(Into::into(ctx), #(#args),*)?).map_err(Into::into)\n            },\n            Instantiate | Migrate =\u003e {\n                emit_error!(name.span(), \"Instantiation and Migrate messages not supported on traits, they should be defined on contracts directly\");\n                quote! {}\n            }\n        }\n    }\n\n    /// Emits variants constructors. Constructors names are variants names in snake_case.\n    pub fn emit_variants_constructors(\u0026self) -\u003e TokenStream {\n        let Self { name, fields, .. } = self;\n\n        let method_name = name.to_string().to_case(Case::Snake);\n        let method_name = Ident::new(\u0026method_name, name.span());\n\n        let parameters = fields.iter().map(|field| {\n            let name = field.name;\n            let ty = field.ty;\n            quote! { #name : #ty}\n        });\n        let arguments = fields.iter().map(|field| field.name);\n\n        quote! {\n            pub fn #method_name( #(#parameters),*) -\u003e Self {\n                Self :: #name { #(#arguments),* }\n            }\n        }\n    }\n}\n\n/// Representation of single message variant field\npub struct MsgField\u003c'a\u003e {\n    name: \u0026'a Ident,\n    ty: \u0026'a Type,\n    attrs: \u0026'a Vec\u003cAttribute\u003e,\n}\n\nimpl\u003c'a\u003e MsgField\u003c'a\u003e {\n    /// Creates new field from trait method argument\n    pub fn new(item: \u0026'a PatType, generics_checker: \u0026mut CheckGenerics) -\u003e Option\u003cMsgField\u003c'a\u003e\u003e {\n        let name = match \u0026*item.pat {\n            Pat::Ident(p) =\u003e Some(\u0026p.ident),\n            pat =\u003e {\n                // TODO: Support pattern arguments, when decorated with argument with item\n                // name\n                //\n                // Eg.\n                //\n                // ```\n                // fn exec_foo(\u0026self, ctx: Ctx, #[msg(name=metadata)] SomeData { addr, sender }: SomeData);\n                // ```\n                //\n                // should expand to enum variant:\n                //\n                // ```\n                // ExecFoo {\n                //   metadata: SomeDaa\n                // }\n                // ```\n                emit_error!(pat.span(), \"Expected argument name, pattern occurred\");\n                None\n            }\n        }?;\n\n        let ty = \u0026item.ty;\n        let attrs = \u0026item.attrs;\n        generics_checker.visit_type(ty);\n\n        Some(Self { name, ty, attrs })\n    }\n\n    /// Emits message field\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self { name, ty, attrs } = self;\n\n        quote! {\n            #(#attrs)*\n            #name: #ty\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026'a Ident {\n        self.name\n    }\n}\n\n/// Glue message is the message composing Exec/Query messages from several traits\n#[derive(Debug)]\npub struct GlueMessage\u003c'a\u003e {\n    interfaces: Vec\u003cContractMessageAttr\u003e,\n    name: \u0026'a Ident,\n    contract: \u0026'a Type,\n    msg_ty: MsgType,\n    error: \u0026'a Type,\n}\n\nimpl\u003c'a\u003e GlueMessage\u003c'a\u003e {\n    #[cfg(not(tarpaulin_include))]\n    // Lack of coverage here is false negative due to usage in closures\n    fn merge_module_with_name(module: \u0026syn::Path, name: \u0026syn::Ident) -\u003e syn::Ident {\n        let segments = \u0026module.segments;\n        assert!(!segments.is_empty());\n\n        let syn::PathSegment { ident, .. } = \u0026segments[0];\n        let module_name = ident.to_string().to_case(Case::UpperCamel);\n        syn::Ident::new(\u0026format!(\"{}{}\", module_name, name), name.span())\n    }\n\n    pub fn new(name: \u0026'a Ident, source: \u0026'a ItemImpl, msg_ty: MsgType, error: \u0026'a Type) -\u003e Self {\n        let interfaces: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(|attr| {\n                let interface = match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e interface,\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        return None;\n                    }\n                };\n\n                Some(interface)\n            })\n            .collect();\n\n        GlueMessage {\n            interfaces,\n            name,\n            contract: \u0026source.self_ty,\n            msg_ty,\n            error,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            interfaces,\n            name,\n            contract,\n            msg_ty,\n            error,\n        } = self;\n        let contract = StripGenerics.fold_type((*contract).clone());\n        let contract_name = Ident::new(\u0026format!(\"Contract{}\", name), name.span());\n\n        let variants = interfaces.iter().map(|interface| {\n            let ContractMessageAttr {\n                module,\n                exec_generic_params,\n                query_generic_params,\n                variant,\n            } = interface;\n\n            let generics = match msg_ty {\n                MsgType::Exec =\u003e exec_generic_params.as_slice(),\n                MsgType::Query =\u003e query_generic_params.as_slice(),\n                _ =\u003e \u0026[],\n            };\n\n            let enum_name = GlueMessage::merge_module_with_name(module, name);\n            quote! { #variant(#module :: #enum_name\u003c#(#generics,)*\u003e) }\n        });\n\n        let msg_name = quote! {#contract ( #name)};\n        let mut interface_names: Vec\u003cTokenStream\u003e = interfaces\n            .iter()\n            .map(|interface| {\n                let ContractMessageAttr { module, .. } = interface;\n\n                let enum_name = GlueMessage::merge_module_with_name(module, name);\n                quote! { \u0026#module :: #enum_name :: messages()}\n            })\n            .collect();\n        interface_names.push(quote! {\u0026#name :: messages()});\n\n        let interfaces_cnt = interface_names.len();\n\n        let dispatch_arms = interfaces.iter().map(|interface| {\n            let ContractMessageAttr { variant, .. } = interface;\n\n            quote! { #contract_name :: #variant(msg) =\u003e msg.dispatch(contract, Into::into(ctx)) }\n        });\n\n        let dispatch_arm = quote! {#contract_name :: #contract (msg) =\u003emsg.dispatch(contract, ctx)};\n\n        let deserialization_attempts = interfaces.iter().map(|interface| {\n            let ContractMessageAttr {\n                module, variant, ..\n            } = interface;\n            let enum_name = GlueMessage::merge_module_with_name(module, name);\n            quote! {\n                let msgs = \u0026#module :: #enum_name ::messages();\n                if msgs.into_iter().any(|msg| msg == \u0026recv_msg_name) {\n                    match val.deserialize_into() {\n                        Ok(msg) =\u003e return Ok(Self:: #variant (msg)),\n                        Err(err) =\u003e return Err(D::Error::custom(err)).map(Self:: #variant),\n                    };\n                }\n            }\n        });\n\n        let contract_deserialization_attempt = quote! {\n            let msgs = \u0026#name :: messages();\n            if msgs.into_iter().any(|msg| msg == \u0026recv_msg_name) {\n                match val.deserialize_into() {\n                    Ok(msg) =\u003e return Ok(Self:: #contract (msg)),\n                    Err(err) =\u003e return Err(D::Error::custom(err)).map(Self:: #contract)\n                };\n            }\n        };\n\n        let ctx_type = msg_ty.emit_ctx_type();\n        let ret_type = msg_ty.emit_result_type(\u0026None, error);\n\n        let mut response_schemas: Vec\u003cTokenStream\u003e = interfaces\n            .iter()\n            .map(|interface| {\n                let ContractMessageAttr { module, .. } = interface;\n\n                let enum_name = GlueMessage::merge_module_with_name(module, name);\n                quote! { #module :: #enum_name :: response_schemas_impl()}\n            })\n            .collect();\n        response_schemas.push(quote! {#name :: response_schemas_impl()});\n\n        let response_schemas = match name.to_string().as_str() {\n            \"QueryMsg\" =\u003e {\n                quote! {\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    impl cosmwasm_schema::QueryResponses for #contract_name {\n                        fn response_schemas_impl() -\u003e std::collections::BTreeMap\u003cString, #sylvia ::schemars::schema::RootSchema\u003e {\n                            let responses = [#(#response_schemas),*];\n                            responses.into_iter().flatten().collect()\n                        }\n                    }\n                }\n            }\n            _ =\u003e {\n                quote! {}\n            }\n        };\n\n        quote! {\n            #[allow(clippy::derive_partial_eq_without_eq)]\n            #[derive(#sylvia ::serde::Serialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n            #[serde(rename_all=\"snake_case\", untagged)]\n            pub enum #contract_name {\n                #(#variants,)*\n                #msg_name\n            }\n\n            impl #contract_name {\n                pub fn dispatch(\n                    self,\n                    contract: \u0026#contract,\n                    ctx: #ctx_type,\n                ) -\u003e #ret_type {\n                    const _: () = {\n                        let msgs: [\u0026[\u0026str]; #interfaces_cnt] = [#(#interface_names),*];\n                        #sylvia ::utils::assert_no_intersection(msgs);\n                    };\n\n                    match self {\n                        #(#dispatch_arms,)*\n                        #dispatch_arm\n                    }\n                }\n            }\n\n            #response_schemas\n\n            impl\u003c'de\u003e serde::Deserialize\u003c'de\u003e for #contract_name {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                    where D: serde::Deserializer\u003c'de\u003e,\n                {\n                    use serde::de::Error;\n\n                    let val = #sylvia ::serde_value::Value::deserialize(deserializer)?;\n                    let map = match \u0026val {\n                        #sylvia ::serde_value::Value::Map(map) =\u003e map,\n                        _ =\u003e panic!(\"Expected msg to be Value variant Map. Possibly an issue with msg format.\")\n                    };\n                    if map.len() != 1 {\n                        panic!(\"Found more or zero msgs after deserialization. Expected one.\")\n                    }\n                    // Due to earlier size check of map this unwrap is safe\n                    let recv_msg_name = map.into_iter().next().unwrap();\n\n                    if let #sylvia ::serde_value::Value::String(recv_msg_name) = \u0026recv_msg_name .0 {\n                        #(#deserialization_attempts)*\n                        #contract_deserialization_attempt\n                    }\n\n                    let msgs: [\u0026[\u0026str]; #interfaces_cnt] = [#(#interface_names),*];\n                    let mut err_msg = msgs.into_iter().flatten().fold(\n                        // It might be better to forward the error or serialization, but we just\n                        // deserialized it from JSON, not reason to expect failure here.\n                        format!(\n                            \"Unsupported message received: {}. Messages supported by this contract: \",\n                            #sylvia ::serde_json::to_string(\u0026val).unwrap_or_else(|_| String::new())\n                        ),\n                        |mut acc, message| acc + message + \", \",\n                    );\n                    err_msg.truncate(err_msg.len() - 2);\n                    Err(D::Error::custom(err_msg))\n                }\n            }\n        }\n    }\n}\n\npub struct EntryPoints {\n    name: Type,\n    error: Type,\n}\n\nimpl EntryPoints {\n    pub fn new(source: \u0026ItemImpl) -\u003e Self {\n        let sylvia = crate_module();\n        let name = StripGenerics.fold_type(*source.self_ty.clone());\n\n        let error = source\n            .attrs\n            .iter()\n            .find(|attr| attr.path.is_ident(\"error\"))\n            .and_then(\n                |attr| match ContractErrorAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(error) =\u003e Some(error.error),\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        None\n                    }\n                },\n            )\n            .unwrap_or_else(|| parse_quote! { #sylvia ::cw_std::StdError });\n\n        Self { name, error }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self { name, error } = self;\n        let sylvia = crate_module();\n\n        quote! {\n            pub mod entry_points {\n                use super::*;\n                const CONTRACT: #name = #name ::new();\n\n                #[#sylvia ::cw_std::entry_point]\n                pub fn instantiate(\n                    deps: #sylvia ::cw_std::DepsMut,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: InstantiateMsg,\n                ) -\u003e Result\u003c#sylvia ::cw_std::Response, #error\u003e {\n                    msg.dispatch(\u0026CONTRACT, (deps, env, info)).map_err(Into::into)\n                }\n\n                #[#sylvia ::cw_std::entry_point]\n                pub fn execute(\n                    deps: #sylvia ::cw_std::DepsMut,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: ContractExecMsg,\n                ) -\u003e Result\u003c#sylvia ::cw_std::Response, #error\u003e {\n                    msg.dispatch(\u0026CONTRACT, (deps, env, info)).map_err(Into::into)\n                }\n\n                #[#sylvia ::cw_std::entry_point]\n                pub fn query(deps: #sylvia ::cw_std::Deps, env: #sylvia ::cw_std::Env, msg: ContractQueryMsg) -\u003e Result\u003c#sylvia ::cw_std::Binary, #error\u003e {\n                    msg.dispatch(\u0026CONTRACT, (deps, env)).map_err(Into::into)\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":36,"address":[1217080,1217205,1215680],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":41,"address":[1215762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1215821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1215841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1215900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1216044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1215995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1216141,1216032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1216149,1216271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[1216351,1216461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[1216763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1216478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[1216486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1216526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1216566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1216606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1216638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1216706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1216718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1217232],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":71,"address":[1217262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1217465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1217499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1217315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1217442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1218237,1225512,1217536],"length":1,"stats":{"Line":1},"fn_name":"emit_struct"},{"line":82,"address":[1217591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1217604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1217619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1217642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1217657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1217680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1217703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1217726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1217734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1217749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1218164,1217769,1217834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[1217862,1218166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[1217840,1218270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[1218256,1218323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[1218349,1218429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1189701,1189552],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":107,"address":[1189579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1189587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1189596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1218733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[1218896,1219349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1218942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[1218923,1218988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1218971,1219405,1219816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1219430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1219473,1219411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1219459,1219873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1226744,1225536,1226869],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":175,"address":[1225653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[1225702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1225898,1225728,1225810],"length":1,"stats":{"Line":3},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1190427,1189728,1189771],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":182,"address":[1189790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1190688,1189921,1190702,1189810,1190004],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":184,"address":[1189934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1190016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1190141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1190173,1190240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1190396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[1190495,1190510,1190633,1190114],"length":1,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[1190603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1190525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1190529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1190533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1190537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1190506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1189904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1226061,1225936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[1226251,1226141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[1226415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1228367,1238942,1226912],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":225,"address":[1226965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1226978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1226993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1227008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[1227031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[1227054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[1227077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1227085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1227108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1227123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1227148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1227254,1227309,1227171],"length":1,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[1190752,1190787],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":243,"address":[1227340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1190851,1190816],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":247,"address":[1227563,1227480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1227578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[1227617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1227780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1228294,1227943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1227992,1228296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1227970,1228404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1228386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[1228550,1228466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[1229343,1228883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[1228936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1228982,1228917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1228965,1229399,1229840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[1229424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1229405,1229479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1229453,1229929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[1230344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1230498,1230443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[1230476,1233116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1235650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[1239424,1238960],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":336,"address":[1239079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[1239161,1239089,1239243],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1190976,1191019,1191675],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":341,"address":[1191038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[1191058,1191936,1191950,1191169,1191252],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":343,"address":[1191182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1191264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[1191389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1191421,1191488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[1191644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[1191881,1191743,1191758,1191362],"length":1,"stats":{"Line":4},"fn_name":null},{"line":352,"address":[1191851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[1191773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1191777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[1191781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[1191785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[1191754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[1191152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1239341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[1241154,1239456,1248171],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":376,"address":[1239503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1239516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[1239524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[1239547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[1239570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[1239593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[1239751,1239696,1239613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":388,"address":[1192000,1192035],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":389,"address":[1239782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[1192099,1192064],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":393,"address":[1239922,1240005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[1240020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[1240059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[1240222],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[1240373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[1240399,1240489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[1240512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[1240584,1240656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[1241165,1240724,1240779],"length":1,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[1243140,1240757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[1245406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[1248192,1249651,1248571],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":461,"address":[1248253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[1248368,1248286,1248424],"length":1,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[1248507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[1248701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[1248713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[1248780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[1249239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[1249221,1249460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[1249468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[1248814,1248873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[1249744,1250768,1250240],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":492,"address":[1249782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[1249806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[1249864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[1250766,1251280,1249869],"length":1,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[1249932,1250251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[1250796,1249890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[1251296,1253983,1252439],"length":1,"stats":{"Line":1},"fn_name":"emit_dispatch_leg"},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[1251327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[1251342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[1251362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[1251374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[1192269,1192224],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":529,"address":[1251444,1251532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[1192589,1192576],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":532,"address":[1251499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[1192608,1192630],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":535,"address":[1251555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[1251589,1253998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[1252450,1251634,1251839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[1251679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[1251820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[1255888,1256075],"length":1,"stats":{"Line":1},"fn_name":"emit_variants_constructors"},{"line":555,"address":[1255919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[1255954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[1256150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[1192832,1192981],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":561,"address":[1192859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[1192867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[1192876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[1193008,1193021],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":567,"address":[1256615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[1258048],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":585,"address":[1258091,1258464,1258276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":586,"address":[1258119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[1258146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1258267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[1258348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[1258363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[1258371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[1258394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[1258496,1258817],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":618,"address":[1258521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[1258555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[1258848],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":627,"address":[1258853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[1259632],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":654,"address":[1259700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[1193040,1193054],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":658,"address":[1193531,1193104],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":659,"address":[1193150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[1193203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":661,"address":[1193259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[1193352,1193285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[1193508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[1193231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":[1259816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[1260500,1259872,1282124],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":681,"address":[1259925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[1259938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[1259946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[1259961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[1259976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[1259991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[1260105,1260014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":691,"address":[1260120,1260200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":693,"address":[1194367,1194332,1193584],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[1193622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[1193634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":[1193654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[1193674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[1193679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":702,"address":[1193741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[1193763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":704,"address":[1193713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[1193783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[1193869,1193807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":711,"address":[1260707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[1261064,1261122,1260981],"length":1,"stats":{"Line":3},"fn_name":null},{"line":714,"address":[1194690,1194384],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":715,"address":[1194407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":[1194416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":718,"address":[1194490,1194439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":721,"address":[1261168,1261227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[1261471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[1195509,1195000,1194720],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":726,"address":[1194760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[1194765,1195016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":731,"address":[1261627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[1195536,1196412,1198448],"length":1,"stats":{"Line":3},"fn_name":"{closure#3}"},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[1195568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[1195585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[1196423,1195665,1195608],"length":1,"stats":{"Line":3},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[1262427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[1265265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[1265343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[1265560,1265508,1265428],"length":1,"stats":{"Line":3},"fn_name":null},{"line":764,"address":[1198464,1198754],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":765,"address":[1198487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[1198496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[1198519,1198575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":771,"address":[1265606,1265681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":773,"address":[1265882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[1265984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[1266039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[1268510,1266017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":790,"address":[1268564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[1282144,1282392,1282715],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":866,"address":[1282179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[1282280,1282189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[1282555,1282457,1282367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[1198784,1198798],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":874,"address":[1198878,1199286,1198848],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":875,"address":[1198932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[1199014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[1199040,1199107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[1199263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[1199328,1199347],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":887,"address":[1282736,1283626,1290017],"length":1,"stats":{"Line":0},"fn_name":"emit"},{"line":888,"address":[1282760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[1282782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[1282792,1282849,1283637],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":244,"coverable":440},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","multitest.rs"],"content":"use convert_case::{Case, Casing};\nuse proc_macro2::{Ident, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::{FnArg, GenericParam, ImplItem, ItemImpl, ItemTrait, Pat, PatType, Path, Type};\n\nuse crate::check_generics::CheckGenerics;\nuse crate::crate_module;\nuse crate::message::MsgField;\nuse crate::parser::{parse_struct_message, ContractMessageAttr, MsgAttr, MsgType};\nuse crate::utils::{extract_return_type, process_fields};\n\nstruct MessageSignature\u003c'a\u003e {\n    pub name: \u0026'a Ident,\n    pub params: Vec\u003cTokenStream\u003e,\n    pub arguments: Vec\u003c\u0026'a Ident\u003e,\n    pub msg_ty: MsgType,\n    pub return_type: TokenStream,\n}\n\npub struct MultitestHelpers\u003c'a\u003e {\n    messages: Vec\u003cMessageSignature\u003c'a\u003e\u003e,\n    error_type: TokenStream,\n    contract: \u0026'a Type,\n    is_trait: bool,\n    is_migrate: bool,\n    source: \u0026'a ItemImpl,\n    generics: \u0026'a [\u0026'a GenericParam],\n    contract_name: \u0026'a Ident,\n    proxy_name: Ident,\n}\n\nfn interface_name(source: \u0026ItemImpl) -\u003e \u0026Ident {\n    let trait_name = \u0026source.trait_;\n    let Some(trait_name) = trait_name else {unreachable!()};\n    let (_, Path { segments, .. }, _) = \u0026trait_name;\n    assert!(!segments.is_empty());\n\n    \u0026segments[0].ident\n}\n\nfn extract_contract_name(contract: \u0026Type) -\u003e \u0026Ident {\n    let Type::Path(type_path) = contract  else {\n            unreachable!()\n        };\n    let segments = \u0026type_path.path.segments;\n    assert!(!segments.is_empty());\n    let segment = \u0026segments[0];\n    \u0026segment.ident\n}\n\nimpl\u003c'a\u003e MultitestHelpers\u003c'a\u003e {\n    pub fn new(\n        source: \u0026'a ItemImpl,\n        is_trait: bool,\n        contract_error: \u0026'a Type,\n        generics: \u0026'a [\u0026'a GenericParam],\n    ) -\u003e Self {\n        let mut is_migrate = false;\n        let sylvia = crate_module();\n\n        let messages: Vec\u003c_\u003e = source\n            .items\n            .iter()\n            .filter_map(|item| match item {\n                ImplItem::Method(method) =\u003e {\n                    let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n                    let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                        Ok(attr) =\u003e attr,\n                        Err(err) =\u003e {\n                            emit_error!(method.span(), err);\n                            return None;\n                        }\n                    };\n                    let msg_ty = attr.msg_type();\n\n                    if msg_ty == MsgType::Migrate {\n                        is_migrate = true;\n                    } else if msg_ty != MsgType::Query \u0026\u0026 msg_ty != MsgType::Exec {\n                        return None;\n                    }\n                    let sig = \u0026method.sig;\n                    let return_type = if let MsgAttr::Query { resp_type } = attr {\n                        match resp_type {\n                            Some(resp_type) =\u003e quote! {#resp_type},\n                            None =\u003e {\n                                let return_type = extract_return_type(\u0026sig.output);\n                                quote! {#return_type}\n                            }\n                        }\n                    } else {\n                        quote! { #sylvia ::cw_multi_test::AppResponse }\n                    };\n\n                    let name = \u0026sig.ident;\n                    let params: Vec\u003c_\u003e = sig\n                        .inputs\n                        .iter()\n                        .skip(2)\n                        .filter_map(|arg| match arg {\n                            FnArg::Typed(ty) =\u003e {\n                                let name = match ty.pat.as_ref() {\n                                    Pat::Ident(ident) =\u003e \u0026ident.ident,\n                                    _ =\u003e return None,\n                                };\n                                let ty = \u0026ty.ty;\n                                Some(quote! {#name : #ty})\n                            }\n                            _ =\u003e None,\n                        })\n                        .collect();\n                    let arguments: Vec\u003c_\u003e = sig\n                        .inputs\n                        .iter()\n                        .skip(2)\n                        .filter_map(|arg| match arg {\n                            FnArg::Typed(item) =\u003e {\n                                let PatType { pat, .. } = item;\n                                let Pat::Ident(ident) = pat.as_ref() else {\n                                    unreachable!()\n                                };\n                                Some(\u0026ident.ident)\n                            }\n                            _ =\u003e None,\n                        })\n                        .collect();\n\n                    Some(MessageSignature {\n                        name,\n                        params,\n                        arguments,\n                        msg_ty,\n                        return_type,\n                    })\n                }\n                _ =\u003e None,\n            })\n            .collect();\n\n        let error_type = if is_trait {\n            let error_type: Vec\u003c_\u003e = source\n                .items\n                .iter()\n                .filter_map(|item| match item {\n                    ImplItem::Type(ty) if ty.ident == \"Error\" =\u003e {\n                        let ty = \u0026ty.ty;\n                        let segments = match ty {\n                            Type::Path(path) =\u003e \u0026path.path.segments,\n                            _ =\u003e {\n                                unreachable!();\n                            }\n                        };\n                        assert!(!segments.is_empty());\n\n                        Some(\u0026segments[0].ident)\n                    }\n                    _ =\u003e None,\n                })\n                .collect();\n\n            assert!(!error_type.is_empty());\n            let error_type = error_type[0];\n            quote! {#error_type}\n        } else {\n            quote! {#contract_error}\n        };\n\n        let contract = \u0026source.self_ty;\n        let contract_name = extract_contract_name(contract);\n\n        let proxy_name = if is_trait {\n            let interface_name = interface_name(source);\n            Ident::new(\u0026format!(\"{}Proxy\", interface_name), interface_name.span())\n        } else {\n            Ident::new(\u0026format!(\"{}Proxy\", contract_name), contract_name.span())\n        };\n\n        Self {\n            messages,\n            error_type,\n            contract,\n            is_trait,\n            is_migrate,\n            source,\n            generics,\n            contract_name,\n            proxy_name,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self {\n            messages,\n            error_type,\n            proxy_name,\n            source,\n            is_trait,\n            ..\n        } = self;\n        let sylvia = crate_module();\n\n        if *is_trait {\n            return self.impl_trait_on_proxy();\n        }\n\n        let messages = messages.iter().map(|msg| {\n            let MessageSignature {\n                name,\n                params,\n                arguments,\n                msg_ty,\n                return_type,\n            } = msg;\n            if msg_ty == \u0026MsgType::Exec {\n                quote! {\n                    #[track_caller]\n                    pub fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::ExecProxy::\u003c#error_type, ExecMsg\u003e {\n                        let msg = ExecMsg:: #name ( #(#arguments),* );\n\n                        #sylvia ::multitest::ExecProxy::new(\u0026self.contract_addr, msg, \u0026self.app)\n                    }\n                }\n            } else if msg_ty == \u0026MsgType::Migrate {\n                quote! {\n                    #[track_caller]\n                    pub fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::MigrateProxy::\u003c#error_type, MigrateMsg\u003e {\n                        let msg = MigrateMsg::new( #(#arguments),* );\n\n                        #sylvia ::multitest::MigrateProxy::new(\u0026self.contract_addr, msg, \u0026self.app)\n                    }\n                }\n            } else {\n                quote! {\n                    pub fn #name (\u0026self, #(#params,)* ) -\u003e Result\u003c#return_type, #error_type\u003e {\n                        let msg = QueryMsg:: #name ( #(#arguments),* );\n\n                        self.app\n                            .app\n                            .borrow()\n                            .wrap()\n                            .query_wasm_smart(self.contract_addr.clone(), \u0026msg)\n                            .map_err(Into::into)\n                    }\n                }\n            }\n        });\n\n        let contract_block = self.generate_contract_helpers();\n\n        let interfaces: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(|attr| {\n                let interface = match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e {\n                        let ContractMessageAttr { module, .. } = interface;\n                        assert!(!module.segments.is_empty());\n                        let module_name = \u0026module.segments[0].ident;\n                        let method_name = Ident::new(\u0026format!(\"{}_proxy\", module_name), module_name.span());\n                        let proxy_name = Ident::new(\n                            \u0026format!(\"{}Proxy\", module_name.to_string().to_case(Case::UpperCamel)),\n                            module_name.span(),\n                        );\n\n                        quote! {\n                            pub fn #method_name (\u0026self) -\u003e #module ::trait_utils:: #proxy_name \u003c'app\u003e {\n                                #module ::trait_utils:: #proxy_name ::new(self.contract_addr.clone(), self.app)\n                            }\n                        }\n                    }\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        return None;\n                    }\n                };\n\n                Some(interface)\n            })\n            .collect();\n\n        quote! {\n            pub mod multitest_utils {\n                use super::*;\n                use #sylvia ::cw_multi_test::Executor;\n                use #sylvia ::derivative::Derivative;\n\n                #[derive(Derivative)]\n                #[derivative(Debug)]\n                pub struct #proxy_name \u003c'app\u003e {\n                    pub contract_addr: #sylvia ::cw_std::Addr,\n                    #[derivative(Debug=\"ignore\")]\n                    pub app: \u0026'app #sylvia ::multitest::App,\n                }\n\n                impl\u003c'app\u003e #proxy_name \u003c'app\u003e {\n                    pub fn new(contract_addr: #sylvia ::cw_std::Addr, app: \u0026'app #sylvia ::multitest::App) -\u003e Self {\n                        #proxy_name{ contract_addr, app }\n                    }\n\n                    #(#messages)*\n\n                    #(#interfaces)*\n                }\n\n                impl\u003c'app\u003e From\u003c(#sylvia ::cw_std::Addr, \u0026'app #sylvia ::multitest::App)\u003e for #proxy_name\u003c'app\u003e {\n                    fn from(input: (#sylvia ::cw_std::Addr, \u0026'app #sylvia ::multitest::App)) -\u003e #proxy_name\u003c'app\u003e {\n                        #proxy_name::new(input.0, input.1)\n                    }\n                }\n\n                #contract_block\n            }\n        }\n    }\n\n    fn impl_trait_on_proxy(\u0026self) -\u003e TokenStream {\n        let Self {\n            messages,\n            error_type,\n            source,\n            ..\n        } = self;\n\n        let sylvia = crate_module();\n\n        let interface_name = interface_name(self.source);\n        let proxy_name = \u0026self.proxy_name;\n        let trait_name = Ident::new(\u0026format!(\"{}\", interface_name), interface_name.span());\n\n        let modules: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(\n                |attr| match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e {\n                        let ContractMessageAttr { module, .. } = \u0026interface;\n                        assert!(!module.segments.is_empty());\n                        Some(module.segments[0].ident.clone())\n                    }\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        None\n                    }\n                },\n            )\n            .collect();\n\n        let module = match modules.len() {\n            0 =\u003e {\n                quote! {}\n            }\n            1 =\u003e {\n                let module = \u0026modules[0];\n                quote! {#module ::}\n            }\n            _ =\u003e {\n                emit_error!(\n                    source.span(),\n                    \"Only one #[messages] attribute is allowed per contract\"\n                );\n                return quote! {};\n            }\n        };\n        let methods_definitions = messages.iter().map(|msg| {\n            let MessageSignature {\n                name,\n                params,\n                arguments,\n                msg_ty,\n                return_type,\n            } = msg;\n            if msg_ty == \u0026MsgType::Exec {\n                quote! {\n                    #[track_caller]\n                    fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::ExecProxy::\u003c#error_type, #module ExecMsg\u003e {\n                        let msg = #module ExecMsg:: #name ( #(#arguments),* );\n\n                        #sylvia ::multitest::ExecProxy::new(\u0026self.contract_addr, msg, \u0026self.app)\n                    }\n                }\n            } else {\n                quote! {\n                    fn #name (\u0026self, #(#params,)* ) -\u003e Result\u003c#return_type, #error_type\u003e {\n                        let msg = #module QueryMsg:: #name ( #(#arguments),* );\n\n                        self.app\n                            .app\n                            .borrow()\n                            .wrap()\n                            .query_wasm_smart(self.contract_addr.clone(), \u0026msg)\n                            .map_err(Into::into)\n                    }\n                }\n            }\n        });\n\n        let methods_declarations = messages.iter().map(|msg| {\n            let MessageSignature {\n                name,\n                params,\n                msg_ty,\n                return_type,\n                ..\n            } = msg;\n            if msg_ty == \u0026MsgType::Exec {\n                quote! {\n                    fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::ExecProxy::\u003c#error_type, #module ExecMsg\u003e;\n                }\n            } else {\n                quote! {\n                    fn #name (\u0026self, #(#params,)* ) -\u003e Result\u003c#return_type, #error_type\u003e;\n                }\n            }\n        });\n\n        quote! {\n            pub mod test_utils {\n                use super::*;\n\n                pub trait #trait_name {\n                    #(#methods_declarations)*\n                }\n\n                impl #trait_name for #module trait_utils:: #proxy_name\u003c'_\u003e {\n                    #(#methods_definitions)*\n                }\n            }\n        }\n    }\n\n    fn generate_contract_helpers(\u0026self) -\u003e TokenStream {\n        let Self {\n            error_type,\n            is_trait,\n            source,\n            generics,\n            contract_name,\n            proxy_name,\n            ..\n        } = self;\n\n        if *is_trait {\n            return quote! {};\n        }\n\n        let sylvia = crate_module();\n\n        let mut generics_checker = CheckGenerics::new(generics);\n\n        let parsed = parse_struct_message(source, MsgType::Instantiate);\n        let Some((method,_)) = parsed else {\n            return quote! {};\n        };\n\n        let instantiate_fields = process_fields(\u0026method.sig, \u0026mut generics_checker);\n        let fields_names: Vec\u003c_\u003e = instantiate_fields.iter().map(MsgField::name).collect();\n        let fields = instantiate_fields.iter().map(MsgField::emit);\n\n        let impl_contract = self.generate_impl_contract();\n\n        quote! {\n            #impl_contract\n\n            pub struct CodeId\u003c'app\u003e {\n                code_id: u64,\n                app: \u0026'app #sylvia ::multitest::App,\n            }\n\n            impl\u003c'app\u003e CodeId\u003c'app\u003e {\n                pub fn store_code(app: \u0026'app #sylvia ::multitest::App) -\u003e Self {\n                    let code_id = app\n                        .app\n                        .borrow_mut()\n                        .store_code(Box::new(#contract_name ::new()));\n                    Self { code_id, app }\n                }\n\n                pub fn code_id(\u0026self) -\u003e u64 {\n                    self.code_id\n                }\n\n                pub fn instantiate(\n                    \u0026self, #(#fields,)*\n                ) -\u003e InstantiateProxy\u003c'_, 'app\u003e {\n                    let msg = InstantiateMsg {#(#fields_names,)*};\n                    InstantiateProxy {\n                        code_id: self,\n                        funds: \u0026[],\n                        label: \"Contract\",\n                        admin: None,\n                        msg,\n                    }\n                }\n            }\n\n            pub struct InstantiateProxy\u003c'a, 'app\u003e {\n                code_id: \u0026'a CodeId \u003c'app\u003e,\n                funds: \u0026'a [#sylvia ::cw_std::Coin],\n                label: \u0026'a str,\n                admin: Option\u003cString\u003e,\n                msg: InstantiateMsg,\n            }\n\n            impl\u003c'a, 'app\u003e InstantiateProxy\u003c'a, 'app\u003e {\n                pub fn with_funds(self, funds: \u0026'a [#sylvia ::cw_std::Coin]) -\u003e Self {\n                    Self { funds, ..self }\n                }\n\n                pub fn with_label(self, label: \u0026'a str) -\u003e Self {\n                    Self { label, ..self }\n                }\n\n                pub fn with_admin\u003c's\u003e(self, admin: impl Into\u003cOption\u003c\u0026's str\u003e\u003e) -\u003e Self {\n                    let admin = admin.into().map(str::to_owned);\n                    Self { admin, ..self }\n                }\n\n                #[track_caller]\n                pub fn call(self, sender: \u0026str) -\u003e Result\u003c#proxy_name\u003c'app\u003e, #error_type\u003e {\n                    self.code_id\n                        .app\n                        .app\n                        .borrow_mut()\n                        .instantiate_contract(\n                            self.code_id.code_id,\n                            #sylvia ::cw_std::Addr::unchecked(sender),\n                            \u0026self.msg,\n                            self.funds,\n                            self.label,\n                            self.admin,\n                        )\n                        .map_err(|err| err.downcast().unwrap())\n                        .map(|addr| #proxy_name {\n                            contract_addr: addr,\n                            app: self.code_id.app,\n                        })\n                }\n            }\n        }\n    }\n\n    fn generate_impl_contract(\u0026self) -\u003e TokenStream {\n        let contract = \u0026self.contract;\n        let sylvia = crate_module();\n\n        // MigrateMsg is not generated all the time in contrary to Exec, Query and Instantiate.\n        let migrate_body = if self.is_migrate {\n            quote! {\n                #sylvia ::cw_std::from_slice::\u003cMigrateMsg\u003e(\u0026msg)?\n                    .dispatch(self, (deps, env).into())\n                    .map_err(Into::into)\n            }\n        } else {\n            quote! {\n                #sylvia ::anyhow::bail!(\"migrate not implemented for contract\")\n            }\n        };\n        quote! {\n            impl #sylvia ::cw_multi_test::Contract\u003c#sylvia ::cw_std::Empty\u003e for #contract {\n                fn execute(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::cw_std::from_slice::\u003cContractExecMsg\u003e(\u0026msg)?\n                        .dispatch(self, (deps, env, info))\n                        .map_err(Into::into)\n                }\n\n                fn instantiate(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::cw_std::from_slice::\u003cInstantiateMsg\u003e(\u0026msg)?\n                        .dispatch(self, (deps, env, info))\n                        .map_err(Into::into)\n                }\n\n                fn query(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::Deps\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Binary\u003e {\n                    #sylvia ::cw_std::from_slice::\u003cContractQueryMsg\u003e(\u0026msg)?\n                        .dispatch(self, (deps, env))\n                        .map_err(Into::into)\n                }\n\n                fn sudo(\n                    \u0026self,\n                    _deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    _env: #sylvia ::cw_std::Env,\n                    _msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::anyhow::bail!(\"sudo not implemented for contract\")\n                }\n\n                fn reply(\n                    \u0026self,\n                    _deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    _env: #sylvia ::cw_std::Env,\n                    _msg: #sylvia ::cw_std::Reply,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::anyhow::bail!(\"reply not implemented for contract\")\n                }\n\n                fn migrate(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #migrate_body\n                }\n            }\n        }\n    }\n}\n\npub struct TraitMultitestHelpers\u003c'a\u003e {\n    trait_name: \u0026'a Ident,\n}\n\nimpl\u003c'a\u003e TraitMultitestHelpers\u003c'a\u003e {\n    pub fn new(source: \u0026'a ItemTrait) -\u003e Self {\n        Self {\n            trait_name: \u0026source.ident,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let trait_name = self.trait_name;\n        let sylvia = crate_module();\n        let proxy_name = Ident::new(\u0026format!(\"{}Proxy\", trait_name), trait_name.span());\n\n        quote! {\n            pub mod trait_utils {\n                pub struct #proxy_name \u003c'app\u003e {\n                    pub contract_addr: #sylvia ::cw_std::Addr,\n                    pub app: \u0026'app #sylvia ::multitest::App,\n                }\n                impl\u003c'app\u003e #proxy_name \u003c'app\u003e {\n                    pub fn new(contract_addr: #sylvia ::cw_std::Addr, app: \u0026'app #sylvia ::multitest::App) -\u003e Self {\n                        #proxy_name { contract_addr, app }\n                    }\n                }\n                impl Into\u003c#sylvia ::cw_std::Addr\u003e for #proxy_name \u003c'_\u003e {\n                    fn into(self) -\u003e #sylvia ::cw_std::Addr {\n                        self.contract_addr\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":35,"address":[2571216],"length":1,"stats":{"Line":1},"fn_name":"interface_name"},{"line":36,"address":[2571230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2571297,2571235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2571266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2571358,2571281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2571332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2571392],"length":1,"stats":{"Line":1},"fn_name":"extract_contract_name"},{"line":45,"address":[2571406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2571476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2571446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2571460,2571542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2571511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2571533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2571584,2572444,2573826],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":61,"address":[2571681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2571697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[2571710,2571801,2571872],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1648861,1648190,1648144],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":68,"address":[1648213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1650752,1648448,1648233,1650766,1648362],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":70,"address":[1648378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1648455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1648586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1648618,1648685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1648841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1648946,1648567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1648953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1649020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1648989,1649068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[1649138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1649031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1649048,1649160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[1649232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1649594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1649575,1649816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[1649824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1649266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1649526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1649546,1650050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[1651184,1650851,1650816],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":103,"address":[1650877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1650885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1650943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1651008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1650960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1650969,1651017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1650913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1650108,1650190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1651216,1651235],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":119,"address":[1651261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1651266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1651275,1651318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1651334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1651327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1651294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1650420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1650253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1650301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1650349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1650356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1648342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[2571933,2572640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[2571969,2572056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1651376,1651395],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":147,"address":[1651406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1651461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1651483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1651515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1651553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[1651615,1651537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1651587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1651447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[2572218,2572260,2572157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[2572300,2572226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[2572311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[2571939,2572505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[2572463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[2572483,2572704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[2572712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[2572756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[2572781,2573021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[2573749,2572716,2573549],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[2573856,2575438,2581167],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2573895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[2573918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[2573926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[2573941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[2573964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2573979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[2574000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[2574050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1651664,1652095,1654256],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[1651711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1651726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1651749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1651772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1651787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1654254,1651795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[1651852,1652106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1659120,1651819,1656692],"length":1,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[1654340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1654287,1656697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[2574247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[2574344,2574262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1659136,1659150],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":256,"address":[1659200,1659845],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":257,"address":[1659258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[1659321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[1659449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[1659497,1659938,1659981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[1660018,1659946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[1660030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[1660926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[1660389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1660889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[1661008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1659534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1659566,1659639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1659822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1662541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[2574444,2574503,2575449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[2584620,2581749,2581184],"length":1,"stats":{"Line":1},"fn_name":"impl_trait_on_proxy"},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[2581223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[2581246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[2581254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[2581282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[2581295,2581374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[2581382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[2581394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[2581812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1662608,1662622],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":338,"address":[1662718,1663210,1662672],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":339,"address":[1662778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1662910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[1663330,1662918,1663290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1663367,1663303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1662941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1662967,1663034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1663190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[2582051,2581994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[2582098,2582599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[2582397,2582120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[2582405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[2582165,2582079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[2582158,2582087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[2582317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[1663901,1663456,1666051],"length":1,"stats":{"Line":3},"fn_name":"{closure#2}"},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1663503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[1663518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[1663541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[1663564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1663579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1663587,1666049,1668499],"length":1,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[1663912,1663664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[1666082,1663611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1668512,1669171,1669560],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1668550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[1668562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[1668582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[1668594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[1668599,1670255,1669558],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[1668673,1669182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[1669588,1668620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[2582886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[2584640,2586263,2599468],"length":1,"stats":{"Line":1},"fn_name":"generate_contract_helpers"},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[2584679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[2584687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[2584704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[2584727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[2584750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[2584765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[2584780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[2584840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[2584797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[2584810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[2584914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[2584974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[2585051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2585016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[2585238,2585159],"length":1,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[2585321,2585388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[2585490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[2585497,2586274,2585560],"length":1,"stats":{"Line":3},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[2615362,2599488,2600023],"length":1,"stats":{"Line":1},"fn_name":"generate_impl_contract"},{"line":547,"address":[2599517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[2599526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[2601272,2599541],"length":1,"stats":{"Line":2},"fn_name":null},{"line":552,"address":[2599572,2599629,2600034],"length":1,"stats":{"Line":3},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[2599550,2600878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[2601322,2600864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[2615392],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":637,"address":[2615401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[2615815,2615424,2619370],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":642,"address":[2615449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[2615462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[2615467,2615544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[2615875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":170,"coverable":407},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","parser.rs"],"content":"use proc_macro2::{Punct, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Error, Nothing, Parse, ParseBuffer, ParseStream, Parser};\nuse syn::spanned::Spanned;\nuse syn::{parenthesized, Ident, ImplItem, ImplItemMethod, ItemImpl, Path, Result, Token, Type};\n\nuse crate::crate_module;\n\n/// Parsed arguments for `interface` macro\npub struct InterfaceArgs {\n    /// Module name wrapping generated messages, by default no additional module is created\n    pub module: Option\u003cIdent\u003e,\n    /// The type being a parameter of `CosmosMsg` for blockchain it is intendet to be used; can be\n    /// set to any of generic parameters to create interface being generic over blockchains; If not\n    /// provided, cosmos messages would be unparametrized (so default would be used)\n    pub msg_type: Option\u003cType\u003e,\n}\n\n/// Parser arguments for `contract` macro\npub struct ContractArgs {\n    /// Module name wrapping generated messages, by default no additional module is created\n    pub module: Option\u003cIdent\u003e,\n}\n\nimpl Parse for InterfaceArgs {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let mut module = None;\n        let mut msg_type = None;\n\n        while !input.is_empty() {\n            let attr: Ident = input.parse()?;\n            let _: Token![=] = input.parse()?;\n\n            if attr == \"module\" {\n                module = Some(input.parse()?);\n            } else if attr == \"msg_type\" {\n                msg_type = Some(input.parse()?);\n            } else {\n                return Err(Error::new(attr.span(), \"expected `module`, or `msg_type`\"));\n            }\n\n            if input.peek(Token![,]) {\n                let _: Token![,] = input.parse()?;\n            } else if !input.is_empty() {\n                return Err(input.error(\"Unexpected token, comma expected\"));\n            }\n        }\n\n        let _: Nothing = input.parse()?;\n\n        Ok(InterfaceArgs { module, msg_type })\n    }\n}\n\nimpl Parse for ContractArgs {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let mut module = None;\n\n        while !input.is_empty() {\n            let attr: Ident = input.parse()?;\n            let _: Token![=] = input.parse()?;\n\n            if attr == \"module\" {\n                module = Some(input.parse()?);\n            } else {\n                return Err(Error::new(attr.span(), \"expected `module`\"));\n            }\n\n            if input.peek(Token![,]) {\n                let _: Token![,] = input.parse()?;\n            } else if !input.is_empty() {\n                return Err(input.error(\"Unexpected token, comma expected\"));\n            }\n        }\n\n        let _: Nothing = input.parse()?;\n\n        Ok(ContractArgs { module })\n    }\n}\n\n/// Type of message to be generated\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\npub enum MsgType {\n    Exec,\n    Query,\n    Instantiate,\n    Migrate,\n}\n\n/// `#[msg(...)]` attribute for `interface` macro\npub enum MsgAttr {\n    Exec,\n    Query { resp_type: Option\u003cIdent\u003e },\n    Instantiate { name: Ident },\n    Migrate { name: Ident },\n}\n\nimpl MsgType {\n    pub fn emit_ctx_type(self) -\u003e TokenStream {\n        use MsgType::*;\n\n        let sylvia = crate_module();\n\n        match self {\n            Exec | Instantiate =\u003e quote! {\n                (#sylvia ::cw_std::DepsMut, #sylvia ::cw_std::Env, #sylvia ::cw_std::MessageInfo)\n            },\n            Migrate =\u003e quote! {\n                (#sylvia ::cw_std::DepsMut, #sylvia ::cw_std::Env)\n            },\n            Query =\u003e quote! {\n                (#sylvia ::cw_std::Deps, #sylvia ::cw_std::Env)\n            },\n        }\n    }\n\n    /// Emits type which should be returned by dispatch function for this kind of message\n    pub fn emit_result_type(self, msg_type: \u0026Option\u003cType\u003e, err_type: \u0026Type) -\u003e TokenStream {\n        use MsgType::*;\n\n        let sylvia = crate_module();\n\n        match (self, msg_type) {\n            (Exec, Some(msg_type)) | (Instantiate, Some(msg_type)) | (Migrate, Some(msg_type)) =\u003e {\n                quote! {\n                    std::result::Result\u003c#sylvia ::cw_std::Response\u003c#msg_type\u003e, #err_type\u003e\n                }\n            }\n            (Exec, None) | (Instantiate, None) | (Migrate, None) =\u003e quote! {\n                std::result::Result\u003c#sylvia ::cw_std::Response, #err_type\u003e\n            },\n\n            (Query, _) =\u003e quote! {\n                std::result::Result\u003c#sylvia ::cw_std::Binary, #err_type\u003e\n            },\n        }\n    }\n}\n\nimpl PartialEq\u003cMsgType\u003e for MsgAttr {\n    fn eq(\u0026self, other: \u0026MsgType) -\u003e bool {\n        self.msg_type() == *other\n    }\n}\n\nimpl MsgAttr {\n    fn parse_query(content: ParseBuffer) -\u003e Result\u003cSelf\u003e {\n        if content.peek2(Ident) {\n            let _: Punct = content.parse()?;\n            let _: Ident = content.parse()?;\n            let _: Punct = content.parse()?;\n            let resp_type: Option\u003cIdent\u003e = Some(content.parse()?);\n            Ok(Self::Query { resp_type })\n        } else {\n            Ok(Self::Query { resp_type: None })\n        }\n    }\n\n    pub fn msg_type(\u0026self) -\u003e MsgType {\n        use MsgAttr::*;\n\n        match self {\n            Exec =\u003e MsgType::Exec,\n            Query { .. } =\u003e MsgType::Query,\n            Instantiate { .. } =\u003e MsgType::Instantiate,\n            Migrate { .. } =\u003e MsgType::Migrate,\n        }\n    }\n}\n\nimpl Parse for MsgAttr {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let content;\n        parenthesized!(content in input);\n\n        let ty: Ident = content.parse()?;\n        if ty == \"exec\" {\n            Ok(Self::Exec)\n        } else if ty == \"query\" {\n            Self::parse_query(content)\n        } else if ty == \"instantiate\" {\n            let name = Ident::new(\"InstantiateMsg\", content.span());\n            Ok(Self::Instantiate { name })\n        } else if ty == \"migrate\" {\n            let name = Ident::new(\"MigrateMsg\", content.span());\n            Ok(Self::Migrate { name })\n        } else {\n            Err(Error::new(\n                ty.span(),\n                \"Invalid message type, expected one of: `exec`, `query`, `instantiate`, `migrate`\",\n            ))\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct ContractErrorAttr {\n    pub error: Type,\n}\n\n#[cfg(not(tarpaulin_include))]\n// False negative. It is being called in closure\nimpl Parse for ContractErrorAttr {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let content;\n        parenthesized!(content in input);\n\n        content.parse().map(|error| Self { error })\n    }\n}\n\n#[derive(Debug)]\npub struct ContractMessageAttr {\n    pub module: Path,\n    pub exec_generic_params: Vec\u003cPath\u003e,\n    pub query_generic_params: Vec\u003cPath\u003e,\n    pub variant: Ident,\n}\n\n#[cfg(not(tarpaulin_include))]\n// False negative. Called in function below\nfn parse_generics(content: \u0026ParseBuffer) -\u003e Result\u003cVec\u003cPath\u003e\u003e {\n    let _: Token![\u003c] = content.parse()?;\n    let mut params = vec![];\n\n    loop {\n        let param: Path = content.parse()?;\n        params.push(param);\n\n        let generics_close: Option\u003cToken![\u003e]\u003e = content.parse()?;\n        if generics_close.is_some() {\n            break;\n        }\n\n        let comma: Option\u003cToken![,]\u003e = content.parse()?;\n        if comma.is_none() {\n            return Err(Error::new(content.span(), \"Expected comma or `\u003e`\"));\n        }\n    }\n\n    Ok(params)\n}\n\n#[cfg(not(tarpaulin_include))]\n// False negative. It is being called in closure\nimpl Parse for ContractMessageAttr {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let content;\n        parenthesized!(content in input);\n\n        let module = content.parse()?;\n\n        let generics_open: Option\u003cToken![:]\u003e = content.parse()?;\n        let mut exec_generic_params = vec![];\n        let mut query_generic_params = vec![];\n\n        if generics_open.is_some() {\n            loop {\n                let ty: Ident = content.parse()?;\n                let params = if ty == \"exec\" {\n                    \u0026mut exec_generic_params\n                } else if ty == \"query\" {\n                    \u0026mut query_generic_params\n                } else {\n                    return Err(Error::new(ty.span(), \"Invalid message type\"));\n                };\n\n                *params = parse_generics(\u0026content)?;\n\n                if content.peek(Token![as]) {\n                    break;\n                }\n\n                let _: Token![,] = content.parse()?;\n            }\n        }\n\n        let _: Token![as] = content.parse()?;\n\n        let variant = content.parse()?;\n\n        if !content.is_empty() {\n            return Err(Error::new(\n                content.span(),\n                \"Unexpected token on the end of `message` attribtue\",\n            ));\n        }\n\n        Ok(Self {\n            module,\n            exec_generic_params,\n            query_generic_params,\n            variant,\n        })\n    }\n}\n\npub fn parse_struct_message(source: \u0026ItemImpl, ty: MsgType) -\u003e Option\u003c(\u0026ImplItemMethod, MsgAttr)\u003e {\n    let mut methods = source.items.iter().filter_map(|item| match item {\n        ImplItem::Method(method) =\u003e {\n            let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n            let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                Ok(attr) =\u003e attr,\n                Err(err) =\u003e {\n                    emit_error!(method.span(), err);\n                    return None;\n                }\n            };\n\n            if attr == ty {\n                Some((method, attr))\n            } else {\n                None\n            }\n        }\n        _ =\u003e None,\n    });\n\n    let (method, msg_attr) = if let Some(method) = methods.next() {\n        method\n    } else {\n        if ty == MsgType::Instantiate {\n            emit_error!(source.span(), \"No instantiation message\");\n        }\n        return None;\n    };\n\n    if let Some((obsolete, _)) = methods.next() {\n        emit_error!(\n            obsolete.span(), \"More than one instantiation or migration message\";\n            note = method.span() =\u003e \"Instantiation/Migration message previously defined here\"\n        );\n    }\n    Some((method, msg_attr))\n}\n","traces":[{"line":27,"address":[1632953,1632574,1630800],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":28,"address":[1630830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1630835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1630849,1630909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[1630943,1631107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1631226,1631083,1631331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1631413,1632165,1631296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[1631457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1631419,1631833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1631870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[1632490,1631839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1632297,1631811,1632174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1632208,1632304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1632389,1632185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[1632402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1632843,1630928,1632601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1632641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[1632992,1634339,1634640],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":58,"address":[1633022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1633092,1633032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[1633126,1633278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1633254,1633388,1633490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[1633458,1633569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[1633603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1633575,1634259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1633931,1634073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1633984,1634080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1633961,1634162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[1634175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1634366,1633111,1634581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1634411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[1634672,1635268,1636449],"length":1,"stats":{"Line":1},"fn_name":"emit_ctx_type"},{"line":104,"address":[1634700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1634705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1635842,1634738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[1634839,1635283,1634779],"length":1,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[1635354,1634757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1636464,1637214,1638141],"length":1,"stats":{"Line":1},"fn_name":"emit_result_type"},{"line":123,"address":[1636517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1637259,1636626,1636531,1636741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1637249,1636702,1636731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1637264,1636712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1637705,1636680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1636784,1636604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[1638160],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":144,"address":[1638179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1638224,1639300],"length":1,"stats":{"Line":1},"fn_name":"parse_query"},{"line":150,"address":[1638252,1639234,1638311,1638424],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[1638438,1638524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1638580,1638500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[1638791,1638892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[1638951,1638868,1639241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[1639140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1638322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[1639360],"length":1,"stats":{"Line":1},"fn_name":"msg_type"},{"line":164,"address":[1639369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1639398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1639405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1639412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1639419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[1640878,1639440,1640901],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":175,"address":[1639462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1639532,1639470,1639678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[1639649,1639933,1639779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[1640076,1639895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[1640117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1640173,1640082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[1640214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1640526,1640179,1640269],"length":1,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[1640308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1640368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1640535,1640275,1640785,1640873],"length":1,"stats":{"Line":3},"fn_name":null},{"line":187,"address":[1640567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[1640627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1640794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[1640541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1646257,1645680],"length":1,"stats":{"Line":1},"fn_name":"parse_struct_message"},{"line":301,"address":[1645724],"length":1,"stats":{"Line":3},"fn_name":null},{"line":302,"address":[1743086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[1743304,1743106,1743952,1743221,1743966],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":304,"address":[1743234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[1743316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[1743441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[1743540,1743473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[1743696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[1743414,1743814,1743795],"length":1,"stats":{"Line":3},"fn_name":null},{"line":313,"address":[1743816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[1743806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[1743200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[1645781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[1646036,1645969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[1646078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[1646047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[1645959,1646333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[1646375,1646463,1646708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[1646383,1646456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1646697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1647001],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":98},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","remote.rs"],"content":"use proc_macro2::TokenStream;\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::ItemImpl;\n\nuse crate::crate_module;\nuse crate::parser::ContractMessageAttr;\n\npub struct Remote {\n    interfaces: Vec\u003cContractMessageAttr\u003e,\n}\n\nimpl Remote {\n    pub fn for_contract(source: \u0026ItemImpl) -\u003e Self {\n        let interfaces: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(|attr| {\n                let interface = match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e interface,\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        return None;\n                    }\n                };\n\n                Some(interface)\n            })\n            .collect();\n        Self { interfaces }\n    }\n\n    pub fn for_interface() -\u003e Self {\n        Self { interfaces: vec![] }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let from_implementations = self.interfaces.iter().map(|interface| {\n            let ContractMessageAttr { module, .. } = interface;\n\n            quote! {\n                impl\u003c'a\u003e From\u003c\u0026'a Remote\u003c'a\u003e\u003e for #module ::Remote\u003c'a\u003e {\n                    fn from(remote: \u0026'a Remote) -\u003e Self {\n                        Self (\n                            std::borrow::Cow::Borrowed(\u0026remote.0)\n                        )\n                    }\n                }\n            }\n        });\n\n        quote! {\n            pub struct Remote\u003c'a\u003e(pub std::borrow::Cow\u003c'a, #sylvia ::cw_std::Addr\u003e);\n\n            impl Remote\u003c'static\u003e {\n                pub fn new(addr: #sylvia ::cw_std::Addr) -\u003e Self {\n                    Self(std::borrow::Cow::Owned(addr))\n                }\n            }\n\n            impl\u003c'a\u003e Remote\u003c'a\u003e {\n                pub fn borrowed(addr: \u0026'a #sylvia ::cw_std::Addr) -\u003e Self {\n                    Self(std::borrow::Cow::Borrowed(addr))\n                }\n            }\n\n            #(#from_implementations)*\n        }\n    }\n}\n","traces":[{"line":16,"address":[2064304],"length":1,"stats":{"Line":1},"fn_name":"for_contract"},{"line":17,"address":[2064336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1689680,1689694],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[1690171,1689744],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":22,"address":[1689790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[1689843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1689899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[1689925,1689992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[1690148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[1689871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[2064464],"length":1,"stats":{"Line":1},"fn_name":"for_interface"},{"line":37,"address":[2064477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2064528,2065423,2068418],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":41,"address":[2064563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1691088,1691883,1690224],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":44,"address":[1690260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1690269,1691099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2064732,2068281,2065439],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":15,"coverable":18},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","strip_generics.rs"],"content":"use syn::fold::Fold;\n\n/// Removes all generics from type assumning default values for it\npub struct StripGenerics;\n\nimpl Fold for StripGenerics {\n    fn fold_path_arguments(\u0026mut self, _: syn::PathArguments) -\u003e syn::PathArguments {\n        syn::PathArguments::None\n    }\n}\n","traces":[{"line":7,"address":[1621312],"length":1,"stats":{"Line":1},"fn_name":"fold_path_arguments"},{"line":8,"address":[1621340],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","strip_input.rs"],"content":"use syn::fold::{self, Fold};\nuse syn::punctuated::Punctuated;\nuse syn::{FnArg, ImplItemMethod, ItemImpl, PatType, Receiver, Signature, Token, TraitItemMethod};\n\n/// Utility for stripping all attributes from input before it is emitted\npub struct StripInput;\n\nfn remove_input_attr(inputs: Punctuated\u003cFnArg, Token![,]\u003e) -\u003e Punctuated\u003cFnArg, Token![,]\u003e {\n    inputs\n        .into_iter()\n        .map(|input| match input {\n            syn::FnArg::Receiver(rec) if !rec.attrs.is_empty() =\u003e {\n                let rec = Receiver {\n                    attrs: vec![],\n                    ..rec\n                };\n                syn::FnArg::Receiver(rec)\n            }\n            syn::FnArg::Typed(ty) if !ty.attrs.is_empty() =\u003e {\n                let ty = PatType {\n                    attrs: vec![],\n                    ..ty\n                };\n                syn::FnArg::Typed(ty)\n            }\n            _ =\u003e input,\n        })\n        .collect()\n}\n\nimpl Fold for StripInput {\n    fn fold_trait_item_method(\u0026mut self, i: TraitItemMethod) -\u003e TraitItemMethod {\n        let attrs = i\n            .attrs\n            .into_iter()\n            .filter(|attr| !attr.path.is_ident(\"msg\"))\n            .collect();\n\n        let inputs = remove_input_attr(i.sig.inputs);\n        let sig = Signature { inputs, ..i.sig };\n        fold::fold_trait_item_method(self, TraitItemMethod { attrs, sig, ..i })\n    }\n\n    fn fold_impl_item_method(\u0026mut self, i: ImplItemMethod) -\u003e ImplItemMethod {\n        let attrs = i\n            .attrs\n            .into_iter()\n            .filter(|attr| !attr.path.is_ident(\"msg\"))\n            .collect();\n\n        let inputs = remove_input_attr(i.sig.inputs);\n        let sig = Signature { inputs, ..i.sig };\n        fold::fold_impl_item_method(self, ImplItemMethod { attrs, sig, ..i })\n    }\n\n    fn fold_item_impl(\u0026mut self, i: ItemImpl) -\u003e ItemImpl {\n        let attrs = i\n            .attrs\n            .into_iter()\n            .filter(|attr| !(attr.path.is_ident(\"messages\") || attr.path.is_ident(\"error\")))\n            .collect();\n\n        fold::fold_item_impl(self, ItemImpl { attrs, ..i })\n    }\n}\n","traces":[{"line":8,"address":[1700768],"length":1,"stats":{"Line":1},"fn_name":"remove_input_attr"},{"line":9,"address":[1700782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[1182125,1181616,1182511,1181646],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":12,"address":[1181704,1182153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1182295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1182230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[1182399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[1181739,1181823,1181875],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[1181986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1181918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1182064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1181839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1702057,1701845,1700832],"length":1,"stats":{"Line":1},"fn_name":"fold_trait_item_method"},{"line":33,"address":[1701086,1700867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[1182585,1182560],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":39,"address":[1701123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1701224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[1701636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1703168,1703415,1702096],"length":1,"stats":{"Line":1},"fn_name":"fold_impl_item_method"},{"line":45,"address":[1702131,1702366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1182649,1182624],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":51,"address":[1702403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[1702504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1702919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1704162,1703456,1704091],"length":1,"stats":{"Line":1},"fn_name":"fold_item_impl"},{"line":57,"address":[1703491,1703654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1182718,1182688],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":63,"address":[1703693],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":28},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","utils.rs"],"content":"use proc_macro_error::emit_error;\nuse syn::spanned::Spanned;\nuse syn::visit::Visit;\nuse syn::{\n    FnArg, GenericArgument, GenericParam, PathArguments, PathSegment, ReturnType, Signature, Type,\n    WhereClause, WherePredicate,\n};\n\nuse crate::check_generics::CheckGenerics;\nuse crate::message::MsgField;\n\npub fn filter_wheres\u003c'a\u003e(\n    clause: \u0026'a Option\u003cWhereClause\u003e,\n    generics: \u0026[\u0026GenericParam],\n    used_generics: \u0026[\u0026GenericParam],\n) -\u003e Vec\u003c\u0026'a WherePredicate\u003e {\n    clause\n        .as_ref()\n        .map(|clause| {\n            clause\n                .predicates\n                .iter()\n                .filter(|pred| {\n                    let mut generics_checker = CheckGenerics::new(generics);\n                    generics_checker.visit_where_predicate(pred);\n                    generics_checker\n                        .used()\n                        .into_iter()\n                        .all(|gen| used_generics.contains(\u0026gen))\n                })\n                .collect()\n        })\n        .unwrap_or_default()\n}\n\npub fn process_fields\u003c's\u003e(\n    sig: \u0026's Signature,\n    generics_checker: \u0026mut CheckGenerics,\n) -\u003e Vec\u003cMsgField\u003c's\u003e\u003e {\n    sig.inputs\n        .iter()\n        .skip(2)\n        .filter_map(|arg| match arg {\n            FnArg::Receiver(item) =\u003e {\n                emit_error!(item.span(), \"Unexpected `self` argument\");\n                None\n            }\n\n            FnArg::Typed(item) =\u003e MsgField::new(item, generics_checker),\n        })\n        .collect()\n}\n\npub fn extract_return_type(ret_type: \u0026ReturnType) -\u003e \u0026PathSegment {\n    let ReturnType::Type(_, ty) = ret_type  else {\n            unreachable!()\n        };\n\n    let Type::Path(type_path) = ty.as_ref()  else {\n            unreachable!()\n        };\n    let segments = \u0026type_path.path.segments;\n    assert!(!segments.is_empty());\n    let segment = \u0026segments[0];\n\n    // In case of aliased result user need to define the return type by hand\n    if segment.ident != \"Result\" \u0026\u0026 segment.ident != \"StdResult\" {\n        emit_error!(\n            segment.span(),\n            \"Neither Result nor StdResult found in return type. \\\n                    You might be using aliased return type. \\\n                    Please use #[msg(return_type=\u003cyour_return_type\u003e)]\"\n        );\n    }\n    let PathArguments::AngleBracketed(args) = \u0026segments[0].arguments  else{\n            unreachable!()\n        };\n    let args = \u0026args.args;\n    assert!(!args.is_empty());\n    let GenericArgument::Type(Type::Path(type_path)) = \u0026args[0] else{\n            unreachable!()\n        };\n    let segments = \u0026type_path.path.segments;\n    assert!(!segments.is_empty());\n\n    \u0026segments[0]\n}\n","traces":[{"line":12,"address":[1737408],"length":1,"stats":{"Line":1},"fn_name":"filter_wheres"},{"line":17,"address":[1737490,1737539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1576016],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":20,"address":[1576051,1576099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[1576064,1576144,1576421,1576448],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":24,"address":[1576177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[1576225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[1576276,1576389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[1576365,1576545,1576528],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1737584],"length":1,"stats":{"Line":1},"fn_name":"process_fields"},{"line":40,"address":[1737626,1737660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[1576576,1576619],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":44,"address":[1576649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1576657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1576783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1576807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1737712],"length":1,"stats":{"Line":1},"fn_name":"extract_return_type"},{"line":55,"address":[1737732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1737813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1737774,1737848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1737893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1737860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1737983,1737877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1737928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1738013,1737961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[1738121,1738101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1738109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1738232,1738059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[1738273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1738249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[1738257,1738361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1738458,1738308,1738396],"length":1,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[1738423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1738474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1738535,1738491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1738510],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":41}]};
        var previousData = {"files":[{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\n\nuse cw1_subkeys::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ContractExecMsg,\n        query: ContractQueryMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","contract.rs"],"content":"use cosmwasm_std::{\n    ensure, ensure_ne, Addr, BankMsg, Coin, CosmosMsg, Deps, DistributionMsg, Env, Order, Response,\n    StakingMsg, StdResult,\n};\nuse cw1_whitelist::contract::Cw1WhitelistContract;\nuse cw1_whitelist::whitelist;\nuse cw2::set_contract_version;\nuse cw_storage_plus::{Bound, Map};\nuse cw_utils::Expiration;\nuse sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};\nuse sylvia::{contract, schemars};\n\n#[cfg(not(feature = \"library\"))]\nuse sylvia::entry_points;\n\nuse crate::error::ContractError;\nuse crate::responses::{\n    AllAllowancesResponse, AllPermissionsResponse, AllowanceInfo, PermissionsInfo,\n};\nuse crate::state::{Allowance, Permissions};\n\npub const CONTRACT_NAME: \u0026str = env!(\"CARGO_PKG_NAME\");\npub const CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n// Default and max limits for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub struct Cw1SubkeysContract\u003c'a\u003e {\n    pub(crate) whitelist: Cw1WhitelistContract\u003c'a\u003e,\n    pub(crate) permissions: Map\u003c'static, \u0026'a Addr, Permissions\u003e,\n    pub(crate) allowances: Map\u003c'static, \u0026'a Addr, Allowance\u003e,\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_points)]\n#[contract]\n#[error(ContractError)]\n#[messages(cw1 as Cw1)]\n#[messages(whitelist as Whitelist)]\nimpl Cw1SubkeysContract\u003c'_\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            whitelist: Cw1WhitelistContract::new(),\n            permissions: Map::new(\"permissions\"),\n            allowances: Map::new(\"allowances\"),\n        }\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        mut ctx: InstantiateCtx,\n        admins: Vec\u003cString\u003e,\n        mutable: bool,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let result = self.whitelist.instantiate(ctx.branch(), admins, mutable)?;\n        set_contract_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n        Ok(result)\n    }\n\n    #[msg(exec)]\n    pub fn increase_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Coin,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(\n            self.whitelist.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender),\n            ContractError::Unauthorized\n        );\n\n        let spender = ctx.deps.api.addr_validate(\u0026spender)?;\n        ensure_ne!(ctx.info.sender, spender, ContractError::CannotSetOwnAccount);\n\n        self.allowances\n            .update(ctx.deps.storage, \u0026spender, |allow| {\n                let prev_expires = allow\n                    .as_ref()\n                    .map(|allow| allow.expires)\n                    .unwrap_or_default();\n\n                let mut allowance = allow\n                    .filter(|allow| !allow.expires.is_expired(\u0026ctx.env.block))\n                    .unwrap_or_default();\n\n                if let Some(exp) = expires {\n                    if exp.is_expired(\u0026ctx.env.block) {\n                        return Err(ContractError::SettingExpiredAllowance(exp));\n                    }\n\n                    allowance.expires = exp;\n                } else if prev_expires.is_expired(\u0026ctx.env.block) {\n                    return Err(ContractError::SettingExpiredAllowance(prev_expires));\n                }\n\n                allowance.balance += amount.clone();\n                Ok(allowance)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"increase_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"denomination\", amount.denom)\n            .add_attribute(\"amount\", amount.amount);\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    pub fn decrease_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Coin,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(\n            self.whitelist.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender),\n            ContractError::Unauthorized\n        );\n\n        let spender = ctx.deps.api.addr_validate(\u0026spender)?;\n        ensure_ne!(ctx.info.sender, spender, ContractError::CannotSetOwnAccount);\n\n        let allowance = self\n            .allowances\n            .update(ctx.deps.storage, \u0026spender, |allow| {\n                // Fail fast\n                let mut allowance = allow\n                    .filter(|allow| !allow.expires.is_expired(\u0026ctx.env.block))\n                    .ok_or(ContractError::NoAllowance)?;\n\n                if let Some(exp) = expires {\n                    if exp.is_expired(\u0026ctx.env.block) {\n                        return Err(ContractError::SettingExpiredAllowance(exp));\n                    }\n\n                    allowance.expires = exp;\n                }\n\n                // Tolerates underflows (amount bigger than balance), but fails if there are no tokens at all for the denom (report potential errors)\n                allowance.balance = allowance.balance.sub_saturating(amount.clone())?;\n\n                Ok(allowance)\n            })?;\n\n        if allowance.balance.is_empty() {\n            self.allowances.remove(ctx.deps.storage, \u0026spender);\n        }\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"decrease_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"denomination\", amount.denom)\n            .add_attribute(\"amount\", amount.amount);\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    pub fn set_permissions(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        permissions: Permissions,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(\n            self.whitelist.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender),\n            ContractError::Unauthorized\n        );\n\n        let spender = ctx.deps.api.addr_validate(\u0026spender)?;\n        ensure_ne!(ctx.info.sender, spender, ContractError::CannotSetOwnAccount);\n        self.permissions\n            .save(ctx.deps.storage, \u0026spender, \u0026permissions)?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"set_permissions\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"permissions\", permissions.to_string());\n        Ok(res)\n    }\n\n    #[msg(query)]\n    pub fn allowance(\u0026self, ctx: QueryCtx, spender: String) -\u003e StdResult\u003cAllowance\u003e {\n        // we can use unchecked here as it is a query - bad value means a miss, we never write it\n        let spender = Addr::unchecked(spender);\n        let allow = self\n            .allowances\n            .may_load(ctx.deps.storage, \u0026spender)?\n            .filter(|allow| !allow.expires.is_expired(\u0026ctx.env.block))\n            .unwrap_or_default();\n\n        Ok(allow)\n    }\n\n    #[msg(query)]\n    pub fn permissions(\u0026self, ctx: QueryCtx, spender: String) -\u003e StdResult\u003cPermissions\u003e {\n        let spender = Addr::unchecked(spender);\n        let permissions = self\n            .permissions\n            .may_load(ctx.deps.storage, \u0026spender)?\n            .unwrap_or_default();\n\n        Ok(permissions)\n    }\n\n    #[msg(query)]\n    pub fn all_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n        let limit = calc_limit(limit);\n        // we use raw addresses here....\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n        let allowances: StdResult\u003c_\u003e = self\n            .allowances\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .filter(|item| {\n                if let Ok((_, allow)) = item {\n                    !allow.expires.is_expired(\u0026ctx.env.block)\n                } else {\n                    true\n                }\n            })\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, allow)| AllowanceInfo {\n                    spender: addr,\n                    balance: allow.balance,\n                    expires: allow.expires,\n                })\n            })\n            .collect();\n\n        Ok(AllAllowancesResponse {\n            allowances: allowances?,\n        })\n    }\n\n    #[msg(query)]\n    pub fn all_permissions(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllPermissionsResponse\u003e {\n        let limit = calc_limit(limit);\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n        let permissions: StdResult\u003c_\u003e = self\n            .permissions\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, perm)| PermissionsInfo {\n                    spender: addr,\n                    permissions: perm,\n                })\n            })\n            .collect();\n\n        Ok(AllPermissionsResponse {\n            permissions: permissions?,\n        })\n    }\n\n    pub fn is_authorized(\n        \u0026self,\n        deps: Deps,\n        env: \u0026Env,\n        sender: \u0026Addr,\n        msg: \u0026CosmosMsg,\n    ) -\u003e StdResult\u003cbool\u003e {\n        if self.whitelist.is_admin(deps, sender) {\n            return Ok(true);\n        }\n\n        match msg {\n            CosmosMsg::Bank(BankMsg::Send { amount, .. }) =\u003e {\n                // now we check if there is enough allowance for this message\n                let allowance = self.allowances.may_load(deps.storage, sender)?;\n                match allowance {\n                    // if there is an allowance, we subtract the requested amount to ensure it is covered (error on underflow)\n                    Some(allow) =\u003e Ok(!allow.expires.is_expired(\u0026env.block)\n                        \u0026\u0026 (allow.balance - amount.clone()).is_ok()),\n                    None =\u003e Ok(false),\n                }\n            }\n            CosmosMsg::Staking(staking_msg) =\u003e {\n                let permissions = match self.permissions.may_load(deps.storage, sender)? {\n                    Some(permissions) =\u003e permissions,\n                    None =\u003e return Ok(false),\n                };\n\n                let delegate =\n                    matches!(staking_msg, StakingMsg::Delegate { .. } if permissions.delegate);\n                let undelegate =\n                    matches!(staking_msg, StakingMsg::Undelegate { .. } if permissions.undelegate);\n                let redelegate =\n                    matches!(staking_msg, StakingMsg::Redelegate { .. } if permissions.redelegate);\n\n                Ok(delegate || undelegate || redelegate)\n            }\n            CosmosMsg::Distribution(distribution_msg) =\u003e {\n                let permissions = match self.permissions.may_load(deps.storage, sender)? {\n                    Some(permissions) =\u003e permissions,\n                    None =\u003e return Ok(false),\n                };\n\n                let set_withdraw_addr = matches!(distribution_msg, DistributionMsg::SetWithdrawAddress { .. } if permissions.withdraw);\n                let withdraw_perm = matches!(distribution_msg, DistributionMsg::WithdrawDelegatorReward { .. } if permissions.withdraw);\n\n                Ok(set_withdraw_addr || withdraw_perm)\n            }\n            _ =\u003e Ok(false),\n        }\n    }\n}\n\nfn calc_limit(request: Option\u003cu32\u003e) -\u003e usize {\n    request.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize\n}\n","traces":[{"line":35,"address":[881735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[981536],"length":1,"stats":{"Line":5},"fn_name":"new"},{"line":38,"address":[981550],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[981561],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[981589],"length":1,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[982736,981696,982779],"length":1,"stats":{"Line":7},"fn_name":"instantiate"},{"line":51,"address":[982215,981850,981760],"length":1,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[982428,982563,982151],"length":1,"stats":{"Line":8},"fn_name":null},{"line":53,"address":[982480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[984944,982816,984840],"length":1,"stats":{"Line":2},"fn_name":"increase_allowance"},{"line":64,"address":[982887,983115,983022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[982994,982927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[983073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[983038,983188,983368],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[983337,983724,983582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[983333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[983682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[983780,984083,983647,983603],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[983607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[1303601,1303523],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[1304345,1304336],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":83,"address":[1303737,1303683],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[1304393,1303726,1304368],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":87,"address":[1304118,1303801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1304086,1303858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[1304128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1304092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1303960,1303892],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[1304011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1304209,1303971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[1304228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[984516,984237,984432,984345,984575],"length":1,"stats":{"Line":8},"fn_name":null},{"line":103,"address":[984313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[984392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[984484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[984568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[984624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[987137,987287,985040],"length":1,"stats":{"Line":0},"fn_name":"decrease_allowance"},{"line":118,"address":[985111,985339,985246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[985151,985218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[985297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[985592,985262,985412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[985806,985561,985948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[985557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[985906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[985827,985871,986311,986004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[985831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1304451,1304542,1304501,1304760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1304490,1305728,1305753],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":136,"address":[1304706,1304531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1304799,1304998,1304676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1304966,1304826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1305008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1304972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1305495,1305088,1305236,1304857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1305408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[986160,986513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[986548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[986840,986899,986669,986519,986580,986756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[986637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[986716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[986808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[986892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[986943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[989276,987376,989173],"length":1,"stats":{"Line":2},"fn_name":"set_permissions"},{"line":172,"address":[987437,987564,987657],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[987469,987536],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[987615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[987580,987910,987730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[987879,988225,988124],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[987875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[988183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[988281,988140,988488,988151],"length":1,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[988360,988144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[988884,988677,988588,988333,988764],"length":1,"stats":{"Line":10},"fn_name":null},{"line":188,"address":[988645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[988724,988811],"length":1,"stats":{"Line":4},"fn_name":null},{"line":190,"address":[988949,988819,989151],"length":1,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[988957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[997441,1000439,1024059,990119,990092,999819,1024964,989360,1023442],"length":1,"stats":{"Line":5},"fn_name":"allowance"},{"line":197,"address":[989395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[989495,989726,989557,989897,989484,989963],"length":1,"stats":{"Line":5},"fn_name":null},{"line":200,"address":[989488,989769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[989714],"length":1,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[989992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1024136,990697,999357,1000519,1024914,997602,990144,1023514,990721],"length":1,"stats":{"Line":10},"fn_name":"permissions"},{"line":209,"address":[990179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[990279,990341,990636,990561,990268],"length":1,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[990272,990436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[990654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[991732,990736],"length":1,"stats":{"Line":1},"fn_name":"all_allowances"},{"line":225,"address":[990814,990893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[990901],"length":1,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[991017,990960,991088],"length":1,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[990964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[991076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[1306006,1305960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[1305989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1306008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1306032],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":241,"address":[1306112,1306252,1306062,1306128],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":242,"address":[1306182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[1306212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1306242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[991427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[991533,991201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[991776,992720],"length":1,"stats":{"Line":1},"fn_name":"all_permissions"},{"line":261,"address":[991933,991854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[991941],"length":1,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[992000,992057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[992004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[1306448],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":269,"address":[1306480,1306528,1306535,1306604],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":270,"address":[1306567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1306596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[992415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[992189,992521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[992768,994682,994916],"length":1,"stats":{"Line":1},"fn_name":"is_authorized"},{"line":288,"address":[992850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[992969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[993014,992919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[994025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[994046,994210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[994182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[994823,994458,994760,994326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[994413,994799,994693,994842,994482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[994306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[993065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[993601,993082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[993764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[993744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[993792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[993831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[993870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[993904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[993183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[993200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[993435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[993415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[993463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[993502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[993536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[992997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[981488],"length":1,"stats":{"Line":1},"fn_name":"calc_limit"},{"line":335,"address":[981496],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":91,"coverable":145},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","cw1.rs"],"content":"use cosmwasm_std::{ensure, Addr, Response, StdResult};\nuse cw1::{CanExecuteResp, Cw1};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw1SubkeysContract;\nuse crate::error::ContractError;\n\n#[contract]\n#[messages(cw1 as Cw1)]\nimpl Cw1 for Cw1SubkeysContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn execute(\n        \u0026self,\n        ctx: ExecCtx,\n        msgs: Vec\u003ccosmwasm_std::CosmosMsg\u003e,\n    ) -\u003e Result\u003ccosmwasm_std::Response, Self::Error\u003e {\n        let authorized: StdResult\u003c_\u003e = msgs.iter().fold(Ok(true), |acc, msg| {\n            Ok(acc? \u0026 self.is_authorized(ctx.deps.as_ref(), \u0026ctx.env, \u0026ctx.info.sender, msg)?)\n        });\n\n        ensure!(authorized?, ContractError::Unauthorized);\n\n        let res = Response::new()\n            .add_messages(msgs)\n            .add_attribute(\"action\", \"execute\")\n            .add_attribute(\"owner\", ctx.info.sender);\n        Ok(res)\n    }\n\n    #[msg(query)]\n    fn can_execute(\n        \u0026self,\n        ctx: QueryCtx,\n        sender: String,\n        msg: cosmwasm_std::CosmosMsg,\n    ) -\u003e StdResult\u003cCanExecuteResp\u003e {\n        let sender = Addr::unchecked(sender);\n\n        self.is_authorized(ctx.deps, \u0026ctx.env, \u0026sender, \u0026msg)\n            .map(|can| CanExecuteResp { can_execute: can })\n    }\n}\n","traces":[{"line":15,"address":[1044976,1046246,1046185],"length":1,"stats":{"Line":1},"fn_name":"execute"},{"line":20,"address":[1045128,1045024],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[1445418,1445112,1445456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1045651,1045266,1045609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[1045916,1045587,1045792],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[1045761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1045884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1045973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1046613,1046701,1046336],"length":1,"stats":{"Line":1},"fn_name":"can_execute"},{"line":40,"address":[1046375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1046581,1046467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[1445552,1445568],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"}],"covered":12,"coverable":12},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse cw1_whitelist::error::ContractError as WhitelistError;\nuse cw_utils::Expiration;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Contract is frozen\")]\n    ContractFrozen,\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount,\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance,\n\n    #[error(\"Allowance already expired while setting: {0}\")]\n    SettingExpiredAllowance(Expiration),\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cWhitelistError\u003e for ContractError {\n    fn from(err: WhitelistError) -\u003e Self {\n        match err {\n            WhitelistError::Unauthorized =\u003e ContractError::Unauthorized,\n            WhitelistError::ContractFrozen =\u003e ContractError::ContractFrozen,\n            WhitelistError::Std(err) =\u003e ContractError::Std(err),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","lib.rs"],"content":"pub mod contract;\nmod cw1;\npub mod error;\n#[cfg(any(test, feature = \"tests\"))]\npub mod multitest;\npub mod responses;\npub mod state;\nmod whitelist;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","multitest","tests.rs"],"content":"use cosmwasm_std::{coin, coins, Addr};\nuse cw2::{query_contract_info, ContractVersion};\nuse cw_utils::{Expiration, NativeBalance};\nuse sylvia::multitest::App;\n\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::{CONTRACT_NAME, CONTRACT_VERSION};\n\nconst ATOM: \u0026str = \"atom\";\n\n/// Helper function for comparing vectors or another slice-like object as they would represent\n/// set with duplications. Compares sets by first sorting elements using provided ordering.\n/// This functions reshufless elements inplace, as it should never matter as compared\n/// containers should represent same value regardless of ordering, and making this inplace just\n/// safes obsolete copying.\n///\n/// This is implemented as a macro instead of function to throw panic in the place of macro\n/// usage instead of from function called inside test.\nmacro_rules! assert_sorted_eq {\n    ($left:expr, $right:expr, $cmp:expr $(,)?) =\u003e {\n        let mut left = $left;\n        left.sort_by(\u0026$cmp);\n\n        let mut right = $right;\n        right.sort_by($cmp);\n\n        assert_eq!(left, right);\n    };\n}\n\n#[test]\nfn get_contract_version_works() {\n    let app = App::default();\n\n    let owner = \"owner\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(vec![owner.to_owned()], true)\n        .with_label(\"Sublist contract\")\n        .call(owner)\n        .unwrap();\n\n    let version: ContractVersion =\n        query_contract_info(\u0026app.app().wrap(), contract.contract_addr.to_string()).unwrap();\n\n    assert_eq!(\n        ContractVersion {\n            contract: CONTRACT_NAME.to_string(),\n            version: CONTRACT_VERSION.to_string(),\n        },\n        version\n    );\n}\n\nmod allowance {\n    use cw_multi_test::next_block;\n\n    use crate::responses::AllowanceInfo;\n    use crate::state::Allowance;\n\n    use super::*;\n\n    #[test]\n    fn query() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spenders = [\"spender1\", \"spender2\", \"spender3\"];\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Sublist contract\")\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(spenders[0].to_owned(), coin(1, ATOM), None)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(spenders[1].to_owned(), coin(2, ATOM), None)\n            .call(owner)\n            .unwrap();\n\n        assert_eq!(\n            Allowance {\n                balance: NativeBalance(coins(1, ATOM)),\n                expires: Expiration::Never {},\n            },\n            contract.allowance(spenders[0].to_owned()).unwrap()\n        );\n\n        assert_eq!(\n            Allowance {\n                balance: NativeBalance(coins(2, ATOM)),\n                expires: Expiration::Never {},\n            },\n            contract.allowance(spenders[1].to_owned()).unwrap()\n        );\n\n        assert_eq!(\n            Allowance::default(),\n            contract.allowance(spenders[2].to_owned()).unwrap()\n        );\n    }\n\n    #[test]\n    fn query_expired() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender = \"spender\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Sublist contract\")\n            .call(owner)\n            .unwrap();\n\n        let height = app.block_info().height;\n        contract\n            .increase_allowance(\n                spender.to_owned(),\n                coin(1, ATOM),\n                Some(Expiration::AtHeight(height + 1)),\n            )\n            .call(owner)\n            .unwrap();\n\n        app.update_block(next_block);\n\n        // Check allowances work for accounts with balances\n        assert_eq!(\n            Allowance {\n                balance: NativeBalance(vec![]),\n                expires: Expiration::Never {},\n            },\n            contract.allowance(spender.to_owned()).unwrap()\n        );\n    }\n\n    #[test]\n    fn query_all() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender1 = \"spender1\";\n        let spender2 = \"spender2\";\n        let spender3 = \"spender3\";\n        let spender4 = \"spender4\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Sublist contract\")\n            .call(owner)\n            .unwrap();\n\n        let height = app.block_info().height;\n        contract\n            .increase_allowance(spender1.to_owned(), coin(1234, ATOM), None)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(\n                spender2.to_owned(),\n                coin(2345, ATOM),\n                Some(Expiration::Never {}),\n            )\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(\n                spender3.to_owned(),\n                coin(3456, ATOM),\n                Some(Expiration::AtHeight(height + 2)),\n            )\n            .call(owner)\n            .unwrap();\n\n        contract\n            .increase_allowance(\n                spender4.to_owned(),\n                coin(2222, ATOM),\n                Some(Expiration::AtHeight(height + 1)),\n            )\n            .call(owner)\n            .unwrap();\n\n        app.update_block(next_block);\n\n        let batch1 = contract.all_allowances(None, Some(2)).unwrap().allowances;\n        assert_eq!(2, batch1.len());\n\n        let batch2 = contract\n            .all_allowances(Some(batch1.last().unwrap().spender.to_string()), Some(2))\n            .unwrap()\n            .allowances;\n        assert_eq!(1, batch2.len());\n\n        let height = app.block_info().height;\n        let expected = vec![\n            AllowanceInfo {\n                spender: Addr::unchecked(spender1),\n                balance: NativeBalance(coins(1234, ATOM)),\n                expires: Expiration::Never {}, // Not set, expected default\n            },\n            AllowanceInfo {\n                spender: Addr::unchecked(spender2),\n                balance: NativeBalance(coins(2345, ATOM)),\n                expires: Expiration::Never {},\n            },\n            AllowanceInfo {\n                spender: Addr::unchecked(spender3),\n                balance: NativeBalance(coins(3456, ATOM)),\n                expires: Expiration::AtHeight(height + 1),\n            },\n        ];\n\n        // Check allowances work for accounts with balances\n        assert_sorted_eq!(\n            expected,\n            [batch1, batch2].concat(),\n            AllowanceInfo::cmp_by_spender\n        );\n    }\n}\n\nmod permissions {\n    use crate::responses::PermissionsInfo;\n    use crate::state::Permissions;\n\n    use super::*;\n\n    const ALL_PERMS: Permissions = Permissions {\n        delegate: true,\n        redelegate: true,\n        undelegate: true,\n        withdraw: true,\n    };\n\n    const NO_PERMS: Permissions = Permissions {\n        delegate: false,\n        redelegate: false,\n        undelegate: false,\n        withdraw: false,\n    };\n\n    #[test]\n    fn query() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender1 = \"spender1\";\n        let spender2 = \"spender2\";\n        let spender3 = \"spender2\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_string()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender1.to_string(), ALL_PERMS)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender2.to_string(), NO_PERMS)\n            .call(owner)\n            .unwrap();\n\n        assert_eq!(\n            ALL_PERMS,\n            contract.permissions(spender1.to_string()).unwrap()\n        );\n        assert_eq!(\n            NO_PERMS,\n            contract.permissions(spender2.to_string()).unwrap()\n        );\n        assert_eq!(\n            NO_PERMS,\n            contract.permissions(spender3.to_string()).unwrap()\n        );\n    }\n\n    #[test]\n    fn query_all() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let spender1 = \"spender1\";\n        let spender2 = \"spender2\";\n        let spender3 = \"spender3\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender1.to_owned(), ALL_PERMS)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender2.to_owned(), NO_PERMS)\n            .call(owner)\n            .unwrap();\n\n        contract\n            .set_permissions(spender3.to_owned(), NO_PERMS)\n            .call(owner)\n            .unwrap();\n\n        assert_eq!(\n            ALL_PERMS,\n            contract.permissions(spender1.to_owned()).unwrap()\n        );\n        assert_eq!(NO_PERMS, contract.permissions(spender2.to_owned()).unwrap());\n        assert_eq!(NO_PERMS, contract.permissions(spender3.to_owned()).unwrap());\n\n        let batch1 = contract.all_permissions(None, Some(2)).unwrap().permissions;\n        assert_eq!(2, batch1.len());\n\n        let batch2 = contract\n            .all_permissions(Some(batch1.last().unwrap().spender.to_string()), Some(2))\n            .unwrap()\n            .permissions;\n        assert_eq!(1, batch2.len());\n\n        let expected = vec![\n            PermissionsInfo {\n                spender: Addr::unchecked(spender1),\n                permissions: ALL_PERMS,\n            },\n            PermissionsInfo {\n                spender: Addr::unchecked(spender2),\n                permissions: NO_PERMS,\n            },\n            PermissionsInfo {\n                spender: Addr::unchecked(spender3),\n                permissions: NO_PERMS,\n            },\n        ];\n\n        // Check allowances work for accounts with balances\n        assert_sorted_eq!(\n            expected,\n            [batch1, batch2].concat(),\n            PermissionsInfo::cmp_by_spender\n        );\n    }\n}\n\nmod cw1_execute {\n    use crate::cw1::test_utils::Cw1;\n    use cosmwasm_std::BankMsg;\n\n    use super::*;\n\n    #[test]\n    fn can_execute() {\n        let app = App::default();\n\n        let owner = \"owner\";\n        let admin = \"admin\";\n        let non_admin = \"non_admin\";\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned(), admin.to_owned()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        let msg = BankMsg::Send {\n            to_address: \"owner\".to_owned(),\n            amount: vec![],\n        };\n\n        let resp = contract\n            .cw1_proxy()\n            .can_execute(admin.to_string(), msg.clone().into())\n            .unwrap();\n\n        assert!(resp.can_execute);\n\n        let resp = contract\n            .cw1_proxy()\n            .can_execute(non_admin.to_string(), msg.into())\n            .unwrap();\n\n        assert!(!resp.can_execute);\n    }\n\n    #[test]\n    fn execute() {\n        let owner = \"owner\";\n        let admin = \"admin\";\n        let non_admin = \"non_admin\";\n\n        let app = cw_multi_test::App::new(|router, _api, storage| {\n            router\n                .bank\n                .init_balance(storage, \u0026Addr::unchecked(admin), coins(2345, ATOM))\n                .unwrap();\n            router\n                .bank\n                .init_balance(storage, \u0026Addr::unchecked(non_admin), coins(2345, ATOM))\n                .unwrap();\n        });\n\n        let app = App::new(app);\n\n        let code_id = CodeId::store_code(\u0026app);\n\n        let contract = code_id\n            .instantiate(vec![owner.to_owned(), admin.to_string()], false)\n            .with_label(\"Subkeys contract\")\n            .call(owner)\n            .unwrap();\n\n        let msg = BankMsg::Send {\n            to_address: \"owner\".to_owned(),\n            amount: vec![coin(2345, ATOM)],\n        };\n\n        contract\n            .cw1_proxy()\n            .execute(vec![msg.clone().into()])\n            .with_funds(\u0026[coin(2345, ATOM)])\n            .call(admin)\n            .unwrap();\n\n        contract\n            .cw1_proxy()\n            .execute(vec![msg.into()])\n            .with_funds(\u0026[coin(2345, ATOM)])\n            .call(non_admin)\n            .unwrap_err();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","multitest.rs"],"content":"#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","responses.rs"],"content":"use crate::state::Permissions;\nuse cosmwasm_schema::schemars::JsonSchema;\nuse cosmwasm_std::Addr;\nuse cw_utils::{Expiration, NativeBalance};\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllAllowancesResponse {\n    pub allowances: Vec\u003cAllowanceInfo\u003e,\n}\n\n#[cfg(test)]\nimpl AllAllowancesResponse {\n    pub fn canonical(mut self) -\u003e Self {\n        self.allowances = self\n            .allowances\n            .into_iter()\n            .map(AllowanceInfo::canonical)\n            .collect();\n        self.allowances.sort_by(AllowanceInfo::cmp_by_spender);\n        self\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub struct AllowanceInfo {\n    pub spender: Addr,\n    pub balance: NativeBalance,\n    pub expires: Expiration,\n}\n\n#[cfg(test)]\nimpl AllowanceInfo {\n    /// Utility function providing some ordering to be used with `slice::sort_by`.\n    ///\n    /// Note, that this doesn't implement full ordering - items with same spender but differing on\n    /// permissions, would be considered equal, however as spender is a unique key in any valid\n    /// state this is enough for testing purposes.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw_utils::{Expiration, NativeBalance};\n    /// # use cw1_subkeys::msg::AllowanceInfo;\n    /// # use cosmwasm_schema::{cw_serde, QueryResponses};\n    /// # use cosmwasm_std::coin;\n    ///\n    /// let mut allows = vec![Allowance {\n    ///   spender: \"spender2\".to_owned(),\n    ///   balance: NativeBalance(vec![coin(1, \"token1\")]),\n    ///   expires: Expiration::Never {},\n    /// }, Allowance {\n    ///   spender: \"spender1\".to_owned(),\n    ///   balance: NativeBalance(vec![coin(2, \"token2\")]),\n    ///   expires: Expiration::Never {},\n    /// }];\n    ///\n    /// allows.sort_by(Allowance::cmp_by_spender);\n    ///\n    /// assert_eq!(\n    ///   allows.into_iter().map(|allow| allow.spender).collect::\u003cVec\u003c_\u003e\u003e(),\n    ///   vec![\"spender1\".to_owned(), \"spender2\".to_owned()]\n    /// );\n    /// ```\n    pub fn cmp_by_spender(left: \u0026Self, right: \u0026Self) -\u003e std::cmp::Ordering {\n        left.spender.cmp(\u0026right.spender)\n    }\n\n    pub fn canonical(mut self) -\u003e Self {\n        self.balance.normalize();\n        self\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, JsonSchema, Debug, Default)]\npub struct AllPermissionsResponse {\n    pub permissions: Vec\u003cPermissionsInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, JsonSchema, Debug)]\npub struct PermissionsInfo {\n    pub spender: Addr,\n    pub permissions: Permissions,\n}\n\n#[cfg(any(test, feature = \"test-utils\"))]\nimpl PermissionsInfo {\n    /// Utility function providing some ordering to be used with `slice::sort_by`.\n    ///\n    /// Note, that this doesn't implement full ordering - items with same spender but differing on\n    /// permissions, would be considered equal, however as spender is a unique key in any valid\n    /// state this is enough for testing purposes.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw1_subkeys::msg::PermissionsInfo;\n    /// # use cw1_subkeys::state::Permissions;\n    ///\n    /// let mut perms = vec![PermissionsInfo {\n    ///   spender: \"spender2\".to_owned(),\n    ///   permissions: Permissions::default(),\n    /// }, PermissionsInfo {\n    ///   spender: \"spender1\".to_owned(),\n    ///   permissions: Permissions::default(),\n    /// }];\n    ///\n    /// perms.sort_by(PermissionsInfo::cmp_by_spender);\n    ///\n    /// assert_eq!(\n    ///   perms.into_iter().map(|perm| perm.spender).collect::\u003cVec\u003c_\u003e\u003e(),\n    ///   vec![\"spender1\".to_owned(), \"spender2\".to_owned()]\n    /// );\n    /// ```\n    pub fn cmp_by_spender(left: \u0026Self, right: \u0026Self) -\u003e std::cmp::Ordering {\n        left.spender.cmp(\u0026right.spender)\n    }\n\n    pub fn spender(\u0026self) -\u003e \u0026str {\n        self.spender.as_ref()\n    }\n}\n","traces":[{"line":116,"address":[832256],"length":1,"stats":{"Line":1},"fn_name":"cmp_by_spender"},{"line":117,"address":[832270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[832288],"length":1,"stats":{"Line":0},"fn_name":"spender"},{"line":121,"address":[832293],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","state.rs"],"content":"use core::fmt;\n\nuse cw_utils::{Expiration, NativeBalance};\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n// Permissions struct defines users message execution permissions.\n// Could have implemented permissions for each cosmos module(StakingPermissions, GovPermissions etc...)\n// But that meant a lot of code for each module. Keeping the permissions inside one struct is more\n// optimal. Define other modules permissions here.\n#[derive(\n    Serialize, Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema, Default, Copy,\n)]\npub struct Permissions {\n    pub delegate: bool,\n    pub redelegate: bool,\n    pub undelegate: bool,\n    pub withdraw: bool,\n}\n\nimpl fmt::Display for Permissions {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"staking: {{ delegate: {}, redelegate: {}, undelegate: {}, withdraw: {} }}\",\n            self.delegate, self.redelegate, self.undelegate, self.withdraw\n        )\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema, Default)]\npub struct Allowance {\n    pub balance: NativeBalance,\n    pub expires: Expiration,\n}\n\n#[cfg(test)]\nimpl Allowance {\n    /// Utility function for converting message to its canonical form, so two messages with\n    /// different representation but same semantic meaning can be easily compared.\n    ///\n    /// It could be encapsulated in custom `PartialEq` implementation, but `PartialEq` is expected\n    /// to be fast, so it seems to be reasonable to keep it as representation-equality, and\n    /// canonicalize message only when it is needed\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw_utils::{Expiration, NativeBalance};\n    /// # use cw1_subkeys::state::Allowance;\n    /// # use cosmwasm_std::coin;\n    ///\n    /// let allow1 = Allowance {\n    ///   balance: NativeBalance(vec![coin(1, \"token1\"), coin(0, \"token2\"), coin(2, \"token1\"), coin(3, \"token3\")]),\n    ///   expires: Expiration::Never {},\n    /// };\n    ///\n    /// let allow2 = Allowance {\n    ///   balance: NativeBalance(vec![coin(3, \"token3\"), coin(3, \"token1\")]),\n    ///   expires: Expiration::Never {},\n    /// };\n    ///\n    /// assert_eq!(allow1.canonical(), allow2.canonical());\n    /// ```\n    pub fn canonical(mut self) -\u003e Self {\n        self.balance.normalize();\n        self\n    }\n}\n","traces":[{"line":22,"address":[1066448],"length":1,"stats":{"Line":2},"fn_name":"fmt"},{"line":23,"address":[1066481],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-subkeys","src","whitelist.rs"],"content":"use cosmwasm_std::{Response, StdResult};\nuse cw1_whitelist::responses::AdminListResponse;\nuse cw1_whitelist::whitelist::{self, Whitelist};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw1SubkeysContract;\nuse crate::error::ContractError;\n\n// This can be skipped by tarpaulin as it's covered in cw1-whitelist\n#[cfg(not(tarpaulin_include))]\n#[contract]\n#[messages(whitelist as Whitelist)]\nimpl Whitelist for Cw1SubkeysContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn freeze(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e {\n        self.whitelist.freeze(ctx).map_err(From::from)\n    }\n\n    #[msg(exec)]\n    fn update_admins(\u0026self, ctx: ExecCtx, admins: Vec\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e {\n        self.whitelist\n            .update_admins(ctx, admins)\n            .map_err(From::from)\n    }\n\n    #[msg(query)]\n    fn admin_list(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cAdminListResponse\u003e {\n        self.whitelist.admin_list(ctx)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\n\nuse cw1_whitelist::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ContractExecMsg,\n        query: ContractQueryMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","contract.rs"],"content":"use crate::error::ContractError;\nuse crate::whitelist;\nuse cosmwasm_std::{Addr, Deps, Empty, Response};\n\nuse cw2::set_contract_version;\nuse cw_storage_plus::{Item, Map};\nuse sylvia::types::InstantiateCtx;\nuse sylvia::{contract, schemars};\n\n#[cfg(not(feature = \"library\"))]\nuse sylvia::entry_points;\n\nconst CONTRACT_NAME: \u0026str = env!(\"CARGO_PKG_NAME\");\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\npub struct Cw1WhitelistContract\u003c'a\u003e {\n    pub(crate) admins: Map\u003c'static, \u0026'a Addr, Empty\u003e,\n    pub(crate) mutable: Item\u003c'static, bool\u003e,\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_points)]\n#[contract]\n#[error(ContractError)]\n#[messages(cw1 as Cw1)]\n#[messages(whitelist as Whitelist)]\nimpl Cw1WhitelistContract\u003c'_\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            admins: Map::new(\"admins\"),\n            mutable: Item::new(\"mutable\"),\n        }\n    }\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        ctx: InstantiateCtx,\n        admins: Vec\u003cString\u003e,\n        mutable: bool,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        set_contract_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n        for admin in admins {\n            let admin = ctx.deps.api.addr_validate(\u0026admin)?;\n            self.admins.save(ctx.deps.storage, \u0026admin, \u0026Empty {})?;\n        }\n\n        self.mutable.save(ctx.deps.storage, \u0026mutable)?;\n\n        Ok(Response::new())\n    }\n\n    pub fn is_admin(\u0026self, deps: Deps, addr: \u0026Addr) -\u003e bool {\n        self.admins.has(deps.storage, addr)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::responses::AdminListResponse;\n    use crate::whitelist::{self, Whitelist};\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{coin, coins, to_binary, BankMsg, CosmosMsg, StakingMsg, SubMsg, WasmMsg};\n    use cw1::Cw1;\n\n    #[test]\n    fn instantiate_and_modify_config() {\n        let mut deps = mock_dependencies();\n\n        let alice = \"alice\";\n        let bob = \"bob\";\n        let carl = \"carl\";\n\n        let anyone = \"anyone\";\n\n        let contract = Cw1WhitelistContract::new();\n\n        // instantiate the contract\n        let info = mock_info(anyone, \u0026[]);\n        contract\n            .instantiate(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), bob.to_string(), carl.to_string()],\n                true,\n            )\n            .unwrap();\n\n        // ensure expected config\n        let expected = AdminListResponse {\n            admins: vec![alice.to_string(), bob.to_string(), carl.to_string()],\n            mutable: true,\n        };\n        assert_eq!(\n            contract\n                .admin_list((deps.as_ref(), mock_env()).into())\n                .unwrap(),\n            expected\n        );\n\n        // anyone cannot modify the contract\n        let info = mock_info(anyone, \u0026[]);\n        let err = contract\n            .update_admins(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![anyone.to_string()],\n            )\n            .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized);\n\n        // but alice can kick out carl\n        let info = mock_info(alice, \u0026[]);\n        contract\n            .update_admins(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), bob.to_string()],\n            )\n            .unwrap();\n\n        // ensure expected config\n        let expected = AdminListResponse {\n            admins: vec![alice.to_string(), bob.to_string()],\n            mutable: true,\n        };\n        assert_eq!(\n            contract\n                .admin_list((deps.as_ref(), mock_env()).into())\n                .unwrap(),\n            expected\n        );\n\n        // carl cannot freeze it\n        let info = mock_info(carl, \u0026[]);\n        let err = contract\n            .freeze((deps.as_mut(), mock_env(), info).into())\n            .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized);\n\n        // but bob can\n        let info = mock_info(bob, \u0026[]);\n        contract\n            .freeze((deps.as_mut(), mock_env(), info).into())\n            .unwrap();\n        let expected = AdminListResponse {\n            admins: vec![alice.to_string(), bob.to_string()],\n            mutable: false,\n        };\n        assert_eq!(\n            contract\n                .admin_list((deps.as_ref(), mock_env()).into())\n                .unwrap(),\n            expected\n        );\n\n        // and now alice cannot change it again\n        let info = mock_info(alice, \u0026[]);\n        let err = contract\n            .update_admins(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string()],\n            )\n            .unwrap_err();\n        assert_eq!(err, ContractError::ContractFrozen);\n    }\n\n    #[test]\n    fn execute_messages_has_proper_permissions() {\n        let mut deps = mock_dependencies();\n\n        let alice = \"alice\";\n        let bob = \"bob\";\n        let carl = \"carl\";\n\n        let contract = Cw1WhitelistContract::new();\n\n        // instantiate the contract\n        let info = mock_info(bob, \u0026[]);\n        contract\n            .instantiate(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), carl.to_string()],\n                false,\n            )\n            .unwrap();\n\n        let freeze = whitelist::ExecMsg::Freeze {};\n        let msgs = vec![\n            BankMsg::Send {\n                to_address: bob.to_string(),\n                amount: coins(10000, \"DAI\"),\n            }\n            .into(),\n            WasmMsg::Execute {\n                contract_addr: \"some contract\".into(),\n                msg: to_binary(\u0026freeze).unwrap(),\n                funds: vec![],\n            }\n            .into(),\n        ];\n\n        // bob cannot execute them\n        let info = mock_info(bob, \u0026[]);\n        let err = contract\n            .execute((deps.as_mut(), mock_env(), info).into(), msgs.clone())\n            .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized);\n\n        // but carl can\n        let info = mock_info(carl, \u0026[]);\n        let res = contract\n            .execute((deps.as_mut(), mock_env(), info).into(), msgs.clone())\n            .unwrap();\n        assert_eq!(\n            res.messages,\n            msgs.into_iter().map(SubMsg::new).collect::\u003cVec\u003c_\u003e\u003e()\n        );\n        assert_eq!(res.attributes, [(\"action\", \"execute\")]);\n    }\n\n    #[test]\n    fn can_execute_query_works() {\n        let mut deps = mock_dependencies();\n\n        let alice = \"alice\";\n        let bob = \"bob\";\n\n        let anyone = \"anyone\";\n\n        let contract = Cw1WhitelistContract::new();\n\n        // instantiate the contract\n        let info = mock_info(anyone, \u0026[]);\n        contract\n            .instantiate(\n                (deps.as_mut(), mock_env(), info).into(),\n                vec![alice.to_string(), bob.to_string()],\n                false,\n            )\n            .unwrap();\n\n        // let us make some queries... different msg types by owner and by other\n        let send_msg = CosmosMsg::Bank(BankMsg::Send {\n            to_address: anyone.to_string(),\n            amount: coins(12345, \"ushell\"),\n        });\n        let staking_msg = CosmosMsg::Staking(StakingMsg::Delegate {\n            validator: anyone.to_string(),\n            amount: coin(70000, \"ureef\"),\n        });\n\n        // owner can send\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                alice.to_string(),\n                send_msg.clone(),\n            )\n            .unwrap();\n        assert!(res.can_execute);\n\n        // owner can stake\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                bob.to_string(),\n                staking_msg.clone(),\n            )\n            .unwrap();\n        assert!(res.can_execute);\n\n        // anyone cannot send\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                anyone.to_string(),\n                send_msg,\n            )\n            .unwrap();\n        assert!(!res.can_execute);\n\n        // anyone cannot stake\n        let res = contract\n            .can_execute(\n                (deps.as_ref(), mock_env()).into(),\n                anyone.to_string(),\n                staking_msg,\n            )\n            .unwrap();\n        assert!(!res.can_execute);\n    }\n\n    mod msgs {\n        use super::*;\n\n        use cosmwasm_std::{from_binary, from_slice, to_binary, BankMsg};\n\n        use crate::contract::{ContractExecMsg, ContractQueryMsg};\n\n        #[test]\n        fn freeze() {\n            let original = whitelist::ExecMsg::Freeze {};\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n\n            assert_eq!(ContractExecMsg::Whitelist(original), deserialized);\n\n            let json = br#\"{\n                \"freeze\": {}\n            }\"#;\n            let deserialized = from_slice(json).unwrap();\n\n            assert_eq!(\n                ContractExecMsg::Whitelist(whitelist::ExecMsg::Freeze {}),\n                deserialized\n            );\n        }\n\n        #[test]\n        fn update_admins() {\n            let original = whitelist::ExecMsg::UpdateAdmins {\n                admins: vec![\"admin1\".to_owned(), \"admin2\".to_owned()],\n            };\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n\n            assert_eq!(ContractExecMsg::Whitelist(original), deserialized);\n\n            let json = br#\"{\n                \"update_admins\": {\n                    \"admins\": [\"admin1\", \"admin3\"]\n                }\n            }\"#;\n            let deserialized = from_slice(json).unwrap();\n\n            assert_eq!(\n                ContractExecMsg::Whitelist(whitelist::ExecMsg::UpdateAdmins {\n                    admins: vec![\"admin1\".to_owned(), \"admin3\".to_owned()]\n                }),\n                deserialized\n            );\n        }\n\n        #[test]\n        fn admin_list() {\n            let original = whitelist::QueryMsg::AdminList {};\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n\n            assert_eq!(ContractQueryMsg::Whitelist(original), deserialized);\n\n            let json = br#\"{\n                \"admin_list\": {}\n            }\"#;\n            let deserialized = from_slice(json).unwrap();\n\n            assert_eq!(\n                ContractQueryMsg::Whitelist(whitelist::QueryMsg::AdminList {}),\n                deserialized\n            );\n        }\n\n        #[test]\n        fn execute() {\n            let original = cw1::ExecMsg::Execute {\n                msgs: vec![BankMsg::Send {\n                    to_address: \"admin1\".to_owned(),\n                    amount: vec![],\n                }\n                .into()],\n            };\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n            assert_eq!(ContractExecMsg::Cw1(original), deserialized);\n        }\n\n        #[test]\n        fn can_execute() {\n            let original = cw1::QueryMsg::CanExecute {\n                sender: \"admin\".to_owned(),\n                msg: BankMsg::Send {\n                    to_address: \"admin1\".to_owned(),\n                    amount: vec![],\n                }\n                .into(),\n            };\n            let serialized = to_binary(\u0026original).unwrap();\n            let deserialized = from_binary(\u0026serialized).unwrap();\n            assert_eq!(ContractQueryMsg::Cw1(original), deserialized);\n        }\n    }\n}\n","traces":[{"line":21,"address":[821175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[1168416],"length":1,"stats":{"Line":9},"fn_name":"new"},{"line":24,"address":[2123326],"length":1,"stats":{"Line":12},"fn_name":null},{"line":25,"address":[1098506],"length":1,"stats":{"Line":9},"fn_name":null},{"line":29,"address":[2125356,2124870,2123424],"length":1,"stats":{"Line":6},"fn_name":"instantiate"},{"line":35,"address":[2123586,2123703,2123473],"length":1,"stats":{"Line":18},"fn_name":null},{"line":37,"address":[2123637,2123872,2124881],"length":1,"stats":{"Line":16},"fn_name":null},{"line":38,"address":[1169179,1169286,1169473],"length":1,"stats":{"Line":18},"fn_name":null},{"line":39,"address":[2262231,2261960,2262310],"length":1,"stats":{"Line":16},"fn_name":null},{"line":42,"address":[1170003,1170109],"length":1,"stats":{"Line":12},"fn_name":null},{"line":44,"address":[1170094,1170340],"length":1,"stats":{"Line":16},"fn_name":null},{"line":47,"address":[1170416],"length":1,"stats":{"Line":4},"fn_name":"is_admin"},{"line":48,"address":[1170436],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":12,"coverable":13},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","cw1.rs"],"content":"use cosmwasm_std::{Addr, CosmosMsg, Response, StdResult};\nuse cw1::{CanExecuteResp, Cw1};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw1WhitelistContract;\nuse crate::error::ContractError;\n\n#[contract]\n#[messages(cw1 as Cw1)]\nimpl Cw1 for Cw1WhitelistContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn execute(\u0026self, ctx: ExecCtx, msgs: Vec\u003cCosmosMsg\u003e) -\u003e Result\u003cResponse, ContractError\u003e {\n        if !self.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender) {\n            return Err(ContractError::Unauthorized);\n        }\n\n        let resp = Response::new()\n            .add_messages(msgs)\n            .add_attribute(\"action\", \"execute\");\n        Ok(resp)\n    }\n\n    #[msg(query)]\n    fn can_execute(\n        \u0026self,\n        ctx: QueryCtx,\n        sender: String,\n        _msg: CosmosMsg,\n    ) -\u003e StdResult\u003cCanExecuteResp\u003e {\n        let resp = CanExecuteResp {\n            can_execute: self.is_admin(ctx.deps, \u0026Addr::unchecked(sender)),\n        };\n\n        Ok(resp)\n    }\n}\n","traces":[{"line":15,"address":[2138448,2139001],"length":1,"stats":{"Line":2},"fn_name":"execute"},{"line":16,"address":[2276195,2276112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[1183529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[1113966,1113765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[2138783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2276517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1184148,1184250,1183904],"length":1,"stats":{"Line":1},"fn_name":"can_execute"},{"line":34,"address":[1183944,1184073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1184169],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Contract is frozen\")]\n    ContractFrozen,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","lib.rs"],"content":"pub mod contract;\nmod cw1;\npub mod error;\n#[cfg(any(test, feature = \"tests\"))]\npub mod multitest;\npub mod responses;\npub mod whitelist;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","multitest.rs"],"content":"#[cfg(test)]\nmod test {\n    use cosmwasm_std::{to_binary, WasmMsg};\n\n    use crate::contract::multitest_utils::CodeId;\n    use crate::cw1::test_utils::Cw1;\n    use crate::error::ContractError;\n    use crate::responses::AdminListResponse;\n    use crate::whitelist;\n    use crate::whitelist::test_utils::Whitelist;\n    use assert_matches::assert_matches;\n    use sylvia::multitest::App;\n\n    #[test]\n    fn proxy_freeze_message() {\n        let app = App::default();\n        let code_id = CodeId::store_code(\u0026app);\n\n        let owner = \"owner\";\n\n        let first_contract = code_id\n            .instantiate(vec![owner.to_owned()], true)\n            .with_label(\"First contract\")\n            .call(owner)\n            .unwrap();\n\n        let second_contract = code_id\n            .instantiate(vec![first_contract.contract_addr.to_string()], true)\n            .with_label(\"Second contract\")\n            .call(owner)\n            .unwrap();\n\n        let freeze = whitelist::ExecMsg::Freeze {};\n        let freeze = WasmMsg::Execute {\n            contract_addr: second_contract.contract_addr.to_string(),\n            msg: to_binary(\u0026freeze).unwrap(),\n            funds: vec![],\n        };\n\n        first_contract\n            .cw1_proxy()\n            .execute(vec![freeze.into()])\n            .call(owner)\n            .unwrap();\n\n        let resp = second_contract.whitelist_proxy().admin_list().unwrap();\n\n        assert_matches!(\n            resp,\n            AdminListResponse {\n                mutable,\n                ..\n            } if !mutable\n        );\n    }\n\n    #[test]\n    fn update_admins() {\n        let app = App::default();\n        let code_id = CodeId::store_code(\u0026app);\n\n        let owner = \"owner\";\n        let mut admins = vec![\"admin1\".to_owned(), \"admin2\".to_owned()];\n\n        let contract = code_id\n            .instantiate(admins.clone(), true)\n            .call(owner)\n            .unwrap();\n\n        let resp = contract.whitelist_proxy().admin_list().unwrap();\n        assert_eq!(resp.admins, admins);\n\n        admins.push(\"admin3\".to_owned());\n        contract\n            .whitelist_proxy()\n            .update_admins(admins.clone())\n            .call(\"admin1\")\n            .unwrap();\n\n        let resp = contract.whitelist_proxy().admin_list().unwrap();\n        assert_eq!(resp.admins, admins);\n    }\n\n    #[test]\n    fn unathorized_admin_update() {\n        let app = App::default();\n        let code_id = CodeId::store_code(\u0026app);\n\n        let owner = \"owner\";\n\n        let contract = code_id\n            .instantiate(vec![owner.to_string()], true)\n            .call(owner)\n            .unwrap();\n\n        let err = contract\n            .whitelist_proxy()\n            .update_admins(vec![owner.to_owned(), \"fake_admin\".to_owned()])\n            .call(\"fake_admin\")\n            .unwrap_err();\n\n        assert_eq!(err, ContractError::Unauthorized);\n\n        contract.whitelist_proxy().freeze().call(owner).unwrap();\n\n        let err = contract\n            .whitelist_proxy()\n            .update_admins(vec![owner.to_owned(), \"admin\".to_owned()])\n            .call(owner)\n            .unwrap_err();\n\n        assert_eq!(err, ContractError::ContractFrozen);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","responses.rs"],"content":"use serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, schemars::JsonSchema, Debug, Default)]\npub struct AdminListResponse {\n    pub admins: Vec\u003cString\u003e,\n    pub mutable: bool,\n}\n\n#[cfg(any(test, feature = \"test-utils\"))]\nimpl AdminListResponse {\n    /// Utility function forconverting message to its canonical form, so two messages with\n    /// different representation but same semantical meaning can be easly compared.\n    ///\n    /// It could be encapsulated in custom `PartialEq` implementation, but `PartialEq` is expected\n    /// to be quickly, so it seems to be reasonable to keep it as representation-equality, and\n    /// canonicalize message only when it is needed\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use cw1_whitelist::msg::AdminListResponse;\n    ///\n    /// let resp1 = AdminListResponse {\n    ///   admins: vec![\"admin1\".to_owned(), \"admin2\".to_owned()],\n    ///   mutable: true,\n    /// };\n    ///\n    /// let resp2 = AdminListResponse {\n    ///   admins: vec![\"admin2\".to_owned(), \"admin1\".to_owned(), \"admin2\".to_owned()],\n    ///   mutable: true,\n    /// };\n    ///\n    /// assert_eq!(resp1.canonical(), resp2.canonical());\n    /// ```\n    pub fn canonical(mut self) -\u003e Self {\n        self.admins.sort();\n        self.admins.dedup();\n        self\n    }\n}\n","traces":[{"line":36,"address":[942240,942386],"length":1,"stats":{"Line":0},"fn_name":"canonical"},{"line":37,"address":[942265,942319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[942330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[942351],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw1-whitelist","src","whitelist.rs"],"content":"use cosmwasm_std::{Empty, Order, Response, StdResult};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{contract, interface, schemars};\n\nuse crate::contract::Cw1WhitelistContract;\nuse crate::error::ContractError;\nuse crate::responses::AdminListResponse;\n\n#[interface]\npub trait Whitelist {\n    type Error: From\u003ccosmwasm_std::StdError\u003e;\n\n    #[msg(exec)]\n    fn freeze(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn update_admins(\u0026self, ctx: ExecCtx, admins: Vec\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn admin_list(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cAdminListResponse\u003e;\n}\n\n#[contract]\nimpl Whitelist for Cw1WhitelistContract\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn freeze(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, ContractError\u003e {\n        if !self.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender) {\n            return Err(ContractError::Unauthorized);\n        }\n\n        self.mutable.save(ctx.deps.storage, \u0026false)?;\n\n        let resp = Response::new().add_attribute(\"action\", \"freeze\");\n        Ok(resp)\n    }\n\n    #[msg(exec)]\n    fn update_admins(\n        \u0026self,\n        ctx: ExecCtx,\n        mut admins: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        if !self.is_admin(ctx.deps.as_ref(), \u0026ctx.info.sender) {\n            return Err(ContractError::Unauthorized);\n        }\n\n        if !self.mutable.load(ctx.deps.storage)? {\n            return Err(ContractError::ContractFrozen);\n        }\n\n        admins.sort_unstable();\n        let mut low_idx = 0;\n\n        let to_remove: Vec\u003c_\u003e = self\n            .admins\n            .keys(ctx.deps.storage, None, None, Order::Ascending)\n            .filter(|addr| {\n                // This is a bit of optimization basing on the fact that both `admins` and queried\n                // keys range are sorted. Binary search would always return the index which is at\n                // most as big as searched item, so for next item there is no point in looking at\n                // lower indices. On the other hand - if we reached and of the sequence, we want to\n                // remove all following keys.\n                addr.as_ref()\n                    .map(|addr| {\n                        if low_idx \u003e= admins.len() {\n                            return true;\n                        }\n\n                        match admins[low_idx..].binary_search(\u0026addr.into()) {\n                            Ok(idx) =\u003e {\n                                low_idx = idx;\n                                false\n                            }\n                            Err(idx) =\u003e {\n                                low_idx = idx;\n                                true\n                            }\n                        }\n                    })\n                    .unwrap_or(true)\n            })\n            .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n\n        for addr in to_remove {\n            self.admins.remove(ctx.deps.storage, \u0026addr);\n        }\n\n        for admin in admins {\n            let admin = ctx.deps.api.addr_validate(\u0026admin)?;\n            self.admins.save(ctx.deps.storage, \u0026admin, \u0026Empty {})?;\n        }\n\n        let resp = Response::new().add_attribute(\"action\", \"update_admins\");\n        Ok(resp)\n    }\n\n    #[msg(query)]\n    fn admin_list(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cAdminListResponse\u003e {\n        let admins: Result\u003c_, _\u003e = self\n            .admins\n            .keys(ctx.deps.storage, None, None, Order::Ascending)\n            .map(|addr| addr.map(String::from))\n            .collect();\n\n        Ok(AdminListResponse {\n            admins: admins?,\n            mutable: self.mutable.load(ctx.deps.storage)?,\n        })\n    }\n}\n","traces":[{"line":28,"address":[1184272,1184875],"length":1,"stats":{"Line":1},"fn_name":"freeze"},{"line":29,"address":[1184374,1184320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[1184452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[1184506,1184414,1184581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1184749,1184566],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[1184795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[1184912,1186419,1187759],"length":1,"stats":{"Line":1},"fn_name":"update_admins"},{"line":45,"address":[1185047,1184960],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[1185118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1185087,1185198],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[1185451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1185511,1185429],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[1185528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[1185660,1185579,1186037],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[1185540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[971184],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":65,"address":[971216,971246],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[971551,971296,971229],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":67,"address":[971326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[971461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[971531,971362],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[971577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[971590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[971598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[971605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[971618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[971626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1186115,1185838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[1186331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1187469,1186435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1186700,1186805,1186992],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[1187289,1186947,1187210],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[1187583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1187638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[1187776,1188454,1188829],"length":1,"stats":{"Line":2},"fn_name":"admin_list"},{"line":101,"address":[1187947,1187858],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[1187819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[971680,971648],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":107,"address":[1188494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[1188194,1187986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1188475,1188417,1188160,1188621],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":40,"coverable":41},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","allowances.rs"],"content":"use cosmwasm_std::{Addr, Binary, Order, Response, StdError, StdResult, Uint128};\nuse cw20_allowances::responses::{\n    AllAccountsResponse, AllAllowancesResponse, AllSpenderAllowancesResponse, AllowanceInfo,\n    AllowanceResponse, SpenderAllowanceInfo,\n};\nuse cw20_allowances::Cw20Allowances;\nuse cw_storage_plus::{Bound, Bounder};\nuse cw_utils::Expiration;\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse crate::contract::Cw20Base;\nuse crate::error::ContractError;\nuse crate::responses::Cw20ReceiveMsg;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\n#[contract]\n#[messages(cw20_allowances as Cw20Allowances)]\nimpl Cw20Allowances for Cw20Base\u003c'_\u003e {\n    type Error = ContractError;\n\n    /// Allows spender to access an additional amount tokens from the owner's (env.sender) account.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn increase_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let spender_addr = ctx.deps.api.addr_validate(\u0026spender)?;\n        if spender_addr == ctx.info.sender {\n            return Err(ContractError::CannotSetOwnAccount);\n        }\n\n        let update_fn = |allow: Option\u003cAllowanceResponse\u003e| -\u003e Result\u003c_, _\u003e {\n            let allow = allow.unwrap_or_default();\n            let allowance = allow.allowance + amount;\n            match expires {\n                Some(expires) if !expires.is_expired(\u0026ctx.env.block) =\u003e {\n                    Ok(AllowanceResponse { allowance, expires })\n                }\n                None =\u003e Ok(AllowanceResponse { allowance, ..allow }),\n                _ =\u003e Err(ContractError::InvalidExpiration),\n            }\n        };\n        self.allowances.update(\n            ctx.deps.storage,\n            (\u0026ctx.info.sender, \u0026spender_addr),\n            update_fn,\n        )?;\n        self.allowances_spender.update(\n            ctx.deps.storage,\n            (\u0026spender_addr, \u0026ctx.info.sender),\n            update_fn,\n        )?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"increase_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Lowers the spender's access of tokens from the owner's (env.sender) account by amount.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn decrease_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let spender_addr = Addr::unchecked(\u0026spender);\n        if spender_addr == ctx.info.sender {\n            return Err(ContractError::CannotSetOwnAccount);\n        }\n\n        let key = (\u0026ctx.info.sender, \u0026spender_addr);\n\n        let reverse = |(a, b)| (b, a);\n\n        // load value and delete if it hits 0, or update otherwise\n        let mut allowance = self.allowances.load(ctx.deps.storage, key)?;\n        if amount \u003c allowance.allowance {\n            // update the new amount\n            allowance.allowance = allowance\n                .allowance\n                .checked_sub(amount)\n                .map_err(StdError::overflow)?;\n            if let Some(exp) = expires {\n                if exp.is_expired(\u0026ctx.env.block) {\n                    return Err(ContractError::InvalidExpiration);\n                }\n                allowance.expires = exp;\n            }\n            self.allowances.save(ctx.deps.storage, key, \u0026allowance)?;\n            self.allowances_spender\n                .save(ctx.deps.storage, reverse(key), \u0026allowance)?;\n        } else {\n            self.allowances.remove(ctx.deps.storage, key);\n            self.allowances_spender\n                .remove(ctx.deps.storage, reverse(key));\n        }\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"decrease_allowance\")\n            .add_attribute(\"owner\", ctx.info.sender)\n            .add_attribute(\"spender\", spender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Transfers amount tokens from owner -\u003e recipient\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn transfer_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026recipient)?;\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n\n        // Avoid doing state update in case of self to self transfer\n        if rcpt_addr == owner_addr {\n            let resp = Response::new()\n                .add_attribute(\"action\", \"transfer_from\")\n                .add_attribute(\"from\", owner)\n                .add_attribute(\"to\", recipient)\n                .add_attribute(\"by\", ctx.info.sender)\n                .add_attribute(\"amount\", amount);\n            return Ok(resp);\n        }\n\n        if ctx.info.sender != owner {\n            // deduct allowance before doing anything else have enough allowance\n            self.deduct_allowance(\n                ctx.deps.storage,\n                \u0026owner_addr,\n                \u0026ctx.info.sender,\n                \u0026ctx.env.block,\n                amount,\n            )?;\n        }\n\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n                Ok(balance.unwrap_or_default().checked_sub(amount)?)\n            },\n        )?;\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026rcpt_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n        )?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"transfer_from\")\n            .add_attribute(\"from\", owner)\n            .add_attribute(\"to\", recipient)\n            .add_attribute(\"by\", ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Sends amount tokens from owner -\u003e contract\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn send_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026contract)?;\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n\n        // deduct allowance before doing anything else have enough allowance\n        self.deduct_allowance(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            \u0026ctx.info.sender,\n            \u0026ctx.env.block,\n            amount,\n        )?;\n\n        // move the tokens to the contract\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n                Ok(balance.unwrap_or_default().checked_sub(amount)?)\n            },\n        )?;\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026rcpt_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n        )?;\n\n        let resp = Response::new()\n            .add_attribute(\"action\", \"send_from\")\n            .add_attribute(\"from\", \u0026owner)\n            .add_attribute(\"to\", \u0026contract)\n            .add_attribute(\"by\", \u0026ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n\n        // create a send message\n        let msg = Cw20ReceiveMsg {\n            sender: ctx.info.sender.into(),\n            amount,\n            msg,\n        }\n        .into_cosmos_msg(contract)?;\n\n        let resp = resp.add_message(msg);\n        Ok(resp)\n    }\n\n    /// Destroys amount of tokens forever\n    #[msg(exec)]\n    fn burn_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n\n        // deduct allowance before doing anything else have enough allowance\n        self.deduct_allowance(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            \u0026ctx.info.sender,\n            \u0026ctx.env.block,\n            amount,\n        )?;\n\n        // lower balance\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026owner_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n                Ok(balance.unwrap_or_default().checked_sub(amount)?)\n            },\n        )?;\n        // reduce total_supply\n        self.token_info\n            .update(ctx.deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n                meta.total_supply = meta.total_supply.checked_sub(amount)?;\n                Ok(meta)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"burn_from\")\n            .add_attribute(\"owner\", owner)\n            .add_attribute(\"spender\", ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Returns how much spender can use from owner account, 0 if unset.\n    #[msg(query)]\n    fn allowance(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        spender: String,\n    ) -\u003e StdResult\u003cAllowanceResponse\u003e {\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n        let spender_addr = ctx.deps.api.addr_validate(\u0026spender)?;\n        let allowance = self\n            .allowances\n            .may_load(ctx.deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n            .unwrap_or_default();\n        Ok(allowance)\n    }\n\n    /// Returns all allowances this owner has approved. Supports pagination.\n    #[msg(query)]\n    fn all_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n        let owner_addr = ctx.deps.api.addr_validate(\u0026owner)?;\n        let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n        let allowances = self\n            .allowances\n            .prefix(\u0026owner_addr)\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, allow)| AllowanceInfo {\n                    spender: addr.into(),\n                    allowance: allow.allowance,\n                    expires: allow.expires,\n                })\n            })\n            .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n        Ok(AllAllowancesResponse { allowances })\n    }\n\n    /// Returns all allowances this spender has been granted. Supports pagination.\n    #[msg(query)]\n    fn all_spender_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        spender: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllSpenderAllowancesResponse\u003e {\n        let spender_addr = ctx.deps.api.addr_validate(\u0026spender)?;\n        let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n        let start_after = start_after.map(Addr::unchecked);\n        let start = start_after.as_ref().and_then(Bounder::exclusive_bound);\n\n        let allowances = self\n            .allowances_spender\n            .prefix(\u0026spender_addr)\n            .range(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, allow)| SpenderAllowanceInfo {\n                    owner: addr.into(),\n                    allowance: allow.allowance,\n                    expires: allow.expires,\n                })\n            })\n            .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n        Ok(AllSpenderAllowancesResponse { allowances })\n    }\n\n    /// Returns all allowances this spender has been granted. Supports pagination.\n    #[msg(query)]\n    fn all_accounts(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n        let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n        let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n        let accounts = self\n            .balances\n            .keys(ctx.deps.storage, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| item.map(Into::into))\n            .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n        Ok(AllAccountsResponse { accounts })\n    }\n}\n","traces":[{"line":28,"address":[1278642,1276544,1278542],"length":1,"stats":{"Line":5},"fn_name":"increase_allowance"},{"line":35,"address":[1276628,1276924,1276756],"length":1,"stats":{"Line":10},"fn_name":null},{"line":36,"address":[1277143,1276893],"length":1,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[1277325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1277163],"length":1,"stats":{"Line":9},"fn_name":null},{"line":41,"address":[2185934],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[2185971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2186037],"length":1,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[2186267,2186183],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[2186294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2186077],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[2186216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1277738,1277204,1277408,1277275],"length":1,"stats":{"Line":25},"fn_name":null},{"line":52,"address":[1277208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1277215],"length":1,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[1277243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1277557,1277486,1277781,1277996],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[1277490],"length":1,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[1277497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1277525],"length":1,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[1278091,1278255,1277853,1278308,1278176],"length":1,"stats":{"Line":12},"fn_name":null},{"line":64,"address":[1278144],"length":1,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[1278224],"length":1,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[1278298],"length":1,"stats":{"Line":8},"fn_name":null},{"line":67,"address":[1278348],"length":1,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[1281450,1278736,1281550],"length":1,"stats":{"Line":1},"fn_name":"decrease_allowance"},{"line":80,"address":[1278838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1279003,1278935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[1279100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1279019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[2186419,2186400],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":90,"address":[1279324,1279050,1279186],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[1279483,1279282],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[1279568,1279536,1279881],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[1279552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1279753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[1280080,1279710,1279913],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[1279945,1280042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[1280090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[1280048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[1280143,1279982,1280315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[1280495,1280205,1280730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[1280602,1280214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1279499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1280978,1280854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1280863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1281075,1281213,1280990,1281154,1280584],"length":1,"stats":{"Line":10},"fn_name":null},{"line":114,"address":[1281043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[1281123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[1281197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1281256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[1284400,1281632],"length":1,"stats":{"Line":1},"fn_name":"transfer_from"},{"line":130,"address":[1282050,1281865,1281709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[1282285,1282007,1282452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[1282674,1282433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1282720,1283029,1282811,1282890,1282970],"length":1,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[1282780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1282859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1282938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1283013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1283064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1283155,1283425,1282690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[1283276,1283563],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[1283242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1283249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1283256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1283260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1283590,1283878,1283171,1283198],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[1283175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1283190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[2186547,2186670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[1284140,1283711,1283905,1283684],"length":1,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[1283688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1283703],"length":1,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[1284606,1284765,1283997,1284685,1284522,1284824],"length":1,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[1284575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1284654],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[1284733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[1284808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[1284864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1285264,1288674],"length":1,"stats":{"Line":1},"fn_name":"send_from"},{"line":188,"address":[1285369,1285553,1285741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1286204,1285976,1285695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[1286156,1286438,1286709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[1286122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1286129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1286136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1286140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1286755,1286512,1286539,1287046],"length":1,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[1286516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1286531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[2186995,2187118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1287311,1287073,1286849,1286876],"length":1,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[1286853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1286868],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[1287529,1287338,1287165,1287478],"length":1,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[1287474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1287569,1287513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[1287577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1287816,1288195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1288029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1288848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1291678,1291578,1289328],"length":1,"stats":{"Line":1},"fn_name":"burn_from"},{"line":241,"address":[1289386,1289514,1289727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[1289685,1289955,1290217],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[1289657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1289664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[1289671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[1289675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[1290533,1290029,1290260,1290053],"length":1,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[1290033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[1290045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[2187566,2187443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[1290374,1291020,1290576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[1290354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[2187761,2187892,2187690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[2187841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[1291123,1291294,1291214,1291347],"length":1,"stats":{"Line":4},"fn_name":null},{"line":269,"address":[1291183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[1291262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[1291337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[1291387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1291760,1293276,1293350],"length":1,"stats":{"Line":2},"fn_name":"allowance"},{"line":283,"address":[1292090,1291813,1291909],"length":1,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[1292048,1292321,1292546],"length":1,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[1292467,1292777,1293032,1292507],"length":1,"stats":{"Line":6},"fn_name":null},{"line":287,"address":[1292904,1292471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1293195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[1295087,1293376,1294674],"length":1,"stats":{"Line":2},"fn_name":"all_allowances"},{"line":301,"address":[1293460,1293580,1293744],"length":1,"stats":{"Line":4},"fn_name":null},{"line":302,"address":[1293968,1293725],"length":1,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[1294003],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[1294210,1294321,1294637,1294070],"length":1,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[1294143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[2188192],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":311,"address":[2188224,2188390,2188288,2188272],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":312,"address":[2188323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[2188370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[2188380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[1294894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[1296497,1295104,1296948],"length":1,"stats":{"Line":1},"fn_name":"all_spender_allowances"},{"line":330,"address":[1295484,1295188,1295320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[1295708,1295465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[1295743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[1295874,1295805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[1295894,1296144,1296031,1296460],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[1295964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[2188432],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":341,"address":[2188528,2188512,2188630,2188464],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":342,"address":[2188563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[2188610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[2188620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[1296736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[1296976,1297906],"length":1,"stats":{"Line":1},"fn_name":"all_accounts"},{"line":359,"address":[1297054,1297136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[1297171],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[1297289,1297844,1297232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[1297236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[2188816,2188784],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":369,"address":[1297563],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":158,"coverable":160},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\n\nuse cw20_base::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ContractExecMsg,\n        query: ContractQueryMsg,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","contract.rs"],"content":"use crate::error::ContractError;\nuse crate::responses::{BalanceResponse, Cw20Coin, Cw20ReceiveMsg, TokenInfoResponse};\nuse crate::validation::{validate_accounts, validate_msg, verify_logo};\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{\n    ensure, Addr, Binary, BlockInfo, DepsMut, Order, Response, StdError, StdResult, Storage,\n    Uint128,\n};\nuse cw2::set_contract_version;\nuse cw20_allowances::responses::AllowanceResponse;\nuse cw20_marketing::responses::{LogoInfo, MarketingInfoResponse};\nuse cw20_marketing::Logo;\nuse cw20_minting::responses::MinterResponse;\nuse cw_storage_plus::{Item, Map};\nuse cw_utils::ensure_from_older_version;\nuse sylvia::types::{ExecCtx, InstantiateCtx, MigrateCtx, QueryCtx};\nuse sylvia::{contract, schemars};\n\n#[cfg(not(feature = \"library\"))]\nuse sylvia::entry_points;\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:cw20-base\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cw_serde]\npub struct TokenInfo {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub total_supply: Uint128,\n    pub mint: Option\u003cMinterData\u003e,\n}\n\nimpl TokenInfo {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n}\n\n#[cw_serde]\npub struct MinterData {\n    pub minter: Addr,\n    /// cap is how many more tokens can be issued by the minter\n    pub cap: Option\u003cUint128\u003e,\n}\n\n#[cw_serde]\npub struct InstantiateMarketingInfo {\n    pub project: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub marketing: Option\u003cString\u003e,\n    pub logo: Option\u003cLogo\u003e,\n}\n\n#[cw_serde]\npub struct InstantiateMsgData {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cCw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n    pub marketing: Option\u003cInstantiateMarketingInfo\u003e,\n}\n\npub struct Cw20Base\u003c'a\u003e {\n    pub(crate) token_info: Item\u003c'static, TokenInfo\u003e,\n    pub(crate) marketing_info: Item\u003c'static, MarketingInfoResponse\u003e,\n    pub(crate) logo: Item\u003c'static, Logo\u003e,\n    pub(crate) balances: Map\u003c'static, \u0026'a Addr, Uint128\u003e,\n    pub(crate) allowances: Map\u003c'static, (\u0026'a Addr, \u0026'a Addr), AllowanceResponse\u003e,\n    // TODO: After https://github.com/CosmWasm/cw-plus/issues/670 is implemented, replace this with a `MultiIndex` over `ALLOWANCES`\n    pub(crate) allowances_spender: Map\u003c'static, (\u0026'a Addr, \u0026'a Addr), AllowanceResponse\u003e,\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_points)]\n#[contract]\n#[error(ContractError)]\n#[messages(cw20_allowances as Allowances)]\n#[messages(cw20_marketing as Marketing)]\n#[messages(cw20_minting as Minting)]\nimpl Cw20Base\u003c'_\u003e {\n    pub const fn new() -\u003e Self {\n        Self {\n            token_info: Item::new(\"token_info\"),\n            marketing_info: Item::new(\"marketing_info\"),\n            logo: Item::new(\"logo\"),\n            balances: Map::new(\"balances\"),\n            allowances: Map::new(\"allowances\"),\n            allowances_spender: Map::new(\"allowances_spender\"),\n        }\n    }\n\n    pub fn create_accounts(\n        \u0026self,\n        deps: \u0026mut DepsMut,\n        accounts: \u0026[Cw20Coin],\n    ) -\u003e Result\u003cUint128, ContractError\u003e {\n        validate_accounts(accounts)?;\n\n        let mut total_supply = Uint128::zero();\n        for row in accounts {\n            let address = deps.api.addr_validate(\u0026row.address)?;\n            self.balances.save(deps.storage, \u0026address, \u0026row.amount)?;\n            total_supply += row.amount;\n        }\n\n        Ok(total_supply)\n    }\n\n    // this can be used to update a lower allowance - call bucket.update with proper keys\n    pub fn deduct_allowance(\n        \u0026self,\n        storage: \u0026mut dyn Storage,\n        owner: \u0026Addr,\n        spender: \u0026Addr,\n        block: \u0026BlockInfo,\n        amount: Uint128,\n    ) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n        let update_fn = |current: Option\u003cAllowanceResponse\u003e| -\u003e _ {\n            let allowance = current.ok_or(ContractError::NoAllowance)?;\n\n            if !allowance.expires.is_expired(block) {\n                // deduct the allowance if enough\n                let expires = allowance.expires;\n                let allowance = allowance\n                    .allowance\n                    .checked_sub(amount)\n                    .map_err(StdError::overflow)?;\n                Ok(AllowanceResponse { allowance, expires })\n            } else {\n                Err(ContractError::Expired)\n            }\n        };\n        self.allowances\n            .update(storage, (owner, spender), update_fn)?;\n        self.allowances_spender\n            .update(storage, (spender, owner), update_fn)\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        mut ctx: InstantiateCtx,\n        data: InstantiateMsgData,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let InstantiateMsgData {\n            name,\n            symbol,\n            decimals,\n            initial_balances,\n            mint,\n            marketing,\n        } = data;\n        set_contract_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n        // check valid token info\n        validate_msg(\u0026name, \u0026symbol, decimals)?;\n        // create initial accounts\n        let total_supply = self.create_accounts(\u0026mut ctx.deps, \u0026initial_balances)?;\n\n        ensure!(\n            !matches!(\n                mint.as_ref().and_then(|v| v.cap), Some(limit) if total_supply \u003e limit\n            ),\n            StdError::generic_err(\"Initial supply greater than cap\")\n        );\n\n        let mint = match mint {\n            Some(m) =\u003e Some(MinterData {\n                minter: ctx.deps.api.addr_validate(\u0026m.minter)?,\n                cap: m.cap,\n            }),\n            None =\u003e None,\n        };\n\n        // store token info\n        let data = TokenInfo {\n            name,\n            symbol,\n            decimals,\n            total_supply,\n            mint,\n        };\n        self.token_info.save(ctx.deps.storage, \u0026data)?;\n\n        if let Some(marketing) = marketing {\n            let logo = if let Some(logo) = marketing.logo {\n                verify_logo(\u0026logo)?;\n                self.logo.save(ctx.deps.storage, \u0026logo)?;\n\n                match logo {\n                    Logo::Url(url) =\u003e Some(LogoInfo::Url(url)),\n                    Logo::Embedded(_) =\u003e Some(LogoInfo::Embedded),\n                }\n            } else {\n                None\n            };\n\n            let data = MarketingInfoResponse {\n                project: marketing.project,\n                description: marketing.description,\n                marketing: marketing\n                    .marketing\n                    .map(|addr| ctx.deps.api.addr_validate(\u0026addr))\n                    .transpose()?,\n                logo,\n            };\n            self.marketing_info.save(ctx.deps.storage, \u0026data)?;\n        }\n\n        Ok(Response::default())\n    }\n\n    /// Transfer is a base message to move tokens to another account without triggering actions\n    #[msg(exec)]\n    fn transfer(\n        \u0026self,\n        ctx: ExecCtx,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(amount != Uint128::zero(), ContractError::InvalidZeroAmount);\n\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026recipient)?;\n\n        self.balances\n            .update(ctx.deps.storage, \u0026ctx.info.sender, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_sub(amount)?)\n            })?;\n        self.balances\n            .update(ctx.deps.storage, \u0026rcpt_addr, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_add(amount)?)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"transfer\")\n            .add_attribute(\"from\", ctx.info.sender)\n            .add_attribute(\"to\", recipient)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Burn is a base message to destroy tokens forever\n    #[msg(exec)]\n    fn burn(\u0026self, ctx: ExecCtx, amount: Uint128) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(amount != Uint128::zero(), ContractError::InvalidZeroAmount);\n\n        // lower balance\n        self.balances\n            .update(ctx.deps.storage, \u0026ctx.info.sender, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_sub(amount)?)\n            })?;\n        // reduce total_supply\n        self.token_info\n            .update(ctx.deps.storage, |mut info| -\u003e StdResult\u003c_\u003e {\n                info.total_supply = info.total_supply.checked_sub(amount)?;\n                Ok(info)\n            })?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"burn\")\n            .add_attribute(\"from\", ctx.info.sender)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    /// Send is a base message to transfer tokens to a contract and trigger an action\n    /// on the receiving contract.\n    #[msg(exec)]\n    fn send(\n        \u0026self,\n        ctx: ExecCtx,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        ensure!(amount != Uint128::zero(), ContractError::InvalidZeroAmount);\n\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026contract)?;\n\n        // move the tokens to the contract\n        self.balances\n            .update(ctx.deps.storage, \u0026ctx.info.sender, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_sub(amount)?)\n            })?;\n        self.balances\n            .update(ctx.deps.storage, \u0026rcpt_addr, |balance| {\n                Ok::\u003c_, StdError\u003e(balance.unwrap_or_default().checked_add(amount)?)\n            })?;\n        let res = Response::new()\n            .add_attribute(\"action\", \"send\")\n            .add_attribute(\"from\", \u0026ctx.info.sender)\n            .add_attribute(\"to\", \u0026contract)\n            .add_attribute(\"amount\", amount);\n\n        let msg = Cw20ReceiveMsg {\n            sender: ctx.info.sender.into(),\n            amount,\n            msg,\n        }\n        .into_cosmos_msg(contract)?;\n\n        let res = res.add_message(msg);\n        Ok(res)\n    }\n\n    /// Returns the current balance of the given address, 0 if unset.\n    #[msg(query)]\n    fn balance(\u0026self, ctx: QueryCtx, address: String) -\u003e StdResult\u003cBalanceResponse\u003e {\n        let address = ctx.deps.api.addr_validate(\u0026address)?;\n        let balance = self\n            .balances\n            .may_load(ctx.deps.storage, \u0026address)?\n            .unwrap_or_default();\n        Ok(BalanceResponse { balance })\n    }\n\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    #[msg(query)]\n    fn token_info(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n        let info = self.token_info.load(ctx.deps.storage)?;\n        let res = TokenInfoResponse {\n            name: info.name,\n            symbol: info.symbol,\n            decimals: info.decimals,\n            total_supply: info.total_supply,\n        };\n        Ok(res)\n    }\n\n    #[msg(migrate)]\n    fn migrate(\u0026self, ctx: MigrateCtx) -\u003e Result\u003cResponse, ContractError\u003e {\n        let original_version =\n            ensure_from_older_version(ctx.deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n        if original_version \u003c \"0.14.0\".parse::\u003csemver::Version\u003e().unwrap() {\n            // Build reverse map of allowances per spender\n            let data = self\n                .allowances\n                .range(ctx.deps.storage, None, None, Order::Ascending)\n                .collect::\u003cStdResult\u003cVec\u003c_\u003e\u003e\u003e()?;\n            for ((owner, spender), allowance) in data {\n                self.allowances_spender\n                    .save(ctx.deps.storage, (\u0026spender, \u0026owner), \u0026allowance)?;\n            }\n        }\n        Ok(Response::default())\n    }\n}\n","traces":[{"line":33,"address":[1276512],"length":1,"stats":{"Line":1},"fn_name":"get_cap"},{"line":34,"address":[1276517],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[1864487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1311072],"length":1,"stats":{"Line":11},"fn_name":"new"},{"line":80,"address":[1311095],"length":1,"stats":{"Line":11},"fn_name":null},{"line":81,"address":[1311118],"length":1,"stats":{"Line":11},"fn_name":null},{"line":82,"address":[1311141],"length":1,"stats":{"Line":12},"fn_name":null},{"line":83,"address":[1311166],"length":1,"stats":{"Line":11},"fn_name":null},{"line":84,"address":[1311193],"length":1,"stats":{"Line":12},"fn_name":null},{"line":85,"address":[1311220],"length":1,"stats":{"Line":11},"fn_name":null},{"line":89,"address":[1312365,1311344],"length":1,"stats":{"Line":1},"fn_name":"create_accounts"},{"line":94,"address":[1311429,1311536],"length":1,"stats":{"Line":12},"fn_name":null},{"line":96,"address":[1311482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1311623,1311513,1311715],"length":1,"stats":{"Line":23},"fn_name":null},{"line":98,"address":[1311960,1311736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1311926,1312086,1312177],"length":1,"stats":{"Line":12},"fn_name":null},{"line":100,"address":[1312143],"length":1,"stats":{"Line":11},"fn_name":null},{"line":103,"address":[1311678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[1312400],"length":1,"stats":{"Line":1},"fn_name":"deduct_allowance"},{"line":115,"address":[1312506],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[1768030,1768296],"length":1,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[1768270,1768717,1768417],"length":1,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[1768424],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[1768459,1768779,1768480],"length":1,"stats":{"Line":7},"fn_name":null},{"line":123,"address":[1768469],"length":1,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[1768722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1768631],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[1768388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1312837,1312524,1312554],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[1312528,1312783],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[1312721,1312751],"length":1,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[1312725],"length":1,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[1319838,1312880,1315308],"length":1,"stats":{"Line":12},"fn_name":"instantiate"},{"line":143,"address":[1312941],"length":1,"stats":{"Line":11},"fn_name":null},{"line":144,"address":[1313045],"length":1,"stats":{"Line":12},"fn_name":null},{"line":145,"address":[1313077],"length":1,"stats":{"Line":11},"fn_name":null},{"line":146,"address":[1313097],"length":1,"stats":{"Line":12},"fn_name":null},{"line":147,"address":[1313121],"length":1,"stats":{"Line":11},"fn_name":null},{"line":148,"address":[1313164],"length":1,"stats":{"Line":12},"fn_name":null},{"line":150,"address":[1313481,1313274,1313387],"length":1,"stats":{"Line":12},"fn_name":null},{"line":153,"address":[1313447,1313702,1313853],"length":1,"stats":{"Line":12},"fn_name":null},{"line":155,"address":[1314176,1313825,1314042],"length":1,"stats":{"Line":13},"fn_name":null},{"line":157,"address":[1314597,1314516],"length":1,"stats":{"Line":12},"fn_name":null},{"line":158,"address":[1314397,1314447,1314499],"length":1,"stats":{"Line":13},"fn_name":null},{"line":159,"address":[1314408,1314336,1314153,1314461],"length":1,"stats":{"Line":16},"fn_name":null},{"line":161,"address":[1314550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[1314522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1315002,1314679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1314842,1314735,1315136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[1314978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1314654],"length":1,"stats":{"Line":11},"fn_name":null},{"line":180,"address":[1315623,1315693,1315788],"length":1,"stats":{"Line":12},"fn_name":null},{"line":182,"address":[1315745,1315958,1319482],"length":1,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[1316024,1316070],"length":1,"stats":{"Line":8},"fn_name":null},{"line":184,"address":[1316410,1316503,1316126],"length":1,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[1316458,1316677,1316772],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[1316729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[1316995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1317209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[1316136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1316164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1316204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1316308,1317921,1316244,1317382,1317516],"length":1,"stats":{"Line":8},"fn_name":null},{"line":204,"address":[1317748,1318236,1318154],"length":1,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[1319514,1316060],"length":1,"stats":{"Line":12},"fn_name":null},{"line":212,"address":[1319856,1321725,1321825],"length":1,"stats":{"Line":1},"fn_name":"transfer"},{"line":218,"address":[1320137,1320045,1319906],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[1319938,1320006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[1320095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1320414,1320209,1320061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[1320613,1320898,1320383,1320355],"length":1,"stats":{"Line":4},"fn_name":null},{"line":226,"address":[1320359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[1769091,1769214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1320944,1320731,1321179,1320707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[1320711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1769395,1769518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1321274,1321036,1321438,1321491,1321359],"length":1,"stats":{"Line":5},"fn_name":null},{"line":236,"address":[1321327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1321407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1321481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1321531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1343565,1321920,1342930,1323432,1344242,1331583,1323493],"length":1,"stats":{"Line":2},"fn_name":"burn"},{"line":245,"address":[1322198,1322092,1321965],"length":1,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[1322053,1321981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[1322159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1322517,1322244,1322136,1322108],"length":1,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[1322112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1769822,1769699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1322358,1323004,1322560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[1322338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[1770017,1770148,1769946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1770097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[1323144,1323052,1323197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[1323112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1323187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[1323242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[1323584,1326239],"length":1,"stats":{"Line":1},"fn_name":"send"},{"line":279,"address":[1323848,1323941,1323653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[1323717,1323797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[1323899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[1324014,1324222,1323864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[1324709,1324191,1324160,1324421],"length":1,"stats":{"Line":4},"fn_name":null},{"line":288,"address":[1324164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1770419,1770542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[1324542,1324515,1324990,1324755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[1324519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[1770723,1770846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[1324847,1325017,1325165,1325074],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[1325070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[1325205,1325149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[1325213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[1325446,1325820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[1325657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[1326407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[1327868,1326848,1333448,1332775,1327826,1356118,1333911,1356251,1356521],"length":1,"stats":{"Line":5},"fn_name":"balance"},{"line":315,"address":[1326992,1326896,1327167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[1327152,1327748,1327128,1327632,1327395],"length":1,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[1327504,1327132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[1327764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[1327888,1328789],"length":1,"stats":{"Line":1},"fn_name":"token_info"},{"line":326,"address":[1327996,1327921,1328604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[1328281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[1328307],"length":1,"stats":{"Line":3},"fn_name":null},{"line":330,"address":[1328336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[1328344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[1328442],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[1328816,1329444,1330937],"length":1,"stats":{"Line":1},"fn_name":"migrate"},{"line":338,"address":[1328851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[1329326,1329082,1330799,1329459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":343,"address":[1329493,1329926,1329536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[1329497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1329727,1330746,1330018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[1330338,1330295,1330427,1330634],"length":1,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[1330299,1330506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[1329473,1330827],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":132,"coverable":135},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount,\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount,\n\n    #[error(\"Allowance is expired\")]\n    Expired,\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance,\n\n    #[error(\"Minting cannot exceed the cap\")]\n    CannotExceedCap,\n\n    #[error(\"Logo binary data exceeds 5KB limit\")]\n    LogoTooBig,\n\n    #[error(\"Invalid xml preamble for SVG\")]\n    InvalidXmlPreamble,\n\n    #[error(\"Invalid png header\")]\n    InvalidPngHeader,\n\n    #[error(\"Invalid expiration value\")]\n    InvalidExpiration,\n\n    #[error(\"Duplicate initial balance addresses\")]\n    DuplicateInitialBalanceAddresses,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","lib.rs"],"content":"pub mod allowances;\npub mod contract;\npub mod error;\npub mod marketing;\npub mod minting;\npub mod responses;\npub mod validation;\n\n#[cfg(test)]\nmod multitest;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","marketing.rs"],"content":"use crate::contract::Cw20Base;\nuse crate::error::ContractError;\nuse crate::validation::verify_logo;\nuse cosmwasm_std::{Response, StdError, StdResult};\nuse cw20_marketing::responses::{DownloadLogoResponse, LogoInfo, MarketingInfoResponse};\nuse cw20_marketing::{Cw20Marketing, EmbeddedLogo, Logo};\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\n#[contract]\n#[messages(cw20_marketing as Cw20Marketing)]\nimpl Cw20Marketing for Cw20Base\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn update_marketing(\n        \u0026self,\n        ctx: ExecCtx,\n        project: Option\u003cString\u003e,\n        description: Option\u003cString\u003e,\n        marketing: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let mut marketing_info = self\n            .marketing_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        if marketing_info\n            .marketing\n            .as_ref()\n            .ok_or(ContractError::Unauthorized)?\n            != \u0026ctx.info.sender\n        {\n            return Err(ContractError::Unauthorized);\n        }\n\n        match project {\n            Some(empty) if empty.trim().is_empty() =\u003e marketing_info.project = None,\n            Some(project) =\u003e marketing_info.project = Some(project),\n            None =\u003e (),\n        }\n\n        match description {\n            Some(empty) if empty.trim().is_empty() =\u003e marketing_info.description = None,\n            Some(description) =\u003e marketing_info.description = Some(description),\n            None =\u003e (),\n        }\n\n        match marketing {\n            Some(empty) if empty.trim().is_empty() =\u003e marketing_info.marketing = None,\n            Some(marketing) =\u003e {\n                marketing_info.marketing = Some(ctx.deps.api.addr_validate(\u0026marketing)?)\n            }\n            None =\u003e (),\n        }\n\n        if marketing_info.project.is_none()\n            \u0026\u0026 marketing_info.description.is_none()\n            \u0026\u0026 marketing_info.marketing.is_none()\n            \u0026\u0026 marketing_info.logo.is_none()\n        {\n            self.marketing_info.remove(ctx.deps.storage);\n        } else {\n            self.marketing_info\n                .save(ctx.deps.storage, \u0026marketing_info)?;\n        }\n\n        let res = Response::new().add_attribute(\"action\", \"update_marketing\");\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    fn upload_logo(\u0026self, ctx: ExecCtx, logo: Logo) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let mut marketing_info = self\n            .marketing_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        verify_logo(\u0026logo)?;\n\n        if marketing_info\n            .marketing\n            .as_ref()\n            .ok_or(ContractError::Unauthorized)?\n            != \u0026ctx.info.sender\n        {\n            return Err(ContractError::Unauthorized);\n        }\n\n        self.logo.save(ctx.deps.storage, \u0026logo)?;\n\n        let logo_info = match logo {\n            Logo::Url(url) =\u003e LogoInfo::Url(url),\n            Logo::Embedded(_) =\u003e LogoInfo::Embedded,\n        };\n\n        marketing_info.logo = Some(logo_info);\n        self.marketing_info\n            .save(ctx.deps.storage, \u0026marketing_info)?;\n\n        let res = Response::new().add_attribute(\"action\", \"upload_logo\");\n        Ok(res)\n    }\n\n    #[msg(query)]\n    fn marketing_info(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cMarketingInfoResponse\u003e {\n        Ok(self\n            .marketing_info\n            .may_load(ctx.deps.storage)?\n            .unwrap_or_default())\n    }\n\n    #[msg(query)]\n    fn download_logo(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cDownloadLogoResponse\u003e {\n        let logo = self.logo.load(ctx.deps.storage)?;\n        match logo {\n            Logo::Embedded(EmbeddedLogo::Svg(logo)) =\u003e Ok(DownloadLogoResponse {\n                mime_type: \"image/svg+xml\".to_owned(),\n                data: logo,\n            }),\n            Logo::Embedded(EmbeddedLogo::Png(logo)) =\u003e Ok(DownloadLogoResponse {\n                mime_type: \"image/png\".to_owned(),\n                data: logo,\n            }),\n            Logo::Url(_) =\u003e Err(StdError::not_found(\"logo\")),\n        }\n    }\n}\n","traces":[{"line":16,"address":[1372477,1375386,1370288],"length":1,"stats":{"Line":1},"fn_name":"update_marketing"},{"line":23,"address":[1370958,1370429,1371463,1371040,1370362,1370812,1370516],"length":1,"stats":{"Line":11},"fn_name":null},{"line":25,"address":[1370414,1370830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1370777,1371335],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[1371684,1371309,1371837,1371890,1371569],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[1371542,1371709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[1371656],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[1371939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1371904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1372285,1372039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[1372160,1372488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1371997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[1372882,1372666],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[1372757,1373074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1372624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1373420,1373236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1373335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1373676,1374042,1373366],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[1374218,1374175,1374270,1374322,1373202],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[1374191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1374247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1374307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1374407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1374445,1374633,1374357,1374384],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[1374505,1374361],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[1374435,1375010],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[1375066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1378579,1378452,1375408],"length":1,"stats":{"Line":7},"fn_name":"upload_logo"},{"line":74,"address":[1376485,1375486,1376005,1375862,1375451,1376080,1375566],"length":1,"stats":{"Line":29},"fn_name":null},{"line":76,"address":[1375471,1375877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[1376357,1375827],"length":1,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[1376629,1376342,1376569],"length":1,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[1376601,1376832,1376944,1377091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[1376963,1376805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1376916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1377174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1377316,1377143,1377224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[1377281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1377476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1377618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1377630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1377861,1378071,1377837],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[1377943,1377841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1377928,1378208],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[1378261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1379210,1378608],"length":1,"stats":{"Line":1},"fn_name":"marketing_info"},{"line":107,"address":[1379184,1378640,1379135,1378659,1378718],"length":1,"stats":{"Line":10},"fn_name":null},{"line":109,"address":[1379007,1378644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1379248,1380159,1380689],"length":1,"stats":{"Line":1},"fn_name":"download_logo"},{"line":115,"address":[1379579,1379281,1379381],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[1379542,1379798],"length":1,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[1379806,1380328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[1379840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1380280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1380028,1379870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1379904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1379980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1380492,1379764],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":54,"coverable":58},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","minting.rs"],"content":"use crate::contract::{Cw20Base, MinterData};\nuse crate::error::ContractError;\nuse cosmwasm_std::{Response, StdResult, Uint128};\nuse cw20_minting::responses::MinterResponse;\nuse cw20_minting::Cw20Minting;\nuse sylvia::contract;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\n#[contract]\n#[messages(cw20_minting as Cw20Minting)]\nimpl Cw20Minting for Cw20Base\u003c'_\u003e {\n    type Error = ContractError;\n\n    #[msg(exec)]\n    fn mint(\n        \u0026self,\n        ctx: ExecCtx,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        if amount == Uint128::zero() {\n            return Err(ContractError::InvalidZeroAmount);\n        }\n\n        let mut config = self\n            .token_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        if config\n            .mint\n            .as_ref()\n            .ok_or(ContractError::Unauthorized)?\n            .minter\n            != ctx.info.sender\n        {\n            return Err(ContractError::Unauthorized);\n        }\n\n        // update supply and enforce cap\n        config.total_supply += amount;\n        if let Some(limit) = config.get_cap() {\n            if config.total_supply \u003e limit {\n                return Err(ContractError::CannotExceedCap);\n            }\n        }\n        self.token_info.save(ctx.deps.storage, \u0026config)?;\n\n        // add amount to recipient balance\n        let rcpt_addr = ctx.deps.api.addr_validate(\u0026recipient)?;\n        self.balances.update(\n            ctx.deps.storage,\n            \u0026rcpt_addr,\n            |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n        )?;\n\n        let res = Response::new()\n            .add_attribute(\"action\", \"mint\")\n            .add_attribute(\"to\", recipient)\n            .add_attribute(\"amount\", amount);\n        Ok(res)\n    }\n\n    #[msg(exec)]\n    fn update_minter(\n        \u0026self,\n        ctx: ExecCtx,\n        new_minter: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        let mut config = self\n            .token_info\n            .may_load(ctx.deps.storage)?\n            .ok_or(ContractError::Unauthorized)?;\n\n        let mint = config.mint.as_ref().ok_or(ContractError::Unauthorized)?;\n        if mint.minter != ctx.info.sender {\n            return Err(ContractError::Unauthorized);\n        }\n\n        let minter_data = new_minter\n            .map(|new_minter| ctx.deps.api.addr_validate(\u0026new_minter))\n            .transpose()?\n            .map(|minter| MinterData {\n                minter,\n                cap: mint.cap,\n            });\n\n        config.mint = minter_data;\n\n        self.token_info.save(ctx.deps.storage, \u0026config)?;\n\n        let resp = Response::new()\n            .add_attribute(\"action\", \"update_minter\")\n            .add_attribute(\n                \"new_minter\",\n                config\n                    .mint\n                    .map(|m| m.minter.into_string())\n                    .unwrap_or_else(|| \"None\".to_string()),\n            );\n        Ok(resp)\n    }\n\n    #[msg(query)]\n    fn minter(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cOption\u003cMinterResponse\u003e\u003e {\n        let meta = self.token_info.load(ctx.deps.storage)?;\n        let minter = match meta.mint {\n            Some(m) =\u003e Some(MinterResponse {\n                minter: m.minter.into(),\n                cap: m.cap,\n            }),\n            None =\u003e None,\n        };\n        Ok(minter)\n    }\n}\n","traces":[{"line":15,"address":[1384171,1380704,1384111],"length":1,"stats":{"Line":1},"fn_name":"mint"},{"line":21,"address":[1380856,1380760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[1380946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1381497,1381026,1381989,1381354,1380934],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[1381369,1380919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1381861,1381319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1382319,1382168,1382088,1382365,1381841],"length":1,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[1382061,1382191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1382164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1382411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1382371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1382466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[1382645,1382570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1382656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1382706,1382810,1382611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[1382984,1382768,1383196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[1383395,1383157,1383130,1383630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[1383134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1275552,1275623],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":57,"address":[1383818,1383734,1383487,1383877],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[1383787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1383861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1383917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1384192,1387470,1387288],"length":1,"stats":{"Line":3},"fn_name":"update_minter"},{"line":70,"address":[1385334,1384682,1384825,1384235,1384290,1384892,1384354],"length":1,"stats":{"Line":15},"fn_name":null},{"line":72,"address":[1384275,1384697],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[1385206,1384647],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[1385410,1385186,1385552],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[1385525,1385723],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[1385838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1385794,1386039,1385888,1386206,1385739],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[1385770],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[1275934,1275888],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":84,"address":[1275900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1275917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1386251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[1386435,1386578,1386503],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[1386811,1386563,1387001],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[1386867,1386994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[1275979,1275968],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":99,"address":[1276044,1276032],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":101,"address":[1387065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[1388450,1388177,1387488],"length":1,"stats":{"Line":1},"fn_name":"minter"},{"line":106,"address":[1387520,1387729,1387602],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1387692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1388093,1387926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[1387973],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1388069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1387909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1388265],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":49,"coverable":50},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","allowances_tests.rs"],"content":"use cosmwasm_std::{Binary, StdError, Timestamp, Uint128};\nuse cw20_allowances::responses::{\n    AllAllowancesResponse, AllSpenderAllowancesResponse, AllowanceInfo, AllowanceResponse,\n    SpenderAllowanceInfo,\n};\nuse cw_multi_test::next_block;\nuse cw_utils::Expiration;\nuse sylvia::multitest::App;\n\nuse crate::allowances::test_utils::Cw20Allowances;\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::InstantiateMsgData;\nuse crate::error::ContractError;\nuse crate::multitest::receiver_contract::multitest_utils::CodeId as ReceiverCodeId;\nuse crate::responses::Cw20Coin;\n\n#[test]\nfn increase_decrease_allowances() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: Uint128::new(12340000),\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let allowances = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowances, AllowanceResponse::default());\n\n    // set allowance with height expiration\n    let allowance = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // decrease it a bit with no expire set - stays the same\n    let lower = Uint128::new(4444);\n    let allowance = allowance.checked_sub(lower).unwrap();\n    contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(spender.to_string(), lower, None)\n        .call(owner)\n        .unwrap();\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // increase it some more and override the expires\n    let raise = Uint128::new(87654);\n    let allowance = allowance + raise;\n    let expires = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), raise, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // decrease it below 0\n    contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(spender.to_string(), Uint128::new(99988647623876347), None)\n        .call(owner)\n        .unwrap();\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse::default());\n}\n\n#[test]\nfn allowances_independent() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let spender2 = \"addr0003\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: Uint128::new(12340000),\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse::default());\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, AllowanceResponse::default());\n\n    // set allowance with height expiration\n    let allowance = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // set other allowance with no expiration\n    let allowance2 = Uint128::new(87654);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), allowance2, None)\n        .call(owner)\n        .unwrap();\n\n    // check they are proper\n    let expect_one = AllowanceResponse { allowance, expires };\n    let expect_two = AllowanceResponse {\n        allowance: allowance2,\n        expires: Expiration::Never {},\n    };\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_one);\n\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_two);\n\n    // also allow spender -\u003e spender2 with no interference\n    let allowance3 = Uint128::new(1821);\n    let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), allowance3, Some(expires3))\n        .call(spender)\n        .unwrap();\n\n    let expect_three = AllowanceResponse {\n        allowance: allowance3,\n        expires: expires3,\n    };\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_one);\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_two);\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(spender.to_string(), spender2.to_string())\n        .unwrap();\n    assert_eq!(allowance_resp, expect_three);\n}\n\n#[test]\nfn no_self_allowance() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: Uint128::new(12340000),\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // self-allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(owner.to_string(), Uint128::new(7777), None)\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotSetOwnAccount);\n\n    // decrease self-allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(owner.to_string(), Uint128::new(7777), None)\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotSetOwnAccount);\n}\n\n#[test]\nfn transfer_from_self_to_self() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // valid transfer of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), owner.to_string(), transfer)\n        .call(owner)\n        .unwrap();\n\n    // make sure amount of money is the same\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(balance_resp.balance, amount);\n}\n\n#[test]\nfn transfer_from_owner_requires_no_allowance() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let rcpt = \"addr0003\";\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // valid transfer of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), transfer)\n        .call(owner)\n        .unwrap();\n\n    // make sure money arrived\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    let balance_resp = contract.balance(rcpt.to_string()).unwrap();\n    assert_eq!(balance_resp.balance, transfer);\n}\n\n#[test]\nfn transfer_from_respects_limits() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let rcpt = \"addr0003\";\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // provide an allowance\n    let allowance = Uint128::new(77777);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // valid transfer of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), transfer)\n        .call(spender)\n        .unwrap();\n\n    // make sure money arrived\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    let balance_resp = contract.balance(rcpt.to_string()).unwrap();\n    assert_eq!(balance_resp.balance, transfer);\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {}\n        }\n    );\n\n    // cannot send more than the allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // let us increase limit, but set the expiration to expire in the next block\n    let next_block_height = app.app.borrow().block_info().height + 1;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(\n            spender.to_string(),\n            Uint128::new(1000),\n            Some(Expiration::AtHeight(next_block_height)),\n        )\n        .call(owner)\n        .unwrap();\n\n    // move to next block\n    app.app.borrow_mut().update_block(next_block);\n\n    // we should now get the expiration error\n    let err = contract\n        .cw20_allowances_proxy()\n        .transfer_from(owner.to_string(), rcpt.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Expired));\n}\n\n#[test]\nfn burn_from_respects_limits() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // provide an allowance\n    let allowance = Uint128::new(77777);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // valid burn of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .burn_from(owner.to_string(), transfer)\n        .call(spender)\n        .unwrap();\n\n    // make sure money burnt\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {}\n        }\n    );\n\n    // cannot burn more than the allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .burn_from(owner.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // let us increase limit, but set the expiration to expire in the next block\n    let next_block_height = app.app.borrow().block_info().height + 1;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(\n            spender.to_string(),\n            Uint128::new(1000),\n            Some(Expiration::AtHeight(next_block_height)),\n        )\n        .call(owner)\n        .unwrap();\n\n    // move to next block\n    app.app.borrow_mut().update_block(next_block);\n\n    // we should now get the expiration error\n    let err = contract\n        .cw20_allowances_proxy()\n        .burn_from(owner.to_string(), Uint128::new(33443))\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Expired));\n}\n\n// Ignoring currently due to some issue with unsupported msg being sent in send_from\n#[test]\nfn send_from_respects_limits() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let owner2 = \"addr0003\";\n    let spender = \"addr0002\";\n    let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n    let start_amount = Uint128::new(999999);\n\n    let code_id = CodeId::store_code(\u0026app);\n    let receiver_code_id = ReceiverCodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let receiver_contract = receiver_code_id\n        .instantiate()\n        .with_label(\"cool-dex\")\n        .call(owner2)\n        .unwrap();\n\n    // provide an allowance\n    let allowance = Uint128::new(77777);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // valid send of part of the allowance\n    let transfer = Uint128::new(44444);\n    contract\n        .cw20_allowances_proxy()\n        .send_from(\n            owner.to_string(),\n            receiver_contract.contract_addr.to_string(),\n            transfer,\n            send_msg.clone(),\n        )\n        .call(spender)\n        .unwrap();\n\n    // make sure money burnt\n    let balance_resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(\n        balance_resp.balance,\n        start_amount.checked_sub(transfer).unwrap()\n    );\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {}\n        }\n    );\n\n    // cannot send more than the allowance\n    let err = contract\n        .cw20_allowances_proxy()\n        .send_from(\n            owner.to_string(),\n            receiver_contract.contract_addr.to_string(),\n            Uint128::new(33443),\n            send_msg.clone(),\n        )\n        .call(spender)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // let us increase limit, but set the expiration to expire in the next block\n    let next_block_height = app.app.borrow().block_info().height + 1;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(\n            spender.to_string(),\n            Uint128::new(1000),\n            Some(Expiration::AtHeight(next_block_height)),\n        )\n        .call(owner)\n        .unwrap();\n\n    // move to next block\n    app.app.borrow_mut().update_block(next_block);\n\n    // we should now get the expiration error\n    let err = contract\n        .cw20_allowances_proxy()\n        .send_from(\n            owner.to_string(),\n            receiver_contract.contract_addr.to_string(),\n            Uint128::new(33443),\n            send_msg,\n        )\n        .call(spender)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Expired));\n}\n\n#[test]\nfn no_past_expiration() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let start_amount = Uint128::new(999999);\n    let allowance = Uint128::new(7777);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // set allowance with height expiration at current block height\n    let block_height = app.app.borrow().block_info().height;\n    let expires = Expiration::AtHeight(block_height);\n\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap_err();\n\n    // ensure it is rejected\n    assert_eq!(ContractError::InvalidExpiration, err);\n\n    // set allowance with time expiration in the past\n    let block_time = app.app.borrow().block_info().time;\n    let expires = Expiration::AtTime(block_time.minus_seconds(1));\n\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap_err();\n\n    // ensure it is rejected\n    assert_eq!(ContractError::InvalidExpiration, err);\n\n    // set allowance with height expiration at next block height\n    let block_height = app.app.borrow().block_info().height + 1;\n    let expires = Expiration::AtHeight(block_height);\n\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n\n    // set allowance with time expiration in the future\n    let block_time = app.app.borrow().block_info().time;\n    let expires = Expiration::AtTime(block_time.plus_seconds(10));\n\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(\n        allowance_resp,\n        AllowanceResponse {\n            allowance: allowance + allowance, // we increased twice\n            expires\n        }\n    );\n\n    // decrease with height expiration at current block height\n    let block_height = app.app.borrow().block_info().height;\n    let expires = Expiration::AtHeight(block_height);\n\n    let err = contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap_err();\n\n    // ensure it is rejected\n    assert_eq!(ContractError::InvalidExpiration, err);\n\n    // decrease with height expiration at next block height\n    let block_height = app.app.borrow().block_info().height + 1;\n    let expires = Expiration::AtHeight(block_height);\n\n    contract\n        .cw20_allowances_proxy()\n        .decrease_allowance(spender.to_string(), allowance, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // ensure it looks good\n    let allowance_resp = contract\n        .cw20_allowances_proxy()\n        .allowance(owner.to_string(), spender.to_string())\n        .unwrap();\n\n    assert_eq!(allowance_resp, AllowanceResponse { allowance, expires });\n}\n\n#[test]\nfn query_allowances() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let spender2 = \"addr0003\";\n    let start_amount = Uint128::new(999999);\n    let allowance = Uint128::new(7777);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // check all allowances\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse { allowances: vec![] }\n    );\n\n    // increase spender allowances\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allowance, None)\n        .call(owner)\n        .unwrap();\n\n    // check all allowances\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender.to_string(),\n                allowance,\n                expires: Expiration::Never {}\n            }]\n        }\n    );\n\n    // check spender allowances\n    let all_spender_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_spender_allowances_resp,\n        AllSpenderAllowancesResponse {\n            allowances: vec![SpenderAllowanceInfo {\n                owner: owner.to_string(),\n                allowance,\n                expires: Expiration::Never {}\n            }]\n        }\n    );\n\n    // increase spender2 allowances\n    let increased_allowances = allowance + allowance;\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), increased_allowances, None)\n        .call(owner)\n        .unwrap();\n\n    // check all allowances\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse {\n            allowances: vec![\n                AllowanceInfo {\n                    spender: spender.to_string(),\n                    allowance,\n                    expires: Expiration::Never {}\n                },\n                AllowanceInfo {\n                    spender: spender2.to_string(),\n                    allowance: increased_allowances,\n                    expires: Expiration::Never {}\n                }\n            ]\n        }\n    );\n\n    // check all allowances with limit\n    let all_allowances_resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, Some(1))\n        .unwrap();\n\n    assert_eq!(\n        all_allowances_resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender.to_string(),\n                allowance,\n                expires: Expiration::Never {}\n            },]\n        }\n    );\n}\n\n#[test]\nfn query_all_allowances_works() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let spender = \"addr0002\";\n    let spender2 = \"addr0003\";\n    let start_amount = Uint128::new(12340000);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances, vec![]);\n\n    // set allowance with height expiration\n    let allow1 = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow1, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // set allowance with no expiration\n    let allow2 = Uint128::new(54321);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender2.to_string(), allow2, None)\n        .call(owner)\n        .unwrap();\n\n    // query list gets 2\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances.len(), 2);\n\n    // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, Some(1))\n        .unwrap();\n    assert_eq!(\n        resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender.to_string(),\n                allowance: allow1,\n                expires\n            }]\n        }\n    );\n\n    // next one is spender2\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), Some(spender.to_string()), Some(10000))\n        .unwrap();\n    assert_eq!(\n        resp,\n        AllAllowancesResponse {\n            allowances: vec![AllowanceInfo {\n                spender: spender2.to_string(),\n                allowance: allow2,\n                expires: Expiration::Never {}\n            }]\n        }\n    );\n}\n\n#[test]\nfn all_spender_allowances_on_two_contracts() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let owner2 = \"addr0003\";\n    let spender = \"addr0002\";\n    let start_amount = Uint128::new(12340000);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances, vec![]);\n\n    // set allowance with height expiration\n    let allow1 = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow1, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // set allowance with no expiration, from the other owner\n    let contract2 = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner2)\n        .unwrap();\n\n    let allow2 = Uint128::new(54321);\n    contract2\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow2, None)\n        .call(owner2)\n        .unwrap();\n\n    // query list on both contracts\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances.len(), 1);\n\n    let resp = contract2\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp.allowances.len(), 1);\n}\n\n#[test]\nfn query_all_accounts_works() {\n    let app = App::default();\n\n    // insert order and lexicographical order are different\n    let owner = \"owner\";\n    let acct2 = \"zebra\";\n    let acct3 = \"nice\";\n    let acct4 = \"aaaardvark\";\n    let start_amount = Uint128::new(12340000);\n    let expected_order = [\n        acct4.to_string(),\n        acct3.to_string(),\n        owner.to_string(),\n        acct2.to_string(),\n    ];\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount: start_amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // put money everywhere (to create balanaces)\n    contract\n        .transfer(acct2.to_string(), Uint128::new(222222))\n        .call(owner)\n        .unwrap();\n    contract\n        .transfer(acct3.to_string(), Uint128::new(333333))\n        .call(owner)\n        .unwrap();\n    contract\n        .transfer(acct4.to_string(), Uint128::new(444444))\n        .call(owner)\n        .unwrap();\n\n    // make sure we get the proper results\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(None, None)\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order);\n\n    // let's do pagination\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(None, Some(2))\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order[0..2].to_vec());\n\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(Some(resp.accounts[1].clone()), Some(1))\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order[2..3].to_vec());\n\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_accounts(Some(resp.accounts[0].clone()), Some(777))\n        .unwrap();\n    assert_eq!(resp.accounts, expected_order[3..].to_vec());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","base_tests.rs"],"content":"use cosmwasm_std::{Addr, Binary, StdError, Uint128};\nuse cw20_allowances::responses::{AllAllowancesResponse, SpenderAllowanceInfo};\nuse cw_utils::Expiration;\nuse sylvia::multitest::App;\n\nuse crate::allowances::test_utils::Cw20Allowances;\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::InstantiateMsgData;\nuse crate::error::ContractError;\nuse crate::multitest::receiver_contract::multitest_utils::CodeId as ReceiverCodeId;\nuse crate::responses::{BalanceResponse, Cw20Coin, TokenInfoResponse};\n\n#[test]\nfn basic() {\n    let app = App::default();\n\n    let amount = Uint128::from(11223344u128);\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.token_info().unwrap();\n\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            total_supply: amount,\n        }\n    );\n\n    let resp = contract.balance(owner.to_string()).unwrap();\n\n    assert_eq!(resp, BalanceResponse { balance: amount });\n}\n\n#[test]\nfn instantiate_multiple_accounts() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let amount1 = Uint128::from(11223344u128);\n    let addr1 = \"addr0001\";\n    let amount2 = Uint128::from(7890987u128);\n    let addr2 = \"addr0002\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    // Fails with duplicate addresses\n    let err = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 6,\n            initial_balances: vec![\n                Cw20Coin {\n                    address: addr1.to_owned(),\n                    amount: amount1,\n                },\n                Cw20Coin {\n                    address: addr1.to_owned(),\n                    amount: amount2,\n                },\n            ],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::DuplicateInitialBalanceAddresses);\n\n    // Works with unique addresses\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Bash Token\".to_string(),\n            symbol: \"BASH\".to_string(),\n            decimals: 6,\n            initial_balances: vec![\n                Cw20Coin {\n                    address: addr1.into(),\n                    amount: amount1,\n                },\n                Cw20Coin {\n                    address: addr2.into(),\n                    amount: amount2,\n                },\n            ],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.token_info().unwrap();\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Bash Token\".to_string(),\n            symbol: \"BASH\".to_string(),\n            decimals: 6,\n            total_supply: amount1 + amount2,\n        }\n    );\n    let resp = contract.balance(addr1.to_string()).unwrap();\n    assert_eq!(resp.balance, amount1);\n    let resp = contract.balance(addr2.to_string()).unwrap();\n    assert_eq!(resp.balance, amount2);\n}\n\n#[test]\nfn queries_work() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let amount = Uint128::from(12340000u128);\n    let addr = Addr::unchecked(\"addr0001\");\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.token_info().unwrap();\n\n    // Check meta query\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            total_supply: amount\n        }\n    );\n\n    // Check owner balance\n    let resp = contract.balance(owner.to_string()).unwrap();\n\n    assert_eq!(resp.balance, amount);\n\n    // Check addr balance (Empty)\n    let resp = contract.balance(addr.to_string()).unwrap();\n\n    assert_eq!(resp.balance, Uint128::zero());\n}\n\n#[test]\nfn transfer() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let addr = \"addr0001\";\n    let amount = Uint128::from(12340000u128);\n    let transfer = Uint128::from(76543u128);\n    let too_much = Uint128::from(12340321u128);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // cannot transfer nothing\n    let err = contract\n        .transfer(addr.to_string(), Uint128::zero())\n        .call(owner)\n        .unwrap_err();\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // cannot send more than we have\n    let err = contract\n        .transfer(addr.to_string(), too_much)\n        .call(owner)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // cannot send from empty account\n    let err = contract\n        .transfer(owner.to_string(), transfer)\n        .call(addr)\n        .unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // valid transfer\n    contract\n        .transfer(addr.to_string(), transfer)\n        .call(owner)\n        .unwrap();\n\n    // Check balance\n    let remainder = amount.checked_sub(transfer).unwrap();\n\n    let resp = contract.balance(addr.to_string()).unwrap();\n    assert_eq!(resp.balance, transfer);\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, remainder);\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n}\n\n#[test]\nfn burn() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let addr = \"addr0001\";\n    let amount = Uint128::from(12340000u128);\n    let burn = Uint128::from(76543u128);\n    let too_much = Uint128::from(12340321u128);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // cannot burn nothing\n    let err = contract.burn(Uint128::zero()).call(owner).unwrap_err();\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n\n    // cannot burn more than we have\n    let err = contract.burn(too_much).call(owner).unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n\n    // cannot send from empty account\n    let err = contract.burn(burn).call(addr).unwrap_err();\n\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // valid burn reduces total supply\n    contract.burn(burn).call(owner).unwrap();\n\n    // check balance\n    let remainder = amount.checked_sub(burn).unwrap();\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, remainder);\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, remainder);\n}\n\n#[test]\nfn send() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let amount = Uint128::from(12340000u128);\n    let too_much = Uint128::from(12340321u128);\n    let transfer = Uint128::from(76543u128);\n    let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    // Receiver contract\n    let receiver_code_id = ReceiverCodeId::store_code(\u0026app);\n    let receiver_contract = receiver_code_id\n        .instantiate()\n        .with_label(\"cool-dex\")\n        .call(owner)\n        .unwrap();\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .send(\n            receiver_contract.contract_addr.to_string(),\n            Uint128::zero(),\n            send_msg.clone(),\n        )\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // cannot send more than we have\n    let err = contract\n        .send(\n            receiver_contract.contract_addr.to_string(),\n            too_much,\n            send_msg.clone(),\n        )\n        .call(owner)\n        .unwrap_err();\n    assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n    // valid transfer\n    contract\n        .send(\n            receiver_contract.contract_addr.to_string(),\n            transfer,\n            send_msg,\n        )\n        .call(owner)\n        .unwrap();\n\n    // ensure balance is properly transferred\n    let remainder = amount.checked_sub(transfer).unwrap();\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, remainder);\n    let resp = contract\n        .balance(receiver_contract.contract_addr.to_string())\n        .unwrap();\n    assert_eq!(resp.balance, transfer);\n    let resp = contract.token_info().unwrap();\n    assert_eq!(resp.total_supply, amount);\n}\n\n#[test]\nfn migrate() {\n    let app = App::default();\n\n    let owner = \"addr0000\";\n    let spender = \"addr0001\";\n    let code_id = CodeId::store_code(\u0026app);\n    let amount = Uint128::new(100);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Token\".to_string(),\n            symbol: \"TOKEN\".to_string(),\n            decimals: 6,\n            initial_balances: vec![Cw20Coin {\n                address: owner.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .with_admin(Some(owner))\n        .call(owner)\n        .unwrap();\n\n    // no allowance to start\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_allowances(owner.to_string(), None, None)\n        .unwrap();\n    assert_eq!(resp, AllAllowancesResponse::default());\n\n    // Set allowance\n    let allow1 = Uint128::new(7777);\n    let expires = Expiration::AtHeight(123_456);\n    contract\n        .cw20_allowances_proxy()\n        .increase_allowance(spender.to_string(), allow1, Some(expires))\n        .call(owner)\n        .unwrap();\n\n    // Now migrate\n    contract.migrate().call(owner, code_id.code_id()).unwrap();\n\n    // Smoke check that the contract still works.\n    let resp = contract.balance(owner.to_string()).unwrap();\n    assert_eq!(resp.balance, Uint128::new(100));\n\n    // Confirm that the allowance per spender is there\n    let resp = contract\n        .cw20_allowances_proxy()\n        .all_spender_allowances(spender.to_string(), None, None)\n        .unwrap();\n    assert_eq!(\n        resp.allowances,\n        \u0026[SpenderAllowanceInfo {\n            owner: owner.to_string(),\n            allowance: allow1,\n            expires\n        }]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","marketing_tests.rs"],"content":"use cosmwasm_std::{Addr, StdError};\nuse cw20_marketing::responses::{DownloadLogoResponse, LogoInfo, MarketingInfoResponse};\nuse cw20_marketing::{EmbeddedLogo, Logo};\nuse sylvia::multitest::App;\n\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::{InstantiateMarketingInfo, InstantiateMsgData};\nuse crate::error::ContractError;\nuse crate::marketing::test_utils::Cw20Marketing;\n\nconst PNG_HEADER: [u8; 8] = [0x89, b'P', b'N', b'G', 0x0d, 0x0a, 0x1a, 0x0a];\n\n#[test]\nfn update_unauthorised() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(\"marketing\".to_owned()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .update_marketing(\n            Some(\"New project\".to_owned()),\n            Some(\"Better description\".to_owned()),\n            Some(\"creator\".to_owned()),\n        )\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::Unauthorized);\n\n    // Ensure marketing didn't change\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(\"marketing\")),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_project() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(Some(\"New project\".to_owned()), None, None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"New project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn clear_project() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(Some(\"\".to_owned()), None, None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: None,\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_description() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, Some(\"Better description\".to_owned()), None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Better description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn clear_description() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, Some(\"\".to_owned()), None)\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: None,\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_marketing() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, None, Some(\"marketing\".to_owned()))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(\"marketing\")),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_marketing_invalid() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, None, Some(\"m\".to_owned()))\n        .call(owner)\n        .unwrap_err();\n\n    assert!(\n        matches!(err, ContractError::Std(_)),\n        \"Expected Std error, received: {}\",\n        err\n    );\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn clear_marketing() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .update_marketing(None, None, Some(\"\".to_owned()))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: None,\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_url() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Url(\"new_url\".to_owned()))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"new_url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_png() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Png(PNG_HEADER.into())))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Embedded),\n        }\n    );\n\n    let resp = contract.cw20_marketing_proxy().download_logo().unwrap();\n    assert_eq!(\n        resp,\n        DownloadLogoResponse {\n            mime_type: \"image/png\".to_owned(),\n            data: PNG_HEADER.into(),\n        }\n    );\n}\n\n#[test]\nfn update_logo_svg() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = \"\u003c?xml version=\\\"1.0\\\"?\u003e\u003csvg\u003e\u003c/svg\u003e\".as_bytes();\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Svg(img.into())))\n        .call(owner)\n        .unwrap();\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Embedded),\n        }\n    );\n\n    let resp = contract.cw20_marketing_proxy().download_logo().unwrap();\n    assert_eq!(\n        resp,\n        DownloadLogoResponse {\n            mime_type: \"image/svg+xml\".to_owned(),\n            data: img.into(),\n        }\n    );\n}\n\n#[test]\nfn update_logo_png_oversized() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = [\u0026PNG_HEADER[..], \u0026[1; 6000][..]].concat();\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Png(img.into())))\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::LogoTooBig);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_svg_oversized() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = [\n        \"\u003c?xml version=\\\"1.0\\\"?\u003e\u003csvg\u003e\",\n        std::str::from_utf8(\u0026[b'x'; 6000]).unwrap(),\n        \"\u003c/svg\u003e\",\n    ]\n    .concat()\n    .into_bytes();\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Svg(img.into())))\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::LogoTooBig);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_png_invalid() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = \u0026[1];\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Png(img.into())))\n        .call(owner)\n        .unwrap_err();\n    assert_eq!(err, ContractError::InvalidPngHeader);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n\n#[test]\nfn update_logo_svg_invalid() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let img = \u0026[1];\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![],\n            mint: None,\n            marketing: Some(InstantiateMarketingInfo {\n                project: Some(\"Project\".to_owned()),\n                description: Some(\"Description\".to_owned()),\n                marketing: Some(owner.to_string()),\n                logo: Some(Logo::Url(\"url\".to_owned())),\n            }),\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_marketing_proxy()\n        .upload_logo(Logo::Embedded(EmbeddedLogo::Svg(img.into())))\n        .call(owner)\n        .unwrap_err();\n    assert_eq!(err, ContractError::InvalidXmlPreamble);\n\n    let resp = contract.cw20_marketing_proxy().marketing_info().unwrap();\n    assert_eq!(\n        resp,\n        MarketingInfoResponse {\n            project: Some(\"Project\".to_owned()),\n            description: Some(\"Description\".to_owned()),\n            marketing: Some(Addr::unchecked(owner)),\n            logo: Some(LogoInfo::Url(\"url\".to_owned())),\n        }\n    );\n\n    // Due to QuerierWrapper impl it will return generic error instead of forwarding ContractError\n    let err = contract.cw20_marketing_proxy().download_logo().unwrap_err();\n\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Querier contract error: logo not found\").into()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","minting_tests.rs"],"content":"use cosmwasm_std::{StdError, Uint128};\nuse cw20_minting::responses::MinterResponse;\nuse sylvia::multitest::App;\n\nuse crate::contract::multitest_utils::CodeId;\nuse crate::contract::InstantiateMsgData;\nuse crate::error::ContractError;\nuse crate::minting::test_utils::Cw20Minting;\nuse crate::responses::{Cw20Coin, TokenInfoResponse};\n\n#[test]\nfn mintable() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let amount = Uint128::new(11223344);\n    let limit = Uint128::new(511223344);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // read token info\n    let resp = contract.token_info().unwrap();\n\n    assert_eq!(\n        resp,\n        TokenInfoResponse {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            total_supply: amount,\n        }\n    );\n\n    // get owner balance\n    let resp = contract.balance(owner.to_string()).unwrap();\n\n    assert_eq!(resp.balance, Uint128::new(11223344));\n\n    // get minter balance\n    let resp = contract.balance(minter.to_string()).unwrap();\n\n    assert_eq!(resp.balance, Uint128::new(0));\n\n    // get minter\n    let resp = contract.cw20_minting_proxy().minter().unwrap();\n\n    assert_eq!(\n        resp,\n        Some(MinterResponse {\n            minter: minter.to_string(),\n            cap: Some(limit),\n        })\n    );\n}\n\n#[test]\nfn mintable_over_cap() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let amount = Uint128::new(11223344);\n    let limit = Uint128::new(11223300);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let err = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap_err();\n\n    assert_eq!(\n        err,\n        StdError::generic_err(\"Initial supply greater than cap\").into()\n    );\n}\n\n#[test]\nfn can_mint_by_minter() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let winner = \"lucky\";\n    let prize = Uint128::new(222_222_222);\n    let limit = Uint128::new(511223344);\n    let amount = Uint128::new(11223344);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // minter can mint coins to some winner\n    contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), prize)\n        .call(minter)\n        .unwrap();\n\n    // but cannot mint nothing\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::zero())\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // but if it exceeds cap (even over multiple rounds), it fails\n    // cap is enforced\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::new(333_222_222))\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotExceedCap);\n}\n\n#[test]\nfn others_cannot_mint() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let winner = \"lucky\";\n    let prize = Uint128::new(222_222_222);\n    let limit = Uint128::new(511223344);\n    let amount = Uint128::new(1234);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: Some(limit),\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // minter can mint coins to some winner\n    contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), prize)\n        .call(minter)\n        .unwrap();\n\n    // but cannot mint nothing\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::zero())\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::InvalidZeroAmount);\n\n    // but if it exceeds cap (even over multiple rounds), it fails\n    // cap is enforced\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), Uint128::new(333_222_222))\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::CannotExceedCap);\n}\n\n#[test]\nfn minter_can_update_minter_but_not_cap() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let new_minter = \"new_minter\";\n    let amount = Uint128::new(1234);\n    let cap = Some(Uint128::from(3000000u128));\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap,\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // minter can mint coins to some winner\n    contract\n        .cw20_minting_proxy()\n        .update_minter(Some(new_minter.to_string()))\n        .call(minter)\n        .unwrap();\n\n    let resp = contract.cw20_minting_proxy().minter().unwrap().unwrap();\n    assert_eq!(\n        resp,\n        MinterResponse {\n            minter: new_minter.to_string(),\n            cap\n        }\n    );\n}\n\n#[test]\nfn others_cannot_update_minter() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let new_minter = \"new_minter\";\n    let amount = Uint128::new(1234);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    let err = contract\n        .cw20_minting_proxy()\n        .update_minter(Some(new_minter.to_string()))\n        .call(new_minter)\n        .unwrap_err();\n    assert_eq!(err, ContractError::Unauthorized);\n}\n\n#[test]\nfn unset_minter() {\n    let app = App::default();\n\n    let owner = \"addr0001\";\n    let minter = \"addr0002\";\n    let winner = \"lucky\";\n    let amount = Uint128::new(1234);\n\n    let code_id = CodeId::store_code(\u0026app);\n\n    let contract = code_id\n        .instantiate(InstantiateMsgData {\n            name: \"Cash Token\".to_string(),\n            symbol: \"CASH\".to_string(),\n            decimals: 9,\n            initial_balances: vec![Cw20Coin {\n                address: owner.to_string(),\n                amount,\n            }],\n            mint: Some(MinterResponse {\n                minter: minter.to_string(),\n                cap: None,\n            }),\n            marketing: None,\n        })\n        .with_label(\"Cw20 contract\")\n        .call(owner)\n        .unwrap();\n\n    // Unset minter\n    contract\n        .cw20_minting_proxy()\n        .update_minter(None)\n        .call(minter)\n        .unwrap();\n\n    let resp = contract.cw20_minting_proxy().minter().unwrap();\n    assert_eq!(resp, None);\n\n    // Old minter can no longer mint\n    let err = contract\n        .cw20_minting_proxy()\n        .mint(winner.to_string(), amount)\n        .call(minter)\n        .unwrap_err();\n\n    assert_eq!(err, ContractError::Unauthorized);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","receiver.rs"],"content":"use cosmwasm_std::{Binary, Response, StdError, Uint128};\nuse sylvia::types::ExecCtx;\nuse sylvia::{contract, interface, schemars};\n\nuse super::receiver_contract::ReceiverContract;\n\n#[interface]\npub trait Receiver {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn receive(\n        \u0026self,\n        ctx: ExecCtx,\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n}\n\n#[contract]\nimpl Receiver for ReceiverContract {\n    type Error = StdError;\n\n    #[msg(exec)]\n    fn receive(\n        \u0026self,\n        _ctx: ExecCtx,\n        _sender: String,\n        _amount: cosmwasm_std::Uint128,\n        _msg: cosmwasm_std::Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        Ok(Response::default())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest","receiver_contract.rs"],"content":"use cosmwasm_std::{Response, StdResult};\nuse sylvia::{contract, schemars, types::InstantiateCtx};\n\nuse super::receiver;\npub struct ReceiverContract {}\n\n#[contract]\n#[messages(receiver as Receiver)]\nimpl ReceiverContract {\n    pub const fn new() -\u003e Self {\n        Self {}\n    }\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","multitest.rs"],"content":"mod allowances_tests;\nmod base_tests;\nmod marketing_tests;\nmod minting_tests;\nmod receiver;\nmod receiver_contract;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{to_binary, Addr, Binary, CosmosMsg, StdResult, Uint128, WasmMsg};\nuse std::fmt;\n\n/// Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg\n#[cw_serde]\npub struct Cw20ReceiveMsg {\n    pub sender: String,\n    pub amount: Uint128,\n    pub msg: Binary,\n}\n\nimpl Cw20ReceiveMsg {\n    /// serializes the message\n    pub fn into_binary(self) -\u003e StdResult\u003cBinary\u003e {\n        let msg = ReceiverExecuteMsg::Receive(self);\n        to_binary(\u0026msg)\n    }\n\n    /// creates a cosmos_msg sending this struct to the named contract\n    pub fn into_cosmos_msg\u003cT: Into\u003cString\u003e\u003e(self, contract_addr: T) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let msg = self.into_binary()?;\n        let execute = WasmMsg::Execute {\n            contract_addr: contract_addr.into(),\n            msg,\n            funds: vec![],\n        };\n        Ok(execute.into())\n    }\n}\n\n// This is just a helper to properly serialize the above message\n#[cw_serde]\nenum ReceiverExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n}\n\n#[cw_serde]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\nimpl Cw20Coin {\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.amount == Uint128::zero()\n    }\n}\n\nimpl fmt::Display for Cw20Coin {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"address: {}, amount: {}\", self.address, self.amount)\n    }\n}\n\n#[cw_serde]\npub struct Cw20CoinVerified {\n    pub address: Addr,\n    pub amount: Uint128,\n}\n\nimpl Cw20CoinVerified {\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.amount == Uint128::zero()\n    }\n}\n\nimpl fmt::Display for Cw20CoinVerified {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"address: {}, amount: {}\", self.address, self.amount)\n    }\n}\n\n#[cw_serde]\npub struct BalanceResponse {\n    pub balance: Uint128,\n}\n\n#[cw_serde]\npub struct TokenInfoResponse {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub total_supply: Uint128,\n}\n","traces":[{"line":15,"address":[1071424,1071589],"length":1,"stats":{"Line":1},"fn_name":"into_binary"},{"line":16,"address":[2198319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1071525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1327233,1326336,1327321],"length":1,"stats":{"Line":1},"fn_name":"into_cosmos_msg\u003calloc::string::String\u003e"},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1808364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[1071616],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":46,"address":[1071630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1071680],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":52,"address":[1071710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1071840],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":64,"address":[1071854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1071904],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":70,"address":[1071934],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":16},{"path":["/","home","janw","workspace","confio","sylvia","contracts","cw20-base","src","validation.rs"],"content":"use cosmwasm_std::{StdError, StdResult};\nuse cw20_marketing::{EmbeddedLogo, Logo};\n\nuse crate::error::ContractError;\nuse crate::responses::Cw20Coin;\n\nconst LOGO_SIZE_CAP: usize = 5 * 1024;\n\npub fn validate_msg(name: \u0026str, symbol: \u0026str, decimals: u8) -\u003e StdResult\u003c()\u003e {\n    // Check name, symbol, decimals\n    if !has_valid_name(name) {\n        return Err(StdError::generic_err(\n            \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n        ));\n    }\n    if !has_valid_symbol(symbol) {\n        return Err(StdError::generic_err(\n            \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n        ));\n    }\n    if decimals \u003e 18 {\n        return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n    }\n    Ok(())\n}\n\npub fn validate_accounts(accounts: \u0026[Cw20Coin]) -\u003e Result\u003c(), ContractError\u003e {\n    let mut addresses = accounts.iter().map(|c| \u0026c.address).collect::\u003cVec\u003c_\u003e\u003e();\n    addresses.sort();\n    addresses.dedup();\n\n    if addresses.len() != accounts.len() {\n        Err(ContractError::DuplicateInitialBalanceAddresses)\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks if passed logo is correct, and if not, returns an error\npub fn verify_logo(logo: \u0026Logo) -\u003e Result\u003c(), ContractError\u003e {\n    match logo {\n        Logo::Embedded(EmbeddedLogo::Svg(logo)) =\u003e verify_xml_logo(logo),\n        Logo::Embedded(EmbeddedLogo::Png(logo)) =\u003e verify_png_logo(logo),\n        Logo::Url(_) =\u003e Ok(()), // Any reasonable url validation would be regex based, probably not worth it\n    }\n}\n\nfn has_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn has_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n/// Validates XML logo\nfn verify_xml_logo(logo: \u0026[u8]) -\u003e Result\u003c(), ContractError\u003e {\n    verify_xml_preamble(logo)?;\n\n    if logo.len() \u003e LOGO_SIZE_CAP {\n        Err(ContractError::LogoTooBig)\n    } else {\n        Ok(())\n    }\n}\n\n/// Validates png logo\nfn verify_png_logo(logo: \u0026[u8]) -\u003e Result\u003c(), ContractError\u003e {\n    // PNG header format:\n    // 0x89 - magic byte, out of ASCII table to fail on 7-bit systems\n    // \"PNG\" ascii representation\n    // [0x0d, 0x0a] - dos style line ending\n    // 0x1a - dos control character, stop displaying rest of the file\n    // 0x0a - unix style line ending\n    const HEADER: [u8; 8] = [0x89, b'P', b'N', b'G', 0x0d, 0x0a, 0x1a, 0x0a];\n    if logo.len() \u003e LOGO_SIZE_CAP {\n        Err(ContractError::LogoTooBig)\n    } else if !logo.starts_with(\u0026HEADER) {\n        Err(ContractError::InvalidPngHeader)\n    } else {\n        Ok(())\n    }\n}\n\n/// Checks if data starts with XML preamble\nfn verify_xml_preamble(data: \u0026[u8]) -\u003e Result\u003c(), ContractError\u003e {\n    // The easiest way to perform this check would be just match on regex, however regex\n    // compilation is heavy and probably not worth it.\n\n    let preamble = data\n        .split_inclusive(|c| *c == b'\u003e')\n        .next()\n        .ok_or(ContractError::InvalidXmlPreamble)?;\n\n    const PREFIX: \u0026[u8] = b\"\u003c?xml \";\n    const POSTFIX: \u0026[u8] = b\"?\u003e\";\n\n    if !(preamble.starts_with(PREFIX) \u0026\u0026 preamble.ends_with(POSTFIX)) {\n        Err(ContractError::InvalidXmlPreamble)\n    } else {\n        Ok(())\n    }\n\n    // Additionally attributes format could be validated as they are well defined, as well as\n    // comments presence inside of preable, but it is probably not worth it.\n}\n","traces":[{"line":9,"address":[1389888],"length":1,"stats":{"Line":11},"fn_name":"validate_msg"},{"line":11,"address":[1389987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[1390021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[1390008],"length":1,"stats":{"Line":11},"fn_name":null},{"line":17,"address":[1390087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[1390081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1390151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[1390143],"length":1,"stats":{"Line":11},"fn_name":null},{"line":27,"address":[1390442,1390208],"length":1,"stats":{"Line":1},"fn_name":"validate_accounts"},{"line":28,"address":[1390267],"length":1,"stats":{"Line":23},"fn_name":null},{"line":29,"address":[1390367,1390306],"length":1,"stats":{"Line":12},"fn_name":null},{"line":30,"address":[1390379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1390479,1390391],"length":1,"stats":{"Line":22},"fn_name":null},{"line":33,"address":[1390486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1390473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1390544],"length":1,"stats":{"Line":4},"fn_name":"verify_logo"},{"line":41,"address":[1390607,1390568],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[1390618],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[1390653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[1390594],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[1390704],"length":1,"stats":{"Line":11},"fn_name":"has_valid_name"},{"line":49,"address":[1390752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[1390762],"length":1,"stats":{"Line":11},"fn_name":null},{"line":51,"address":[1390806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1390799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[1390832],"length":1,"stats":{"Line":1},"fn_name":"has_valid_symbol"},{"line":57,"address":[1390895],"length":1,"stats":{"Line":11},"fn_name":null},{"line":58,"address":[1390905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1390983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1391054,1391005,1390953],"length":1,"stats":{"Line":23},"fn_name":null},{"line":62,"address":[1391068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[1391189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1391047],"length":1,"stats":{"Line":11},"fn_name":null},{"line":70,"address":[1391200],"length":1,"stats":{"Line":3},"fn_name":"verify_xml_logo"},{"line":71,"address":[1391238,1391300],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[1391434,1391290,1391398],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[1391405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[1391392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1391440],"length":1,"stats":{"Line":3},"fn_name":"verify_png_logo"},{"line":89,"address":[1391483],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[1391533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1391580,1391610,1391502],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[1391587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1391574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1391616],"length":1,"stats":{"Line":3},"fn_name":"verify_xml_preamble"},{"line":103,"address":[1391649,1391689,1391874],"length":1,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[1244573,1244560],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":106,"address":[1391678,1391820],"length":1,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[1392014,1391907,1391978,1391796],"length":1,"stats":{"Line":7},"fn_name":null},{"line":112,"address":[1391985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[1391972],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":45,"coverable":51},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw1","src","lib.rs"],"content":"use cosmwasm_std::{CosmosMsg, Response, StdError, StdResult};\nuse serde::{Deserialize, Serialize};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[derive(\n    Serialize, Deserialize, Clone, PartialEq, Eq, sylvia::schemars::JsonSchema, Debug, Default,\n)]\npub struct CanExecuteResp {\n    pub can_execute: bool,\n}\n\n#[interface]\npub trait Cw1 {\n    type Error: From\u003cStdError\u003e;\n\n    /// Execute requests the contract to re-dispatch all these messages with the\n    /// contract's address as sender. Every implementation has it's own logic to\n    /// determine in\n    #[msg(exec)]\n    fn execute(\u0026self, ctx: ExecCtx, msgs: Vec\u003cCosmosMsg\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Checks permissions of the caller on this proxy.\n    /// If CanExecute returns true then a call to `Execute` with the same message,\n    /// from the given sender, before any further state changes, should also succeed.\n    #[msg(query)]\n    fn can_execute(\n        \u0026self,\n        ctx: QueryCtx,\n        sender: String,\n        msg: CosmosMsg,\n    ) -\u003e StdResult\u003cCanExecuteResp\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use cosmwasm_std::{coins, from_binary, from_slice, to_binary, BankMsg};\n\n    use super::*;\n\n    #[test]\n    fn execute() {\n        let original = ExecMsg::Execute {\n            msgs: vec![BankMsg::Send {\n                to_address: \"receiver\".to_owned(),\n                amount: coins(10, \"atom\"),\n            }\n            .into()],\n        };\n\n        let serialized = to_binary(\u0026original).unwrap();\n        let deserialized = from_binary(\u0026serialized).unwrap();\n\n        assert_eq!(original, deserialized);\n    }\n\n    #[test]\n    fn execute_from_slice() {\n        let deserialized = from_slice(br#\"{\"execute\": { \"msgs\": [] }}\"#).unwrap();\n        assert_eq!(ExecMsg::Execute { msgs: vec![] }, deserialized);\n    }\n\n    #[test]\n    fn query() {\n        let original = QueryMsg::CanExecute {\n            sender: \"sender\".to_owned(),\n            msg: BankMsg::Send {\n                to_address: \"receiver\".to_owned(),\n                amount: coins(10, \"atom\"),\n            }\n            .into(),\n        };\n\n        let serialized = to_binary(\u0026original).unwrap();\n        let deserialized = from_binary(\u0026serialized).unwrap();\n\n        assert_eq!(original, deserialized);\n    }\n\n    #[test]\n    fn query_from_slice() {\n        let deserialized = from_slice(\n            br#\"{\"can_execute\": {\n                \"sender\": \"address\",\n                \"msg\": {\n                    \"bank\": {\n                        \"send\": {\n                            \"to_address\": \"receiver\",\n                            \"amount\": [\n                                {\n                                    \"amount\": \"10\",\n                                    \"denom\": \"atom\"\n                                }\n                            ]\n                        }\n                    }\n                }\n            }}\"#,\n        )\n        .unwrap();\n        assert_eq!(\n            QueryMsg::CanExecute {\n                sender: \"address\".to_owned(),\n                msg: BankMsg::Send {\n                    to_address: \"receiver\".to_owned(),\n                    amount: coins(10, \"atom\"),\n                }\n                .into()\n            },\n            deserialized\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-allowances","src","lib.rs"],"content":"pub mod responses;\n\nuse cosmwasm_std::{Binary, Response, StdError, StdResult, Uint128};\nuse cw_utils::Expiration;\nuse responses::{\n    AllAccountsResponse, AllAllowancesResponse, AllSpenderAllowancesResponse, AllowanceResponse,\n};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[interface]\npub trait Cw20Allowances {\n    type Error: From\u003cStdError\u003e;\n\n    /// Allows spender to access an additional amount tokens from the owner's (env.sender) account.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn increase_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Lowers the spender's access of tokens from the owner's (env.sender) account by amount.\n    /// If expires is Some(), overwrites current allowance expiration with this one.\n    #[msg(exec)]\n    fn decrease_allowance(\n        \u0026self,\n        ctx: ExecCtx,\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Transfers amount tokens from owner -\u003e recipient\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn transfer_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Sends amount tokens from owner -\u003e contract\n    /// if `env.sender` has sufficient pre-approval.\n    #[msg(exec)]\n    fn send_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Destroys amount of tokens forever\n    #[msg(exec)]\n    fn burn_from(\n        \u0026self,\n        ctx: ExecCtx,\n        owner: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Returns how much spender can use from owner account, 0 if unset.\n    #[msg(query)]\n    fn allowance(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        spender: String,\n    ) -\u003e StdResult\u003cAllowanceResponse\u003e;\n\n    /// Returns all allowances this owner has approved. Supports pagination.\n    #[msg(query)]\n    fn all_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAllowancesResponse\u003e;\n\n    /// Returns all allowances this spender has been granted. Supports pagination.\n    #[msg(query)]\n    fn all_spender_allowances(\n        \u0026self,\n        ctx: QueryCtx,\n        spender: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllSpenderAllowancesResponse\u003e;\n\n    /// Returns all accounts that have balances. Supports pagination.\n    #[msg(query)]\n    fn all_accounts(\n        \u0026self,\n        ctx: QueryCtx,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cAllAccountsResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-allowances","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::Uint128;\nuse cw_utils::Expiration;\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct AllowanceResponse {\n    pub allowance: Uint128,\n    pub expires: Expiration,\n}\n\n#[cw_serde]\npub struct AllowanceInfo {\n    pub spender: String,\n    pub allowance: Uint128,\n    pub expires: Expiration,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct AllAllowancesResponse {\n    pub allowances: Vec\u003cAllowanceInfo\u003e,\n}\n\n#[cw_serde]\npub struct SpenderAllowanceInfo {\n    pub owner: String,\n    pub allowance: Uint128,\n    pub expires: Expiration,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct AllSpenderAllowancesResponse {\n    pub allowances: Vec\u003cSpenderAllowanceInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, schemars::JsonSchema, Debug, Default)]\npub struct AllAccountsResponse {\n    pub accounts: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-marketing","src","lib.rs"],"content":"pub mod responses;\n\nuse cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Binary, Response, StdError, StdResult};\nuse responses::{DownloadLogoResponse, MarketingInfoResponse};\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n/// This is used for uploading logo data, or setting it in InstantiateData\n#[cw_serde]\npub enum Logo {\n    /// A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.\n    Url(String),\n    /// Logo content stored on the blockchain. Enforce maximum size of 5KB on all variants\n    Embedded(EmbeddedLogo),\n}\n\n/// This is used to store the logo on the blockchain in an accepted format.\n/// Enforce maximum size of 5KB on all variants.\n#[cw_serde]\npub enum EmbeddedLogo {\n    /// Store the Logo as an SVG file. The content must conform to the spec\n    /// at https://en.wikipedia.org/wiki/Scalable_Vector_Graphics\n    /// (The contract should do some light-weight sanity-check validation)\n    Svg(Binary),\n    /// Store the Logo as a PNG file. This will likely only support up to 64x64 or so\n    /// within the 5KB limit.\n    Png(Binary),\n}\n\n#[interface]\npub trait Cw20Marketing {\n    type Error: From\u003cStdError\u003e;\n\n    /// If authorized, updates marketing metadata.\n    /// Setting None/null for any of these will leave it unchanged.\n    /// Setting Some(\"\") will clear this field on the contract storage\n    /// `project` - A URL pointing to the project behind this token.\n    /// `description` - A longer description of the token and it's utility. Designed for tooltips or such\n    /// `marketing` - The address (if any) who can update this data structure\n    #[msg(exec)]\n    fn update_marketing(\n        \u0026self,\n        ctx: ExecCtx,\n        project: Option\u003cString\u003e,\n        description: Option\u003cString\u003e,\n        marketing: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// If set as the \"marketing\" role on the contract, upload a new URL, SVG, or PNG for the token\n    #[msg(exec)]\n    fn upload_logo(\u0026self, ctx: ExecCtx, logo: Logo) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    #[msg(query)]\n    fn marketing_info(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cMarketingInfoResponse\u003e;\n\n    /// Downloads the embedded logo data (if stored on chain). Errors if no logo data is stored for this\n    /// contract.\n    #[msg(query)]\n    fn download_logo(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cDownloadLogoResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-marketing","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Binary};\nuse serde::{Deserialize, Serialize};\nuse sylvia::schemars;\n\n/// This is used to display logo info, provide a link or inform there is one\n/// that can be downloaded from the blockchain itself\n#[cw_serde]\npub enum LogoInfo {\n    /// A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.\n    Url(String),\n    /// There is an embedded logo on the chain, make another call to download it.\n    Embedded,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, schemars::JsonSchema, Debug, Default)]\npub struct MarketingInfoResponse {\n    /// A URL pointing to the project behind this token.\n    pub project: Option\u003cString\u003e,\n    /// A longer description of the token and it's utility. Designed for tooltips or such\n    pub description: Option\u003cString\u003e,\n    /// A link to the logo, or a comment there is an on-chain logo stored\n    pub logo: Option\u003cLogoInfo\u003e,\n    /// The address (if any) who can update this data structure\n    pub marketing: Option\u003cAddr\u003e,\n}\n\n/// When we download an embedded logo, we get this response type.\n/// We expect a SPA to be able to accept this info and display it.\n#[cw_serde]\npub struct DownloadLogoResponse {\n    pub mime_type: String,\n    pub data: Binary,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-minting","src","lib.rs"],"content":"pub mod responses;\n\nuse cosmwasm_std::{Response, StdError, StdResult, Uint128};\nuse responses::MinterResponse;\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[interface]\npub trait Cw20Minting {\n    type Error: From\u003cStdError\u003e;\n\n    /// If authorized, creates amount new tokens and adds to the recipient balance.\n    #[msg(exec)]\n    fn mint(\n        \u0026self,\n        ctx: ExecCtx,\n        recipient: String,\n        amount: Uint128,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// The current minter may set a new minter.\n    /// Setting the minter to None will remove the token's minter forever.\n    #[msg(exec)]\n    fn update_minter(\n        \u0026self,\n        ctx: ExecCtx,\n        new_minter: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    #[msg(query)]\n    fn minter(\u0026self, ctx: QueryCtx) -\u003e StdResult\u003cOption\u003cMinterResponse\u003e\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw20-minting","src","responses.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::Uint128;\n\n#[cw_serde]\npub struct MinterResponse {\n    pub minter: String,\n    /// cap is a hard cap on total supply that can be achieved by minting.\n    /// Note that this refers to total_supply.\n    /// If None, there is unlimited cap.\n    pub cap: Option\u003cUint128\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","interfaces","cw4","src","lib.rs"],"content":"use cosmwasm_std::{Response, StdError};\n\nuse sylvia::types::{ExecCtx, QueryCtx};\nuse sylvia::{interface, schemars};\n\n#[interface]\npub trait Cw4 {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn update_admin(\u0026self, ctx: ExecCtx, admin: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn update_members(\u0026self, ctx: ExecCtx, members: Vec\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn add_hook(\u0026self, ctx: ExecCtx, hook: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn remove_hook(\u0026self, ctx: ExecCtx, hook: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn member(\u0026self, ctx: QueryCtx, member: String) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn list_members(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn total_weight(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn admin(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn hooks(\u0026self, ctx: QueryCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use cosmwasm_std::{from_binary, from_slice, to_binary};\n\n    use super::*;\n\n    #[test]\n    fn execute() {\n        let original_msg = Cw4ExecMsg::UpdateAdmin {\n            admin: \"admin_name\".to_owned(),\n        };\n\n        let serialized_msg = to_binary(\u0026original_msg).unwrap();\n        let serialized_msg: Cw4ExecMsg = from_binary(\u0026serialized_msg).unwrap();\n\n        assert_eq!(serialized_msg, original_msg);\n    }\n\n    #[test]\n    fn query() {\n        let original_msg = Cw4QueryMsg::Admin {};\n\n        let serialized_msg = to_binary(\u0026original_msg).unwrap();\n        let serialized_msg: Cw4QueryMsg = from_binary(\u0026serialized_msg).unwrap();\n\n        assert_eq!(serialized_msg, original_msg);\n    }\n\n    #[test]\n    fn execute_from_slice() {\n        let deserialized: Cw4ExecMsg =\n            from_slice(br#\"{\"update_admin\": {\"admin\": \"admin_name\"}}\"#).unwrap();\n        assert_eq!(\n            deserialized,\n            Cw4ExecMsg::UpdateAdmin {\n                admin: \"admin_name\".to_owned()\n            }\n        );\n    }\n\n    #[test]\n    fn query_from_slice() {\n        let deserialized: Cw4QueryMsg = from_slice(br#\"{\"admin\": {}}\"#).unwrap();\n        assert_eq!(deserialized, Cw4QueryMsg::Admin {});\n    }\n\n    #[test]\n    fn exec_msgs() {\n        assert_eq!(\n            Cw4ExecMsg::messages(),\n            [\"add_hook\", \"remove_hook\", \"update_admin\", \"update_members\"]\n        );\n    }\n\n    #[test]\n    fn query_msgs() {\n        assert_eq!(\n            Cw4QueryMsg::messages(),\n            [\"admin\", \"hooks\", \"list_members\", \"member\", \"total_weight\"]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","examples","basic.rs"],"content":"use anyhow::Error;\nuse cosmwasm_std::{Addr, Response, StdError};\nuse cw_storage_plus::{Item, Map};\nuse sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};\nuse sylvia::{contract, interface};\n\n#[derive(\n    sylvia::serde::Serialize,\n    sylvia::serde::Deserialize,\n    Clone,\n    Debug,\n    PartialEq,\n    Eq,\n    sylvia::schemars::JsonSchema,\n)]\npub struct Member {\n    addr: String,\n    weight: u64,\n}\n\n#[derive(\n    sylvia::serde::Serialize,\n    sylvia::serde::Deserialize,\n    Clone,\n    Debug,\n    PartialEq,\n    Eq,\n    sylvia::schemars::JsonSchema,\n)]\npub struct MemberResp {\n    weight: u64,\n}\n\nmod group {\n    use super::*;\n\n    #[interface]\n    pub trait Group {\n        type Error: From\u003cStdError\u003e;\n\n        #[msg(exec)]\n        fn update_admin(\n            \u0026self,\n            ctx: ExecCtx,\n            admin: Option\u003cString\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n        #[msg(exec)]\n        fn update_members(\n            \u0026self,\n            ctx: ExecCtx,\n            remove: Vec\u003cString\u003e,\n            add: Vec\u003cMember\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n        #[msg(query)]\n        fn member(\u0026self, ctx: QueryCtx, addr: String) -\u003e Result\u003cMemberResp, Self::Error\u003e;\n    }\n\n    #[contract]\n    impl Group for GroupContract {\n        type Error = Error;\n\n        #[msg(exec)]\n        fn update_admin(\n            \u0026self,\n            _ctx: ExecCtx,\n            _admin: Option\u003cString\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e {\n            todo!()\n        }\n\n        #[msg(exec)]\n        fn update_members(\n            \u0026self,\n            _ctx: ExecCtx,\n            _remove: Vec\u003cString\u003e,\n            _add: Vec\u003cMember\u003e,\n        ) -\u003e Result\u003cResponse, Self::Error\u003e {\n            todo!()\n        }\n\n        #[msg(query)]\n        fn member(\u0026self, _ctx: QueryCtx, _addr: String) -\u003e Result\u003cMemberResp, Self::Error\u003e {\n            todo!()\n        }\n    }\n}\n\npub struct GroupContract {\n    admin: Item\u003c'static, Addr\u003e,\n    _members: Map\u003c'static, Addr, u64\u003e,\n}\n\nimpl Default for GroupContract {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[contract(module=contract)]\n#[error(Error)]\n#[messages(group as Group)]\nimpl GroupContract {\n    pub const fn new() -\u003e Self {\n        Self {\n            admin: Item::new(\"admin\"),\n            _members: Map::new(\"members\"),\n        }\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\n        \u0026self,\n        ctx: InstantiateCtx,\n        admin: Option\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, Error\u003e {\n        if let Some(admin) = admin {\n            let admin = ctx.deps.api.addr_validate(\u0026admin)?;\n            self.admin.save(ctx.deps.storage, \u0026admin)?;\n        }\n\n        Ok(Response::new())\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","examples","generics.rs"],"content":"use cosmwasm_std::{CosmosMsg, Response};\n\nuse sylvia::types::ExecCtx;\nuse sylvia_derive::interface;\n\n#[interface(module=msg)]\npub trait Cw1\u003cMsg\u003e\nwhere\n    Msg: std::fmt::Debug + PartialEq + Clone + schemars::JsonSchema,\n{\n    type Error;\n\n    #[msg(exec)]\n    fn execute(\u0026self, ctx: ExecCtx, msgs: Vec\u003cCosmosMsg\u003cMsg\u003e\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","lib.rs"],"content":"//! Framework for creating CosmWasm Smart Contract with high-level abstraction layer\n//!\n//! Most of implementation lies in `cw-derive-ng` crate which is reexported here\n\n#[cfg(feature = \"mt\")]\npub mod multitest;\npub mod types;\npub mod utils;\n\n#[cfg(feature = \"mt\")]\npub use anyhow;\npub use cosmwasm_std as cw_std;\n#[cfg(feature = \"mt\")]\npub use cw_multi_test;\n#[cfg(feature = \"mt\")]\npub use derivative;\npub use schemars;\npub use serde;\npub use serde_cw_value as serde_value;\npub use serde_json_wasm as serde_json;\npub use sylvia_derive::{contract, entry_points, interface};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","multitest.rs"],"content":"use std::cell::{Ref, RefCell, RefMut};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{Addr, BlockInfo, Coin};\nuse cw_multi_test::Executor;\nuse serde::Serialize;\n\n#[derive(Default)]\npub struct App {\n    pub app: RefCell\u003ccw_multi_test::App\u003e,\n}\n\nimpl App {\n    pub fn new(app: cw_multi_test::App) -\u003e Self {\n        Self {\n            app: RefCell::new(app),\n        }\n    }\n\n    pub fn app(\u0026self) -\u003e Ref\u003c'_, cw_multi_test::App\u003e {\n        Ref::map(self.app.borrow(), |app| app)\n    }\n\n    pub fn app_mut(\u0026self) -\u003e RefMut\u003c'_, cw_multi_test::App\u003e {\n        RefMut::map(self.app.borrow_mut(), |app| app)\n    }\n\n    pub fn block_info(\u0026self) -\u003e BlockInfo {\n        self.app.borrow().block_info()\n    }\n\n    pub fn set_block(\u0026self, block: BlockInfo) {\n        self.app.borrow_mut().set_block(block)\n    }\n\n    pub fn update_block\u003cF: Fn(\u0026mut BlockInfo)\u003e(\u0026self, action: F) {\n        self.app.borrow_mut().update_block(action)\n    }\n}\n\n#[must_use]\npub struct ExecProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    funds: \u0026'a [Coin],\n    contract_addr: \u0026'a Addr,\n    msg: Msg,\n    app: \u0026'app App,\n    phantom: PhantomData\u003cError\u003e,\n}\n\nimpl\u003c'a, 'app, Error, Msg\u003e ExecProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    pub fn new(contract_addr: \u0026'a Addr, msg: Msg, app: \u0026'app App) -\u003e Self {\n        Self {\n            funds: \u0026[],\n            contract_addr,\n            msg,\n            app,\n            phantom: PhantomData,\n        }\n    }\n    pub fn with_funds(self, funds: \u0026'a [Coin]) -\u003e Self {\n        Self { funds, ..self }\n    }\n\n    #[track_caller]\n    pub fn call(self, sender: \u0026'a str) -\u003e Result\u003ccw_multi_test::AppResponse, Error\u003e {\n        self.app\n            .app\n            .borrow_mut()\n            .execute_contract(\n                Addr::unchecked(sender),\n                Addr::unchecked(self.contract_addr),\n                \u0026self.msg,\n                self.funds,\n            )\n            .map_err(|err| err.downcast().unwrap())\n    }\n}\n\n#[must_use]\npub struct MigrateProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    contract_addr: \u0026'a Addr,\n    msg: Msg,\n    app: \u0026'app App,\n    phantom: PhantomData\u003cError\u003e,\n}\n\nimpl\u003c'a, 'app, Error, Msg\u003e MigrateProxy\u003c'a, 'app, Error, Msg\u003e\nwhere\n    Msg: Serialize + std::fmt::Debug,\n    Error: std::fmt::Debug + std::fmt::Display + Send + Sync + 'static,\n{\n    pub fn new(contract_addr: \u0026'a Addr, msg: Msg, app: \u0026'app App) -\u003e Self {\n        Self {\n            contract_addr,\n            msg,\n            app,\n            phantom: PhantomData,\n        }\n    }\n\n    #[track_caller]\n    pub fn call(self, sender: \u0026str, new_code_id: u64) -\u003e Result\u003ccw_multi_test::AppResponse, Error\u003e {\n        self.app\n            .app\n            .borrow_mut()\n            .migrate_contract(\n                Addr::unchecked(sender),\n                Addr::unchecked(self.contract_addr),\n                \u0026self.msg,\n                new_code_id,\n            )\n            .map_err(|err| err.downcast().unwrap())\n    }\n}\n","traces":[{"line":14,"address":[580736],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":16,"address":[580752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[580832],"length":1,"stats":{"Line":1},"fn_name":"app"},{"line":21,"address":[1553628,1553616],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":24,"address":[580864],"length":1,"stats":{"Line":0},"fn_name":"app_mut"},{"line":25,"address":[560368,560380],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":28,"address":[580896,581030],"length":1,"stats":{"Line":1},"fn_name":"block_info"},{"line":29,"address":[581003,580926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[581280,581264,581056],"length":1,"stats":{"Line":0},"fn_name":"set_block"},{"line":33,"address":[581209,581070,581146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[1979648,1979760],"length":1,"stats":{"Line":16},"fn_name":"new\u003ccw1_whitelist::error::ContractError, cw1::Cw1ExecMsg\u003e"},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1980302,1980355,1980867,1979872,1980384,1980814],"length":1,"stats":{"Line":15},"fn_name":"call\u003ccw1_whitelist::error::ContractError, cw1::Cw1ExecMsg\u003e"},{"line":74,"address":[1980725,1980445,1979933,1980273,1980785,1980013,1980525,1980213],"length":1,"stats":{"Line":54},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1980616,1980104],"length":1,"stats":{"Line":18},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":104,"address":[1049088],"length":1,"stats":{"Line":1},"fn_name":"new\u003ccosmwasm_std::errors::std_error::StdError, messages_generation::contract::MigrateMsg\u003e"},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":22,"coverable":32},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","types.rs"],"content":"use cosmwasm_std::{Deps, DepsMut, Env, MessageInfo};\n\npub struct MigrateCtx\u003c'a\u003e {\n    pub deps: DepsMut\u003c'a\u003e,\n    pub env: Env,\n}\n\npub struct ExecCtx\u003c'a\u003e {\n    pub deps: DepsMut\u003c'a\u003e,\n    pub env: Env,\n    pub info: MessageInfo,\n}\n\npub type InstantiateCtx\u003c'a\u003e = ExecCtx\u003c'a\u003e;\n\npub struct QueryCtx\u003c'a\u003e {\n    pub deps: Deps\u003c'a\u003e,\n    pub env: Env,\n}\n\nimpl ExecCtx\u003c'_\u003e {\n    pub fn branch(\u0026'_ mut self) -\u003e ExecCtx\u003c'_\u003e {\n        ExecCtx {\n            deps: self.deps.branch(),\n            env: self.env.clone(),\n            info: self.info.clone(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c(DepsMut\u003c'a\u003e, Env)\u003e for MigrateCtx\u003c'a\u003e {\n    fn from((deps, env): (DepsMut\u003c'a\u003e, Env)) -\u003e Self {\n        Self { deps, env }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c(DepsMut\u003c'a\u003e, Env, MessageInfo)\u003e for ExecCtx\u003c'a\u003e {\n    fn from((deps, env, info): (DepsMut\u003c'a\u003e, Env, MessageInfo)) -\u003e Self {\n        Self { deps, env, info }\n    }\n}\n\nimpl\u003c'a\u003e From\u003c(Deps\u003c'a\u003e, Env)\u003e for QueryCtx\u003c'a\u003e {\n    fn from((deps, env): (Deps\u003c'a\u003e, Env)) -\u003e Self {\n        Self { deps, env }\n    }\n}\n","traces":[{"line":22,"address":[2415680,2415885],"length":1,"stats":{"Line":5},"fn_name":"branch"},{"line":24,"address":[1317981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[1318000],"length":1,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[1318019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[566704,566725],"length":1,"stats":{"Line":44},"fn_name":"from"},{"line":44,"address":[],"length":0,"stats":{"Line":14},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","src","utils.rs"],"content":"#[derive(Debug, Copy, Clone, PartialEq, Eq)]\nenum State {\n    // Ongoing arrays can be compared to other arrays.\n    Ongoing(usize),\n    // Finished arrays can only be used by other arrays to be compared to.\n    Finished(usize),\n    // There can be empty arrays provided and we want to secure ourselves from \"index out of bounds\"\n    Empty,\n}\n\n/// # Examples\n///\n/// Compile time intersection assert.\n/// Will panic! in case duplicated messages were provided.\n/// Requires sorted arrays to work.\n/// ```\n///     const _: () = {\n///         let msgs: [\u0026[\u0026str]; 2] = [\u0026[\"msg_a\", \"msg_b\"], \u0026[\"msg_c\", \"msg_d\"]];\n///         sylvia::utils::assert_no_intersection(msgs);\n///     };\n/// ```\npub const fn assert_no_intersection\u003cconst N: usize\u003e(msgs: [\u0026[\u0026str]; N]) {\n    let mut states = init_states(\u0026msgs);\n\n    while !should_end(\u0026states) {\n        // Get index of array with alphabetically smallest value.\n        // This will always be one which state is Ongoing.\n        let index = get_next_alphabetical_index(\u0026msgs, \u0026states);\n\n        // Compare all elements at current indexes\n        verify_no_collissions(\u0026msgs, \u0026states, \u0026index);\n\n        // Increment index of alaphabeticaly first element\n        states[index] = match states[index] {\n            State::Ongoing(wi) =\u003e {\n                if msgs[index].len() == wi + 1 {\n                    State::Finished(wi)\n                } else {\n                    State::Ongoing(wi + 1)\n                }\n            }\n            _ =\u003e unreachable!(),\n        };\n    }\n}\n\nconst fn init_states\u003cconst N: usize\u003e(msgs: \u0026[\u0026[\u0026str]; N]) -\u003e [State; N] {\n    let mut states = [State::Ongoing(0); N];\n    konst::for_range! {i in 0..N =\u003e\n        if msgs[i].is_empty() {\n            states[i] = State::Empty;\n        }\n\n    }\n    states\n}\n\n// Finds index of array which is Ongoing and which current value\n// is alphabetically smallest\nconst fn get_next_alphabetical_index\u003cconst N: usize\u003e(\n    msgs: \u0026[\u0026[\u0026str]; N],\n    states: \u0026[State; N],\n) -\u003e usize {\n    let mut output_index = 0;\n    konst::for_range! {i in 0..N =\u003e\n        if let State::Ongoing(outer_i) = states[i] {\n            match states[output_index] {\n                State::Ongoing(inner_i) =\u003e {\n                    if let std::cmp::Ordering::Greater =\n                        konst::cmp_str(msgs[output_index][inner_i], msgs[i][outer_i])\n                    {\n                        output_index = i;\n                    }\n                }\n                _ =\u003e output_index = i,\n            }\n        }\n    }\n    output_index\n}\n\n// Compare values at current indexes saved in states.\n// All comparisions are made with value at index which point to alphabetically smallest\n// and values in each other arrays at their current position.\n//\n// Because arrays are sorted we don't have to compare each value with each other\n// and can just compare values in alphabetical ordering.\nconst fn verify_no_collissions\u003cconst N: usize\u003e(\n    msgs: \u0026[\u0026[\u0026str]; N],\n    states: \u0026[State; N],\n    index: \u0026usize,\n) {\n    let mut i = 0;\n    while i \u003c N {\n        if i == *index {\n            i += 1;\n            continue;\n        }\n        match states[i] {\n            State::Ongoing(outer_i) | State::Finished(outer_i) =\u003e {\n                if let State::Ongoing(inner_i) = states[*index] {\n                    if konst::eq_str(msgs[i][outer_i], msgs[*index][inner_i]) {\n                        panic!(\"Message overlaps between interface and contract impl!\");\n                    }\n                }\n            }\n            _ =\u003e (),\n        }\n        i += 1;\n    }\n}\n\nconst fn should_end\u003cconst N: usize\u003e(states: \u0026[State; N]) -\u003e bool {\n    konst::for_range! {i in 0..N =\u003e\n        if let State::Ongoing(..) = states[i] {\n            return false;\n        }\n    }\n    true\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn should_not_end() {\n        let states = [State::Empty, State::Ongoing(3), State::Finished(5)];\n        assert!(!super::should_end(\u0026states));\n    }\n\n    #[test]\n    fn should_end() {\n        let states = [State::Empty, State::Finished(3), State::Finished(5)];\n        assert!(super::should_end(\u0026states));\n    }\n\n    #[test]\n    fn init_states() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[\"msg\", \"msg\"], \u0026[], \u0026[\"msg\"]];\n        let states = [State::Ongoing(0), State::Empty, State::Ongoing(0)];\n        assert_eq!(super::init_states(\u0026msgs), states);\n    }\n\n    #[test]\n    fn aquire_index_when_two_states_ongoing() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[\"msg_b\", \"msg_c\"], \u0026[], \u0026[\"msg_a\"]];\n        let states = [State::Ongoing(1), State::Empty, State::Ongoing(0)];\n        assert_eq!(get_next_alphabetical_index(\u0026msgs, \u0026states), 2);\n    }\n\n    #[test]\n    fn aquire_index_when_mixed_state() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[\"msg_b\", \"msg_c\"], \u0026[], \u0026[\"msg_a\"]];\n        let states = [State::Ongoing(1), State::Empty, State::Finished(0)];\n        assert_eq!(get_next_alphabetical_index(\u0026msgs, \u0026states), 0);\n    }\n\n    #[test]\n    fn aquire_index_when_first_array_empty() {\n        let msgs: [\u0026[\u0026str]; 3] = [\u0026[], \u0026[\"msg_b\", \"msg_c\"], \u0026[\"msg_a\"]];\n        let states = [State::Empty, State::Ongoing(1), State::Finished(0)];\n        assert_eq!(get_next_alphabetical_index(\u0026msgs, \u0026states), 1);\n    }\n\n    #[test]\n    fn verify_no_collissions() {\n        let msgs: [\u0026[\u0026str]; 4] = [\u0026[], \u0026[\"msg_b\", \"msg_c\"], \u0026[\"msg_a\"], \u0026[\"msg_d\", \"msg_a\"]];\n        let states = [\n            State::Empty,\n            State::Ongoing(1),\n            State::Finished(0),\n            State::Ongoing(0),\n        ];\n\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00261);\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00263);\n\n        let states = [\n            State::Empty,\n            State::Ongoing(1),\n            State::Finished(0),\n            State::Ongoing(1),\n        ];\n\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00261);\n    }\n\n    #[test]\n    #[should_panic]\n    fn verify_collissions() {\n        let msgs: [\u0026[\u0026str]; 4] = [\u0026[], \u0026[\"msg_b\", \"msg_c\"], \u0026[\"msg_a\"], \u0026[\"msg_d\", \"msg_a\"]];\n        let states = [\n            State::Empty,\n            State::Ongoing(1),\n            State::Finished(0),\n            State::Ongoing(1),\n        ];\n\n        super::verify_no_collissions(\u0026msgs, \u0026states, \u00263);\n    }\n\n    #[test]\n    fn no_intersection() {\n        let msgs: [\u0026[\u0026str]; 5] = [\n            \u0026[\"msg_b\", \"msg_c\"],\n            \u0026[\"msg_d\", \"msg_e\", \"msg_f\"],\n            \u0026[\"msg_a\"],\n            \u0026[\"msg_g\", \"msg_h\", \"msg_i\", \"msg_j\"],\n            \u0026[],\n        ];\n\n        assert_no_intersection(msgs);\n    }\n\n    #[test]\n    #[should_panic]\n    fn intersection() {\n        let msgs: [\u0026[\u0026str]; 5] = [\n            \u0026[\"msg_b\", \"msg_c\", \"msg_i\"],\n            \u0026[\"msg_d\", \"msg_e\", \"msg_f\"],\n            \u0026[\"msg_a\"],\n            \u0026[\"msg_g\", \"msg_h\", \"msg_i\", \"msg_j\"],\n            \u0026[],\n        ];\n\n        assert_no_intersection(msgs);\n    }\n\n    #[test]\n    fn single_interface_with_no_contract_msgs() {\n        let msgs: [\u0026[\u0026str]; 2] = [\u0026[\"msg_a\", \"msg_b\"], \u0026[]];\n\n        assert_no_intersection(msgs);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[574064,573248,574880],"length":1,"stats":{"Line":4},"fn_name":"get_next_alphabetical_index\u003c2\u003e"},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[576656,575696,577616],"length":1,"stats":{"Line":5},"fn_name":"verify_no_collissions\u003c5\u003e"},{"line":93,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":41,"coverable":46},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","dispatching.rs"],"content":"use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\nuse cosmwasm_std::{from_binary, Addr, Decimal, Response, StdError};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\nuse sylvia::{contract, interface};\n\n#[interface]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        ctx: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, ctx: QueryCtx) -\u003e Result\u003cEmptyQueryResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, ctx: QueryCtx, user: Addr) -\u003e Result\u003cQueryResponse, Self::Error\u003e;\n}\n\n#[derive(Default)]\nstruct Contract {\n    execs: RefCell\u003cu64\u003e,\n    queries: RefCell\u003cu64\u003e,\n\n    data: RefCell\u003cHashMap\u003cAddr, QueryResponse\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct EmptyQueryResponse {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct QueryResponse {\n    coef: Decimal,\n    desc: String,\n}\n\n#[contract]\nimpl Interface for Contract {\n    type Error = StdError;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, _: ExecCtx) -\u003e Result\u003cResponse, StdError\u003e {\n        *self.execs.borrow_mut() += 1;\n        Ok(Response::new())\n    }\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        _: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e {\n        *self.execs.borrow_mut() += 1;\n\n        self.data\n            .borrow_mut()\n            .insert(addr, QueryResponse { coef, desc });\n        Ok(Response::new())\n    }\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, _: QueryCtx) -\u003e Result\u003cEmptyQueryResponse, StdError\u003e {\n        *self.queries.borrow_mut() += 1;\n        Ok(dbg!(EmptyQueryResponse {}))\n    }\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, _: QueryCtx, user: Addr) -\u003e Result\u003cQueryResponse, Self::Error\u003e {\n        *self.queries.borrow_mut() += 1;\n        Ok(self.data.borrow().get(\u0026user).unwrap().clone())\n    }\n}\n\n#[test]\nfn dispatch() {\n    let contract = Contract::default();\n\n    let mut deps = mock_dependencies();\n    let env = mock_env();\n    let info = mock_info(\"owner\", \u0026[]);\n\n    let resp = ExecMsg::NoArgsExecution {}\n        .dispatch(\u0026contract, (deps.as_mut(), env.clone(), info.clone()))\n        .unwrap();\n    assert_eq!(resp, Response::new());\n\n    let resp = ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"addr1\"),\n        coef: Decimal::percent(30),\n        desc: \"True\".to_owned(),\n    }\n    .dispatch(\u0026contract, (deps.as_mut(), env.clone(), info.clone()))\n    .unwrap();\n    assert_eq!(resp, Response::new());\n\n    let resp = ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"addr2\"),\n        coef: Decimal::percent(70),\n        desc: \"False\".to_owned(),\n    }\n    .dispatch(\u0026contract, (deps.as_mut(), env.clone(), info))\n    .unwrap();\n    assert_eq!(resp, Response::new());\n\n    let resp = QueryMsg::NoArgsQuery {}\n        .dispatch(\u0026contract, (deps.as_ref(), env.clone()))\n        .unwrap();\n    let _resp: EmptyQueryResponse = from_binary(\u0026resp).unwrap();\n\n    let resp = QueryMsg::ArgumentedQuery {\n        user: Addr::unchecked(\"addr2\"),\n    }\n    .dispatch(\u0026contract, (deps.as_ref(), env))\n    .unwrap();\n    let resp: QueryResponse = from_binary(\u0026resp).unwrap();\n    assert_eq!(\n        resp,\n        QueryResponse {\n            coef: Decimal::percent(70),\n            desc: \"False\".to_owned()\n        }\n    );\n\n    assert_eq!(*contract.execs.borrow(), 3);\n    assert_eq!(*contract.queries.borrow(), 2);\n}\n","traces":[{"line":58,"address":[849744,849662,849408],"length":1,"stats":{"Line":1},"fn_name":"no_args_execution"},{"line":59,"address":[849522,849451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[849678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[850556,849760,850099],"length":1,"stats":{"Line":1},"fn_name":"argumented_execution"},{"line":71,"address":[849954,849847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[850386,850115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[850196,850401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[850431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[850896,851412,850576],"length":1,"stats":{"Line":1},"fn_name":"no_args_query"},{"line":81,"address":[850724,850634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[850915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[673390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[851567,851488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[851728,851852],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","messages_generation.rs"],"content":"use cosmwasm_std::{Addr, Decimal, Response, StdError, StdResult};\n\nuse sylvia::types::{ExecCtx, InstantiateCtx, MigrateCtx, QueryCtx};\nuse sylvia::{contract, interface};\n\n#[derive(\n    serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema,\n)]\npub struct QueryResult;\n\n#[interface(module=interface)]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        ctx: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        #[serde(default)] desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, ctx: QueryCtx) -\u003e Result\u003cQueryResult, Self::Error\u003e;\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, ctx: QueryCtx, user: Addr) -\u003e Result\u003cQueryResult, Self::Error\u003e;\n}\n\npub struct Contract {}\n\n#[cfg(not(tarpaulin_include))]\n// Ignoring coverage of test implementation\n#[contract(module=contract)]\nimpl Contract {\n    #[allow(clippy::new_without_default)]\n    pub const fn new() -\u003e Self {\n        Self {}\n    }\n\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(migrate)]\n    pub fn migrate(\u0026self, _ctx: MigrateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, _ctx: ExecCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        _ctx: ExecCtx,\n        _addr: Addr,\n        #[serde(default)] _coef: Decimal,\n        #[serde(default)] _desc: String,\n    ) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, _ctx: QueryCtx) -\u003e StdResult\u003cQueryResult\u003e {\n        Ok(QueryResult {})\n    }\n\n    #[msg(query)]\n    fn argumented_query(\u0026self, _ctx: QueryCtx, _user: Addr) -\u003e StdResult\u003cQueryResult\u003e {\n        Ok(QueryResult {})\n    }\n}\n\n#[test]\nfn interface_messages_constructible() {\n    let no_args_exec = interface::ExecMsg::NoArgsExecution {};\n    let _argumented_exec = interface::ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"owner\"),\n        coef: Decimal::percent(10),\n        desc: \"Some description\".to_owned(),\n    };\n    let no_args_query = interface::QueryMsg::NoArgsQuery {};\n    let _argumented_query = interface::QueryMsg::ArgumentedQuery {\n        user: Addr::unchecked(\"owner\"),\n    };\n\n    // Ensure no extra variants are generated\n    match no_args_exec {\n        interface::ExecMsg::NoArgsExecution {} =\u003e (),\n        interface::ExecMsg::ArgumentedExecution { .. } =\u003e (),\n    }\n\n    match no_args_query {\n        interface::QueryMsg::NoArgsQuery {} =\u003e (),\n        interface::QueryMsg::ArgumentedQuery { .. } =\u003e (),\n    }\n}\n\n#[test]\nfn contract_messages_constructible() {\n    let no_args_exec = contract::ExecMsg::NoArgsExecution {};\n    let _argumented_exec = contract::ExecMsg::ArgumentedExecution {\n        _addr: Addr::unchecked(\"owner\"),\n        _coef: Decimal::percent(10),\n        _desc: \"Some description\".to_owned(),\n    };\n    let no_args_query = contract::QueryMsg::NoArgsQuery {};\n    let _argumented_query = contract::QueryMsg::ArgumentedQuery {\n        _user: Addr::unchecked(\"owner\"),\n    };\n    let _ = contract::InstantiateMsg {};\n    let _ = contract::MigrateMsg {};\n\n    // Ensure no extra variants are generated\n    match no_args_exec {\n        contract::ExecMsg::NoArgsExecution {} =\u003e (),\n        contract::ExecMsg::ArgumentedExecution { .. } =\u003e (),\n    }\n\n    match no_args_query {\n        contract::QueryMsg::NoArgsQuery {} =\u003e (),\n        contract::QueryMsg::ArgumentedQuery { .. } =\u003e (),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","query_returns.rs"],"content":"use cosmwasm_std::{Response, StdError, StdResult};\n\nuse sylvia::types::{InstantiateCtx, QueryCtx};\nuse sylvia::{contract, interface};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n}\n\n#[derive(\n    serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema,\n)]\npub struct QueryResponse;\n\ntype QueryResult\u003cE\u003e = Result\u003cQueryResponse, E\u003e;\n\n#[interface(module=msg)]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(query, resp=QueryResponse)]\n    fn query(\u0026self, ctx: QueryCtx, #[serde(default)] name: String) -\u003e QueryResult\u003cSelf::Error\u003e;\n}\n\npub struct SomeContract {}\n\n#[contract]\n#[error(ContractError)]\nimpl SomeContract {\n    #[allow(clippy::new_without_default)]\n    pub const fn new() -\u003e Self {\n        Self {}\n    }\n    #[msg(instantiate)]\n    pub fn instantiate(\u0026self, _ctx: InstantiateCtx) -\u003e StdResult\u003cResponse\u003e {\n        Ok(Response::new())\n    }\n\n    #[msg(query, resp=QueryResponse)]\n    fn contract_query(\n        \u0026self,\n        _ctx: QueryCtx,\n        #[serde(default)] _name: String,\n    ) -\u003e QueryResult\u003cContractError\u003e {\n        Ok(QueryResponse {})\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generate_interface_query() {\n        let _ = msg::InterfaceQueryMsg::Query {\n            name: \"some_name\".to_owned(),\n        };\n    }\n\n    #[test]\n    fn generate_contract_query() {\n        let _ = QueryMsg::ContractQuery {\n            _name: \"some_name\".to_owned(),\n        };\n    }\n}\n","traces":[{"line":31,"address":[694455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[974752],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":37,"address":[974768,974903],"length":1,"stats":{"Line":0},"fn_name":"instantiate"},{"line":38,"address":[974849,974803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[975044,974944],"length":1,"stats":{"Line":0},"fn_name":"contract_query"},{"line":47,"address":[974979],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","janw","workspace","confio","sylvia","sylvia","tests","separate_module.rs"],"content":"use cosmwasm_std::{Addr, Decimal, Response, StdError};\n\nuse sylvia::interface;\nuse sylvia::types::{ExecCtx, QueryCtx};\n\n#[derive(\n    serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, Eq, schemars::JsonSchema,\n)]\npub struct QueryResult;\n\n#[interface(module=msg)]\npub trait Interface {\n    type Error: From\u003cStdError\u003e;\n\n    #[msg(exec)]\n    fn no_args_execution(\u0026self, ctx: ExecCtx) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(exec)]\n    fn argumented_execution(\n        \u0026self,\n        ctx: ExecCtx,\n        addr: Addr,\n        coef: Decimal,\n        desc: String,\n    ) -\u003e Result\u003cResponse, Self::Error\u003e;\n\n    #[msg(query)]\n    fn no_args_query(\u0026self, ctx: QueryCtx) -\u003e Result\u003cQueryResult, Self::Error\u003e;\n\n    #[msg(query)]\n    fn argumented_query(\n        \u0026self,\n        ctx: QueryCtx,\n        user: Addr,\n    ) -\u003e Result\u003cOption\u003cQueryResult\u003e, Self::Error\u003e;\n}\n\n#[test]\nfn messages_constructible() {\n    let _no_args_exec = msg::ExecMsg::NoArgsExecution {};\n    let _argumented_exec = msg::ExecMsg::ArgumentedExecution {\n        addr: Addr::unchecked(\"owner\"),\n        coef: Decimal::percent(10),\n        desc: \"Some description\".to_owned(),\n    };\n    let _no_args_query = msg::QueryMsg::NoArgsQuery {};\n    let _argumented_query = msg::QueryMsg::ArgumentedQuery {\n        user: Addr::unchecked(\"owner\"),\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","check_generics.rs"],"content":"use syn::visit::Visit;\nuse syn::GenericParam;\n\npub struct CheckGenerics\u003c'g\u003e {\n    generics: \u0026'g [\u0026'g GenericParam],\n    used: Vec\u003c\u0026'g GenericParam\u003e,\n}\n\nimpl\u003c'g\u003e CheckGenerics\u003c'g\u003e {\n    pub fn new(generics: \u0026'g [\u0026'g GenericParam]) -\u003e Self {\n        Self {\n            generics,\n            used: vec![],\n        }\n    }\n\n    pub fn used(self) -\u003e Vec\u003c\u0026'g GenericParam\u003e {\n        self.used\n    }\n\n    /// Returns split between used and unused generics\n    pub fn used_unused(self) -\u003e (Vec\u003c\u0026'g GenericParam\u003e, Vec\u003c\u0026'g GenericParam\u003e) {\n        let unused = self\n            .generics\n            .iter()\n            .filter(|gen| !self.used.contains(*gen))\n            .copied()\n            .collect();\n\n        (self.used, unused)\n    }\n}\n\nimpl\u003c'ast, 'g\u003e Visit\u003c'ast\u003e for CheckGenerics\u003c'g\u003e {\n    fn visit_path(\u0026mut self, p: \u0026'ast syn::Path) {\n        if let Some(p) = p.get_ident() {\n            if let Some(gen) = self\n                .generics\n                .iter()\n                .find(|gen| matches!(gen, GenericParam::Type(ty) if ty.ident == *p))\n            {\n                if !self.used.contains(gen) {\n                    self.used.push(gen);\n                }\n            }\n        }\n\n        // Default visit implementation - visiting path deeper\n        for el in \u0026p.segments {\n            self.visit_path_segment(el);\n        }\n    }\n}\n","traces":[{"line":10,"address":[2803632],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2803744],"length":1,"stats":{"Line":0},"fn_name":"used"},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[2803776,2804093],"length":1,"stats":{"Line":1},"fn_name":"used_unused"},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[1275826,1275808],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":30,"address":[2803945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2804554,2804128],"length":1,"stats":{"Line":1},"fn_name":"visit_path"},{"line":36,"address":[2804168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2804263,2804337,2804228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[1275895,1275872],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":42,"address":[2804355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2804398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2804314,2804529,2804412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[2804542],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":12,"coverable":18},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","input.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::{parse_quote, GenericParam, Ident, ItemImpl, ItemTrait, TraitItem, Type};\n\nuse crate::crate_module;\nuse crate::message::{ContractEnumMessage, EnumMessage, GlueMessage, StructMessage};\nuse crate::multitest::{MultitestHelpers, TraitMultitestHelpers};\nuse crate::parser::{ContractArgs, ContractErrorAttr, InterfaceArgs, MsgType};\nuse crate::remote::Remote;\n\n/// Preprocessed `interface` macro input\npub struct TraitInput\u003c'a\u003e {\n    attributes: \u0026'a InterfaceArgs,\n    item: \u0026'a ItemTrait,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n}\n\n/// Preprocessed `contract` macro input for non-trait impl block\npub struct ImplInput\u003c'a\u003e {\n    attributes: \u0026'a ContractArgs,\n    error: Type,\n    item: \u0026'a ItemImpl,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n}\n\nimpl\u003c'a\u003e TraitInput\u003c'a\u003e {\n    #[cfg(not(tarpaulin_include))]\n    // This requires invalid implementation which would fail at compile time and making it impossible to test\n    pub fn new(attributes: \u0026'a InterfaceArgs, item: \u0026'a ItemTrait) -\u003e Self {\n        let generics = item.generics.params.iter().collect();\n\n        if !item\n            .items\n            .iter()\n            .any(|item| matches!(item, TraitItem::Type(ty) if ty.ident == Ident::new(\"Error\", ty.ident.span())))\n        {\n            emit_error!(\n                item.ident.span(), \"Missing `Error` type defined for trait.\";\n                note = \"Error is an error type returned by generated types dispatch function. Messages handling function have to return an error type convertible to this Error type.\";\n                note = \"A trait error type should be bound to implement `From\u003ccosmwasm_std::StdError\u003e`.\";\n            );\n        }\n\n        Self {\n            attributes,\n            item,\n            generics,\n        }\n    }\n\n    pub fn process(\u0026self) -\u003e TokenStream {\n        let messages = self.emit_messages();\n        let multitest_helpers = self.emit_helpers();\n        let remote = Remote::for_interface().emit();\n\n        if let Some(module) = \u0026self.attributes.module {\n            #[cfg(not(tarpaulin_include))]\n            quote! {\n                pub mod #module {\n                    use super::*;\n\n                    #messages\n\n                    #multitest_helpers\n\n                    #remote\n                }\n            }\n        } else {\n            #[cfg(not(tarpaulin_include))]\n            quote! {\n                #messages\n\n                #multitest_helpers\n\n                #remote\n            }\n        }\n    }\n\n    fn emit_helpers(\u0026self) -\u003e TokenStream {\n        if cfg!(feature = \"mt\") {\n            let multitest_helpers = TraitMultitestHelpers::new(self.item);\n            multitest_helpers.emit()\n        } else {\n            quote! {}\n        }\n    }\n\n    fn emit_messages(\u0026self) -\u003e TokenStream {\n        let exec = self.emit_msg(\n            \u0026Ident::new(\"ExecMsg\", Span::mixed_site()),\n            MsgType::Exec,\n            self.attributes,\n        );\n        let query = self.emit_msg(\n            \u0026Ident::new(\"QueryMsg\", Span::mixed_site()),\n            MsgType::Query,\n            self.attributes,\n        );\n\n        #[cfg(not(tarpaulin_include))]\n        quote! {\n            #exec\n\n            #query\n        }\n    }\n\n    fn emit_msg(\u0026self, name: \u0026Ident, msg_ty: MsgType, args: \u0026InterfaceArgs) -\u003e TokenStream {\n        EnumMessage::new(name, self.item, msg_ty, \u0026self.generics, args).emit()\n    }\n}\n\nimpl\u003c'a\u003e ImplInput\u003c'a\u003e {\n    pub fn new(attributes: \u0026'a ContractArgs, item: \u0026'a ItemImpl) -\u003e Self {\n        let sylvia = crate_module();\n\n        let generics = item.generics.params.iter().collect();\n\n        let error = item\n            .attrs\n            .iter()\n            .find(|attr| attr.path.is_ident(\"error\"))\n            .and_then(\n                |attr| match ContractErrorAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(error) =\u003e Some(error.error),\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        None\n                    }\n                },\n            )\n            .unwrap_or_else(|| parse_quote! { #sylvia ::cw_std::StdError });\n\n        Self {\n            attributes,\n            item,\n            generics,\n            error,\n        }\n    }\n\n    pub fn process(\u0026self) -\u003e TokenStream {\n        let is_trait = self.item.trait_.is_some();\n\n        let multitest_helpers = if cfg!(feature = \"mt\") {\n            MultitestHelpers::new(self.item, is_trait, \u0026self.error, \u0026self.generics).emit()\n        } else {\n            quote! {}\n        };\n\n        if is_trait {\n            return multitest_helpers;\n        }\n\n        let messages = self.emit_messages();\n        let remote = Remote::for_contract(self.item).emit();\n\n        #[cfg(not(tarpaulin_include))]\n        let code = quote! {\n            #messages\n\n            #multitest_helpers\n\n            #remote\n        };\n\n        if let Some(module) = \u0026self.attributes.module {\n            #[cfg(not(tarpaulin_include))]\n            quote! {\n                pub mod #module {\n                    use super::*;\n\n                    #code\n                }\n            }\n        } else {\n            code\n        }\n    }\n\n    fn emit_messages(\u0026self) -\u003e TokenStream {\n        let instantiate = self.emit_struct_msg(MsgType::Instantiate);\n        let migrate = self.emit_struct_msg(MsgType::Migrate);\n        let exec_impl =\n            self.emit_enum_msg(\u0026Ident::new(\"ExecMsg\", Span::mixed_site()), MsgType::Exec);\n        let query_impl =\n            self.emit_enum_msg(\u0026Ident::new(\"QueryMsg\", Span::mixed_site()), MsgType::Query);\n        let exec = self.emit_glue_msg(\u0026Ident::new(\"ExecMsg\", Span::mixed_site()), MsgType::Exec);\n        let query = self.emit_glue_msg(\u0026Ident::new(\"QueryMsg\", Span::mixed_site()), MsgType::Query);\n\n        #[cfg(not(tarpaulin_include))]\n        quote! {\n            #instantiate\n\n            #exec_impl\n\n            #query_impl\n\n            #migrate\n\n            #exec\n\n            #query\n        }\n    }\n\n    fn emit_struct_msg(\u0026self, msg_ty: MsgType) -\u003e TokenStream {\n        StructMessage::new(self.item, msg_ty, \u0026self.generics).map_or(quote! {}, |msg| msg.emit())\n    }\n\n    fn emit_enum_msg(\u0026self, name: \u0026Ident, msg_ty: MsgType) -\u003e TokenStream {\n        ContractEnumMessage::new(name, self.item, msg_ty, \u0026self.generics, \u0026self.error).emit()\n    }\n\n    fn emit_glue_msg(\u0026self, name: \u0026Ident, msg_ty: MsgType) -\u003e TokenStream {\n        GlueMessage::new(name, self.item, msg_ty, \u0026self.error).emit()\n    }\n}\n","traces":[{"line":49,"address":[1234768,1235648,1235130],"length":1,"stats":{"Line":1},"fn_name":"process"},{"line":50,"address":[1234803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1234818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1235128,1234871,1235619],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[1235160,1234908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1234927,1234987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1235664],"length":1,"stats":{"Line":1},"fn_name":"emit_helpers"},{"line":73,"address":[1235683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1235702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1235728,1235889],"length":1,"stats":{"Line":1},"fn_name":"emit_messages"},{"line":81,"address":[1235818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[1235758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[1235810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1235815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1236019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1235953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[1236008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[1236016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[1236156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1236288,1236506],"length":1,"stats":{"Line":1},"fn_name":"emit_msg"},{"line":100,"address":[1236365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1236544],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":106,"address":[1236586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1236704,1236912],"length":1,"stats":{"Line":1},"fn_name":"process"},{"line":116,"address":[1236734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1236773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1236906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1236963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[1236951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1237109,1237049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1237922,1237278],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[1237318,1237460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1237342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1238313,1238000,1239279],"length":1,"stats":{"Line":1},"fn_name":"emit_messages"},{"line":150,"address":[1238030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[1238055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1238175,1238118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1238368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1238569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1238770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1238976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1239541,1239514,1239296],"length":1,"stats":{"Line":1},"fn_name":"emit_struct_msg"},{"line":175,"address":[328352,328368],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":178,"address":[1239552,1239760],"length":1,"stats":{"Line":1},"fn_name":"emit_enum_msg"},{"line":179,"address":[1239616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1239792,1239938],"length":1,"stats":{"Line":1},"fn_name":"emit_glue_msg"},{"line":183,"address":[1239838],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":47,"coverable":70},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","lib.rs"],"content":"use input::{ImplInput, TraitInput};\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse proc_macro_error::proc_macro_error;\nuse quote::quote;\nuse syn::fold::Fold;\nuse syn::{parse2, parse_quote, ItemImpl, ItemTrait, Path};\n\npub(crate) mod check_generics;\nmod input;\nmod message;\nmod multitest;\nmod parser;\nmod remote;\nmod strip_generics;\nmod strip_input;\nmod utils;\n\nuse strip_input::StripInput;\n\nuse crate::message::EntryPoints;\n\n#[cfg(not(test))]\npub(crate) fn crate_module() -\u003e Path {\n    use proc_macro_crate::{crate_name, FoundCrate};\n\n    match crate_name(\"sylvia\").expect(\"sylvia is not found in Cargo.toml\") {\n        FoundCrate::Itself =\u003e parse_quote!(sylvia),\n        FoundCrate::Name(name) =\u003e {\n            let ident = syn::Ident::new(\u0026name, proc_macro2::Span::mixed_site());\n            parse_quote!(#ident)\n        }\n    }\n}\n\n#[cfg(test)]\npub(crate) fn crate_module() -\u003e Path {\n    parse_quote!(sylvia)\n}\n\n/// Macro generating messages from contract trait.\n///\n/// ## Example usage\n/// ```ignore\n/// # use cosmwasm_std::Response;\n///\n/// # struct Ctx;\n/// # struct Error;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct Member;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct AdminQueryResponse;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct MemberQueryResponse;\n///\n/// #[sylvia::interface(module=msg)]\n/// trait Cw4 {\n///     type Error: From\u003cStdError\u003e;\n///\n///     #[msg(exec)]\n///     fn update_admin(\u0026self, ctx: (DepsMut, Env, MessageInfo), admin: Option\u003cString\u003e) -\u003e Result\u003cResponse, Self::Error\u003e;\n///\n///     #[msg(exec)]\n///     fn update_members(\u0026self, ctx: (DepsMut, Env, MessageInfo), remove: Vec\u003cString\u003e, add: Vec\u003cMember\u003e)\n///         -\u003e Result\u003cResponse, Self::Error\u003e;\n///\n///     #[msg(query)]\n///     fn admin(\u0026self, ctx: (Deps, Env)) -\u003e Result\u003cAdminQueryResponse, Error\u003e;\n///\n///     #[msg(query)]\n///     fn member(\u0026self, ctx: (Deps, Env), addr: String, at_height: Option\u003cu64\u003e) -\u003e Result\u003cMemberQueryResponse, Error\u003e;\n/// }\n/// ```\n///\n/// This would generate output like:\n///\n/// ```ignore\n/// pub mod msg {\n///     # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     # struct Member;\n///\n///     #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     #[serde(rename_all = \"snake_case\")]\n///     pub enum ExecMsg {\n///         UpdateAdmin { admin: Option\u003cString\u003e },\n///         UpdateMembers {\n///             remove: Vec\u003cString\u003e,\n///             add: Vec\u003cMember\u003e,\n///         },\n///         AddHook { addr: String },\n///         RemoveHook { addr: String },\n///     }\n///\n///     impl ExecMsg {\n///         pub fn dispatch\u003cC: Cw4\u003e(contract: \u0026C, ctx: (DepsMut, Env, MessageInfo))\n///             -\u003e Result\u003cResponse, C::Error\u003e\n///         {\n///             // Some dispatching implementation\n///         }\n///     }\n/// }\n///\n/// And similar `Query` structure for handling queries.\n/// ```\n///\n/// ## Parameters\n///\n/// `interface` attribute takes optional parameters:\n/// * `module` - defines module name, where all generated messages would be encapsulated; no\n/// additional module would be created if not provided\n///\n/// ## Attributes\n///\n/// Messages structures are generated basing on interface trait method attributed with\n/// `#[msg(msg_type, ...)`. Msg attribute takes as its first argument type of message it is\n/// supposed to handle:\n///   * `exec` - this is execute message variant\n///   * `query` - this is query message variant\n///\n/// In case of query it is possible to pass second argument which is it's `ResponseType`.\n/// This is required in case of aliased results wrapping their `ResponseType`.\n/// Example for member query\n///\n/// ```ignore\n///     #[msg(query, resp=MemberQueryResponse)]\n///     fn member(\u0026self, ctx: (Deps, Env), addr: String, at_height: Option\u003cu64\u003e) -\u003e Result\u003cMemberQueryResponse, Error\u003e;\n/// ```\n///\n/// For now `#[msg(...)]` attribute doesn't support anymore data on `#[interface]`\n/// elements, but it may be extended in future.\n#[cfg(not(tarpaulin_include))]\n#[proc_macro_error]\n#[proc_macro_attribute]\npub fn interface(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    interface_impl(attr.into(), item.into()).into()\n}\n\nfn interface_impl(attr: TokenStream2, item: TokenStream2) -\u003e TokenStream2 {\n    fn inner(attr: TokenStream2, item: TokenStream2) -\u003e syn::Result\u003cTokenStream2\u003e {\n        let attrs: parser::InterfaceArgs = parse2(attr)?;\n        let input: ItemTrait = parse2(item)?;\n\n        let expanded = TraitInput::new(\u0026attrs, \u0026input).process();\n        let input = StripInput.fold_item_trait(input);\n\n        Ok(quote! {\n            #input\n\n            #expanded\n        })\n    }\n\n    inner(attr, item).unwrap_or_else(syn::Error::into_compile_error)\n}\n\n/// Macro generating messages from contract impl block.\n///\n/// ## Example usage\n/// ```ignore\n/// # use cosmwasm_std::Response;\n///\n/// # struct Ctx;\n/// # struct Error;\n///\n/// # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n/// # struct Cw4Group;\n///\n/// #[cw_derive::contract(module=msg)]\n/// impl Cw4Group {\n///     #[msg(instantiate, name=\"Instantiate\")]\n///     fn instantiate(\u0026self, ctx: (DepsMut, Env, MessageInfo), admin: Option\u003cString\u003e)\n///         -\u003e Result\u003cResponse, Error\u003e;\n/// }\n/// ```\n///\n/// This would generate output like:\n///\n/// ```ignore\n/// pub mod msg {\n///     # #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     # struct Cw4Group;\n///\n///     #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq, schemars::JsonSchema)]\n///     #[serde(rename_all = \"snake_case\")]\n///     pub struct Instantiate {\n///         admin: Option\u003cString\u003e,\n///     }\n///\n///     impl Instantiate {\n///         fn dispatch(contract: \u0026Cw4Group, ctx: (DepsMut, Env, MessageInfo), admin: Option\u003cString\u003e)\n///             -\u003e Result\u003cResponse, Error\u003e\n///         {\n///             contract.instantiate(ctx, admin)\n///         }\n///     }\n/// }\n/// ```\n///\n/// ## Parameters\n///\n/// `contract` attribute takes optional parameters:\n/// * `module` - defines module name, where all generated messages would be encapsulated; no\n/// additional module would be created if not provided\n///\n/// ## Attributes\n///\n/// Messages structures are generated basing on specific implemented methods attributed with\n/// `#[msg(msg_type, ...)`. Msg attribute takes as its first argument type of message it is\n/// supposed to handle:\n/// * `instantiate` - this is instantiation message handler. There should be always exactly one\n/// * `exec` - this is execute message variant\n/// * `query` - this is query message variant\n/// * `migrate` - this is migrate message variant\n/// handler for this kind of message.\n/// In case of query it is possible to pass second argument which is it's `ResponseType`.\n/// This is required in case of aliased results wrapping their `ResponseType`.\n/// Example for member query\n///\n/// ```ignore\n///     #[msg(query, resp=MemberQueryResponse)]\n///     fn member(\u0026self, ctx: (Deps, Env), addr: String, at_height: Option\u003cu64\u003e) -\u003e Result\u003cMemberQueryResponse, Error\u003e\n/// ```\n#[cfg(not(tarpaulin_include))]\n#[proc_macro_error]\n#[proc_macro_attribute]\npub fn contract(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    contract_impl(attr.into(), item.into()).into()\n}\n\nfn contract_impl(attr: TokenStream2, item: TokenStream2) -\u003e TokenStream2 {\n    fn inner(attr: TokenStream2, item: TokenStream2) -\u003e syn::Result\u003cTokenStream2\u003e {\n        let attrs: parser::ContractArgs = parse2(attr)?;\n        let input: ItemImpl = parse2(item)?;\n\n        let expanded = ImplInput::new(\u0026attrs, \u0026input).process();\n        let input = StripInput.fold_item_impl(input);\n\n        Ok(quote! {\n            #input\n\n            #expanded\n        })\n    }\n\n    inner(attr, item).unwrap_or_else(syn::Error::into_compile_error)\n}\n\n#[cfg(not(tarpaulin_include))]\n#[proc_macro_error]\n#[proc_macro_attribute]\npub fn entry_points(attr: TokenStream, item: TokenStream) -\u003e TokenStream {\n    entry_points_impl(attr.into(), item.into()).into()\n}\n\nfn entry_points_impl(attr: TokenStream2, item: TokenStream2) -\u003e TokenStream2 {\n    fn inner(_attr: TokenStream2, item: TokenStream2) -\u003e syn::Result\u003cTokenStream2\u003e {\n        let input: ItemImpl = parse2(item)?;\n        let expanded = EntryPoints::new(\u0026input).emit();\n\n        Ok(quote! {\n            #input\n\n            #expanded\n        })\n    }\n\n    inner(attr, item).unwrap_or_else(syn::Error::into_compile_error)\n}\n\n#[cfg(test)]\nmod test {\n    use std::{env, fs};\n\n    use sylvia_runtime_macros::emulate_attribute_expansion_fallible;\n\n    use crate::{contract_impl, interface_impl};\n\n    // Test expanding macros in sylvia crate tests, to calculate generating code coverage\n    #[test]\n    fn sylvia_test_cov() {\n        let mut path = env::current_dir().unwrap();\n        path.push(\"..\");\n        path.push(\"sylvia\");\n        path.push(\"tests\");\n\n        for entry in fs::read_dir(path).unwrap() {\n            let entry = entry.unwrap();\n\n            if entry.file_type().unwrap().is_file() {\n                let file = fs::File::open(entry.path()).unwrap();\n                emulate_attribute_expansion_fallible(file, \"interface\", interface_impl).unwrap();\n\n                let file = fs::File::open(entry.path()).unwrap();\n                emulate_attribute_expansion_fallible(file, \"contract\", contract_impl).unwrap();\n            }\n        }\n    }\n}\n","traces":[{"line":34,"address":[674384,674540],"length":1,"stats":{"Line":1},"fn_name":"crate_module"},{"line":35,"address":[674397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[674576],"length":1,"stats":{"Line":1},"fn_name":"interface_impl"},{"line":139,"address":[675591,674704,676026],"length":1,"stats":{"Line":1},"fn_name":"inner"},{"line":140,"address":[674853,674726,675024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[675188,675336,674962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[675532,675321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[675646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[675717,675780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[674589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[676064],"length":1,"stats":{"Line":1},"fn_name":"contract_impl"},{"line":231,"address":[677514,676192,677079],"length":1,"stats":{"Line":1},"fn_name":"inner"},{"line":232,"address":[676512,676341,676214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[676450,676676,676824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[676809,677020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[677134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[677268,677205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[676077],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":18,"coverable":18},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","message.rs"],"content":"use crate::check_generics::CheckGenerics;\nuse crate::crate_module;\nuse crate::parser::{\n    parse_struct_message, ContractErrorAttr, ContractMessageAttr, InterfaceArgs, MsgAttr, MsgType,\n};\nuse crate::strip_generics::StripGenerics;\nuse crate::utils::{extract_return_type, filter_wheres, process_fields};\nuse convert_case::{Case, Casing};\nuse proc_macro2::{Span, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::fold::Fold;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::visit::Visit;\nuse syn::{\n    parse_quote, Attribute, GenericParam, Ident, ImplItem, ItemImpl, ItemTrait, Pat, PatType,\n    ReturnType, Signature, TraitItem, Type, WhereClause, WherePredicate,\n};\n\n/// Representation of single struct message\npub struct StructMessage\u003c'a\u003e {\n    contract_type: \u0026'a Type,\n    fields: Vec\u003cMsgField\u003c'a\u003e\u003e,\n    function_name: \u0026'a Ident,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n    unused_generics: Vec\u003c\u0026'a GenericParam\u003e,\n    wheres: Vec\u003c\u0026'a WherePredicate\u003e,\n    full_where: Option\u003c\u0026'a WhereClause\u003e,\n    result: \u0026'a ReturnType,\n    msg_attr: MsgAttr,\n}\n\nimpl\u003c'a\u003e StructMessage\u003c'a\u003e {\n    /// Creates new struct message of given type from impl block\n    pub fn new(\n        source: \u0026'a ItemImpl,\n        ty: MsgType,\n        generics: \u0026'a [\u0026'a GenericParam],\n    ) -\u003e Option\u003cStructMessage\u003c'a\u003e\u003e {\n        let mut generics_checker = CheckGenerics::new(generics);\n\n        let contract_type = \u0026source.self_ty;\n\n        let parsed = parse_struct_message(source, ty);\n        let Some((method, msg_attr)) = parsed else {\n            return None;\n        };\n\n        let function_name = \u0026method.sig.ident;\n        let fields = process_fields(\u0026method.sig, \u0026mut generics_checker);\n        let (used_generics, unused_generics) = generics_checker.used_unused();\n        let wheres = filter_wheres(\u0026source.generics.where_clause, generics, \u0026used_generics);\n\n        Some(Self {\n            contract_type,\n            fields,\n            function_name,\n            generics: used_generics,\n            unused_generics,\n            wheres,\n            full_where: source.generics.where_clause.as_ref(),\n            result: \u0026method.sig.output,\n            msg_attr,\n        })\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        use MsgAttr::*;\n\n        match \u0026self.msg_attr {\n            Instantiate { name } =\u003e self.emit_struct(name),\n            Migrate { name } =\u003e self.emit_struct(name),\n            _ =\u003e {\n                emit_error!(Span::mixed_site(), \"Invalid message type\");\n                quote! {}\n            }\n        }\n    }\n\n    pub fn emit_struct(\u0026self, name: \u0026Ident) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            contract_type,\n            fields,\n            function_name,\n            generics,\n            unused_generics,\n            wheres,\n            full_where,\n            result,\n            msg_attr,\n        } = self;\n\n        let where_clause = if !wheres.is_empty() {\n            quote! {\n                where #(#wheres,)*\n            }\n        } else {\n            quote! {}\n        };\n\n        let ctx_type = msg_attr.msg_type().emit_ctx_type();\n        let fields_names: Vec\u003c_\u003e = fields.iter().map(MsgField::name).collect();\n        let parameters = fields.iter().map(|field| {\n            let name = field.name;\n            let ty = field.ty;\n            quote! { #name : #ty}\n        });\n        let fields = fields.iter().map(MsgField::emit);\n\n        let generics = if generics.is_empty() {\n            quote! {}\n        } else {\n            quote! {\n                \u003c#(#generics,)*\u003e\n            }\n        };\n\n        let unused_generics = if unused_generics.is_empty() {\n            quote! {}\n        } else {\n            quote! {\n                \u003c#(#unused_generics,)*\u003e\n            }\n        };\n\n        quote! {\n            #[allow(clippy::derive_partial_eq_without_eq)]\n            #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n            #[serde(rename_all=\"snake_case\")]\n            pub struct #name #generics #where_clause {\n                #(pub #fields,)*\n            }\n\n            impl #generics #name #generics #where_clause {\n                pub fn new(#(#parameters,)*) -\u003e Self {\n                    Self { #(#fields_names,)* }\n                }\n\n                pub fn dispatch #unused_generics(self, contract: \u0026#contract_type, ctx: #ctx_type)\n                    #result #full_where\n                {\n                    let Self { #(#fields_names,)* } = self;\n                    contract.#function_name(Into::into(ctx), #(#fields_names,)*).map_err(Into::into)\n                }\n            }\n        }\n    }\n}\n\n/// Representation of single enum message\npub struct EnumMessage\u003c'a\u003e {\n    name: \u0026'a Ident,\n    trait_name: \u0026'a Ident,\n    variants: Vec\u003cMsgVariant\u003c'a\u003e\u003e,\n    generics: Vec\u003c\u0026'a GenericParam\u003e,\n    unused_generics: Vec\u003c\u0026'a GenericParam\u003e,\n    all_generics: \u0026'a [\u0026'a GenericParam],\n    wheres: Vec\u003c\u0026'a WherePredicate\u003e,\n    full_where: Option\u003c\u0026'a WhereClause\u003e,\n    msg_ty: MsgType,\n    args: \u0026'a InterfaceArgs,\n}\n\nimpl\u003c'a\u003e EnumMessage\u003c'a\u003e {\n    pub fn new(\n        name: \u0026'a Ident,\n        source: \u0026'a ItemTrait,\n        ty: MsgType,\n        generics: \u0026'a [\u0026'a GenericParam],\n        args: \u0026'a InterfaceArgs,\n    ) -\u003e Self {\n        let trait_name = \u0026source.ident;\n\n        let mut generics_checker = CheckGenerics::new(generics);\n        let variants: Vec\u003c_\u003e = source\n            .items\n            .iter()\n            .filter_map(|item| match item {\n                TraitItem::Method(method) =\u003e {\n                    let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n                    let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                        Ok(attr) =\u003e attr,\n                        Err(err) =\u003e {\n                            emit_error!(method.span(), err);\n                            return None;\n                        }\n                    };\n\n                    if attr == ty {\n                        Some(MsgVariant::new(\n                            \u0026method.sig,\n                            \u0026mut generics_checker,\n                            name,\n                            attr,\n                        ))\n                    } else {\n                        None\n                    }\n                }\n                _ =\u003e None,\n            })\n            .collect();\n\n        let (used_generics, unused_generics) = generics_checker.used_unused();\n        let wheres = filter_wheres(\u0026source.generics.where_clause, generics, \u0026used_generics);\n\n        Self {\n            name,\n            trait_name,\n            variants,\n            generics: used_generics,\n            unused_generics,\n            all_generics: generics,\n            wheres,\n            full_where: source.generics.where_clause.as_ref(),\n            msg_ty: ty,\n            args,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            name,\n            trait_name,\n            variants,\n            generics,\n            unused_generics,\n            all_generics,\n            wheres,\n            full_where,\n            msg_ty,\n            args,\n        } = self;\n\n        let match_arms = variants\n            .iter()\n            .map(|variant| variant.emit_dispatch_leg(*msg_ty));\n        let mut msgs: Vec\u003cString\u003e = variants\n            .iter()\n            .map(|var| var.name.to_string().to_case(Case::Snake))\n            .collect();\n        msgs.sort();\n        let msgs_cnt = msgs.len();\n        let variants_constructors = variants.iter().map(MsgVariant::emit_variants_constructors);\n        let variants = variants.iter().map(MsgVariant::emit);\n        let where_clause = if !wheres.is_empty() {\n            quote! {\n                where #(#wheres,)*\n            }\n        } else {\n            quote! {}\n        };\n\n        let ctx_type = msg_ty.emit_ctx_type();\n        let dispatch_type = msg_ty.emit_result_type(\u0026args.msg_type, \u0026parse_quote!(C::Error));\n\n        let all_generics = if all_generics.is_empty() {\n            quote! {}\n        } else {\n            quote! { \u003c#(#all_generics,)*\u003e }\n        };\n\n        let generics = if generics.is_empty() {\n            quote! {}\n        } else {\n            quote! { \u003c#(#generics,)*\u003e }\n        };\n\n        let unique_enum_name = Ident::new(\u0026format!(\"{}{}\", trait_name, name), name.span());\n\n        let enum_declaration = match name.to_string().as_str() {\n            \"QueryMsg\" =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema, cosmwasm_schema::QueryResponses)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #unique_enum_name #generics #where_clause {\n                    #(#variants,)*\n                }\n                pub type #name #generics = #unique_enum_name #generics;\n            },\n            _ =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #unique_enum_name #generics #where_clause {\n                    #(#variants,)*\n                }\n                pub type #name #generics = #unique_enum_name #generics;\n            },\n        };\n\n        quote! {\n            #enum_declaration\n\n            impl #generics #unique_enum_name #generics #where_clause {\n                pub fn dispatch\u003cC: #trait_name #all_generics, #(#unused_generics,)*\u003e(self, contract: \u0026C, ctx: #ctx_type)\n                    -\u003e #dispatch_type #full_where\n                {\n                    use #unique_enum_name::*;\n\n                    match self {\n                        #(#match_arms,)*\n                    }\n                }\n                pub const fn messages() -\u003e [\u0026'static str; #msgs_cnt] {\n                    [#(#msgs,)*]\n                }\n                #(#variants_constructors)*\n            }\n        }\n    }\n}\n\n/// Representation of single enum message\npub struct ContractEnumMessage\u003c'a\u003e {\n    name: \u0026'a Ident,\n    variants: Vec\u003cMsgVariant\u003c'a\u003e\u003e,\n    msg_ty: MsgType,\n    contract: \u0026'a Type,\n    error: \u0026'a Type,\n}\n\nimpl\u003c'a\u003e ContractEnumMessage\u003c'a\u003e {\n    pub fn new(\n        name: \u0026'a Ident,\n        source: \u0026'a ItemImpl,\n        ty: MsgType,\n        generics: \u0026'a [\u0026'a GenericParam],\n        error: \u0026'a Type,\n    ) -\u003e Self {\n        let mut generics_checker = CheckGenerics::new(generics);\n        let variants: Vec\u003c_\u003e = source\n            .items\n            .iter()\n            .filter_map(|item| match item {\n                ImplItem::Method(method) =\u003e {\n                    let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n                    let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                        Ok(attr) =\u003e attr,\n                        Err(err) =\u003e {\n                            emit_error!(method.span(), err);\n                            return None;\n                        }\n                    };\n\n                    if attr == ty {\n                        Some(MsgVariant::new(\n                            \u0026method.sig,\n                            \u0026mut generics_checker,\n                            name,\n                            attr,\n                        ))\n                    } else {\n                        None\n                    }\n                }\n                _ =\u003e None,\n            })\n            .collect();\n\n        Self {\n            name,\n            variants,\n            msg_ty: ty,\n            contract: \u0026source.self_ty,\n            error,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            name,\n            variants,\n            msg_ty,\n            contract,\n            error,\n        } = self;\n\n        let match_arms = variants\n            .iter()\n            .map(|variant| variant.emit_dispatch_leg(*msg_ty));\n        let mut msgs: Vec\u003cString\u003e = variants\n            .iter()\n            .map(|var| var.name.to_string().to_case(Case::Snake))\n            .collect();\n        msgs.sort();\n        let msgs_cnt = msgs.len();\n        let variants_constructors = variants.iter().map(MsgVariant::emit_variants_constructors);\n        let variants = variants.iter().map(MsgVariant::emit);\n\n        let ctx_type = msg_ty.emit_ctx_type();\n        let contract = StripGenerics.fold_type((*contract).clone());\n        let ret_type = msg_ty.emit_result_type(\u0026None, error);\n\n        let enum_declaration = match name.to_string().as_str() {\n            \"QueryMsg\" =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema, cosmwasm_schema::QueryResponses)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #name {\n                    #(#variants,)*\n                }\n            },\n            _ =\u003e quote! {\n                #[allow(clippy::derive_partial_eq_without_eq)]\n                #[derive(#sylvia ::serde::Serialize, #sylvia ::serde::Deserialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n                #[serde(rename_all=\"snake_case\")]\n                pub enum #name {\n                    #(#variants,)*\n                }\n            },\n        };\n\n        quote! {\n            #enum_declaration\n\n            impl #name {\n                pub fn dispatch(self, contract: \u0026#contract, ctx: #ctx_type) -\u003e #ret_type {\n                    use #name::*;\n\n                    match self {\n                        #(#match_arms,)*\n                    }\n                }\n                pub const fn messages() -\u003e [\u0026'static str; #msgs_cnt] {\n                    [#(#msgs,)*]\n                }\n\n                #(#variants_constructors)*\n            }\n        }\n    }\n}\n\n/// Representation of whole message variant\npub struct MsgVariant\u003c'a\u003e {\n    name: Ident,\n    function_name: \u0026'a Ident,\n    // With https://github.com/rust-lang/rust/issues/63063 this could be just an iterator over\n    // `MsgField\u003c'a\u003e`\n    fields: Vec\u003cMsgField\u003c'a\u003e\u003e,\n    return_type: TokenStream,\n    message_type: \u0026'a Ident,\n}\n\nimpl\u003c'a\u003e MsgVariant\u003c'a\u003e {\n    /// Creates new message variant from trait method\n    pub fn new(\n        sig: \u0026'a Signature,\n        generics_checker: \u0026mut CheckGenerics,\n        message_type: \u0026'a Ident,\n        msg_attr: MsgAttr,\n    ) -\u003e MsgVariant\u003c'a\u003e {\n        let function_name = \u0026sig.ident;\n\n        let name = Ident::new(\n            \u0026function_name.to_string().to_case(Case::UpperCamel),\n            function_name.span(),\n        );\n        let fields = process_fields(sig, generics_checker);\n\n        let return_type = if let MsgAttr::Query { resp_type } = msg_attr {\n            match resp_type {\n                Some(resp_type) =\u003e quote! {#resp_type},\n                None =\u003e {\n                    let return_type = extract_return_type(\u0026sig.output);\n                    quote! {#return_type}\n                }\n            }\n        } else {\n            quote! {}\n        };\n\n        Self {\n            name,\n            function_name,\n            fields,\n            return_type,\n            message_type,\n        }\n    }\n\n    /// Emits message variant\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self { name, fields, .. } = self;\n        let fields = fields.iter().map(MsgField::emit);\n        let return_type = \u0026self.return_type;\n\n        if self.message_type == \"QueryMsg\" {\n            quote! {\n                #[returns(#return_type)]\n                #name {\n                    #(#fields,)*\n                }\n            }\n        } else {\n            quote! {\n                #name {\n                    #(#fields,)*\n                }\n            }\n        }\n    }\n\n    /// Emits match leg dispatching against this variant. Assumes enum variants are imported into the\n    /// scope. Dispatching is performed by calling the function this variant is build from on the\n    /// `contract` variable, with `ctx` as its first argument - both of them should be in scope.\n    pub fn emit_dispatch_leg(\u0026self, msg_attr: MsgType) -\u003e TokenStream {\n        use MsgType::*;\n\n        let Self {\n            name,\n            fields,\n            function_name,\n            ..\n        } = self;\n        let args = fields\n            .iter()\n            .zip(1..)\n            .map(|(field, num)| Ident::new(\u0026format!(\"field{}\", num), field.name.span()));\n\n        let fields = fields\n            .iter()\n            .map(|field| field.name)\n            .zip(args.clone())\n            .map(|(field, num_field)| quote!(#field : #num_field));\n\n        match msg_attr {\n            Exec =\u003e quote! {\n                #name {\n                    #(#fields,)*\n                } =\u003e contract.#function_name(Into::into(ctx), #(#args),*).map_err(Into::into)\n            },\n            Query =\u003e quote! {\n                #name {\n                    #(#fields,)*\n                } =\u003e cosmwasm_std::to_binary(\u0026contract.#function_name(Into::into(ctx), #(#args),*)?).map_err(Into::into)\n            },\n            Instantiate | Migrate =\u003e {\n                emit_error!(name.span(), \"Instantiation and Migrate messages not supported on traits, they should be defined on contracts directly\");\n                quote! {}\n            }\n        }\n    }\n\n    /// Emits variants constructors. Constructors names are variants names in snake_case.\n    pub fn emit_variants_constructors(\u0026self) -\u003e TokenStream {\n        let Self { name, fields, .. } = self;\n\n        let method_name = name.to_string().to_case(Case::Snake);\n        let method_name = Ident::new(\u0026method_name, name.span());\n\n        let parameters = fields.iter().map(|field| {\n            let name = field.name;\n            let ty = field.ty;\n            quote! { #name : #ty}\n        });\n        let arguments = fields.iter().map(|field| field.name);\n\n        quote! {\n            pub fn #method_name( #(#parameters),*) -\u003e Self {\n                Self :: #name { #(#arguments),* }\n            }\n        }\n    }\n}\n\n/// Representation of single message variant field\npub struct MsgField\u003c'a\u003e {\n    name: \u0026'a Ident,\n    ty: \u0026'a Type,\n    attrs: \u0026'a Vec\u003cAttribute\u003e,\n}\n\nimpl\u003c'a\u003e MsgField\u003c'a\u003e {\n    /// Creates new field from trait method argument\n    pub fn new(item: \u0026'a PatType, generics_checker: \u0026mut CheckGenerics) -\u003e Option\u003cMsgField\u003c'a\u003e\u003e {\n        let name = match \u0026*item.pat {\n            Pat::Ident(p) =\u003e Some(\u0026p.ident),\n            pat =\u003e {\n                // TODO: Support pattern arguments, when decorated with argument with item\n                // name\n                //\n                // Eg.\n                //\n                // ```\n                // fn exec_foo(\u0026self, ctx: Ctx, #[msg(name=metadata)] SomeData { addr, sender }: SomeData);\n                // ```\n                //\n                // should expand to enum variant:\n                //\n                // ```\n                // ExecFoo {\n                //   metadata: SomeDaa\n                // }\n                // ```\n                emit_error!(pat.span(), \"Expected argument name, pattern occurred\");\n                None\n            }\n        }?;\n\n        let ty = \u0026item.ty;\n        let attrs = \u0026item.attrs;\n        generics_checker.visit_type(ty);\n\n        Some(Self { name, ty, attrs })\n    }\n\n    /// Emits message field\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self { name, ty, attrs } = self;\n\n        quote! {\n            #(#attrs)*\n            #name: #ty\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026'a Ident {\n        self.name\n    }\n}\n\n/// Glue message is the message composing Exec/Query messages from several traits\n#[derive(Debug)]\npub struct GlueMessage\u003c'a\u003e {\n    interfaces: Vec\u003cContractMessageAttr\u003e,\n    name: \u0026'a Ident,\n    contract: \u0026'a Type,\n    msg_ty: MsgType,\n    error: \u0026'a Type,\n}\n\nimpl\u003c'a\u003e GlueMessage\u003c'a\u003e {\n    #[cfg(not(tarpaulin_include))]\n    // Lack of coverage here is false negative due to usage in closures\n    fn merge_module_with_name(module: \u0026syn::Path, name: \u0026syn::Ident) -\u003e syn::Ident {\n        let segments = \u0026module.segments;\n        assert!(!segments.is_empty());\n\n        let syn::PathSegment { ident, .. } = \u0026segments[0];\n        let module_name = ident.to_string().to_case(Case::UpperCamel);\n        syn::Ident::new(\u0026format!(\"{}{}\", module_name, name), name.span())\n    }\n\n    pub fn new(name: \u0026'a Ident, source: \u0026'a ItemImpl, msg_ty: MsgType, error: \u0026'a Type) -\u003e Self {\n        let interfaces: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(|attr| {\n                let interface = match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e interface,\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        return None;\n                    }\n                };\n\n                Some(interface)\n            })\n            .collect();\n\n        GlueMessage {\n            interfaces,\n            name,\n            contract: \u0026source.self_ty,\n            msg_ty,\n            error,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let sylvia = crate_module();\n\n        let Self {\n            interfaces,\n            name,\n            contract,\n            msg_ty,\n            error,\n        } = self;\n        let contract = StripGenerics.fold_type((*contract).clone());\n        let contract_name = Ident::new(\u0026format!(\"Contract{}\", name), name.span());\n\n        let variants = interfaces.iter().map(|interface| {\n            let ContractMessageAttr {\n                module,\n                exec_generic_params,\n                query_generic_params,\n                variant,\n            } = interface;\n\n            let generics = match msg_ty {\n                MsgType::Exec =\u003e exec_generic_params.as_slice(),\n                MsgType::Query =\u003e query_generic_params.as_slice(),\n                _ =\u003e \u0026[],\n            };\n\n            let enum_name = GlueMessage::merge_module_with_name(module, name);\n            quote! { #variant(#module :: #enum_name\u003c#(#generics,)*\u003e) }\n        });\n\n        let msg_name = quote! {#contract ( #name)};\n        let mut interface_names: Vec\u003cTokenStream\u003e = interfaces\n            .iter()\n            .map(|interface| {\n                let ContractMessageAttr { module, .. } = interface;\n\n                let enum_name = GlueMessage::merge_module_with_name(module, name);\n                quote! { \u0026#module :: #enum_name :: messages()}\n            })\n            .collect();\n        interface_names.push(quote! {\u0026#name :: messages()});\n\n        let interfaces_cnt = interface_names.len();\n\n        let dispatch_arms = interfaces.iter().map(|interface| {\n            let ContractMessageAttr { variant, .. } = interface;\n\n            quote! { #contract_name :: #variant(msg) =\u003e msg.dispatch(contract, Into::into(ctx)) }\n        });\n\n        let dispatch_arm = quote! {#contract_name :: #contract (msg) =\u003emsg.dispatch(contract, ctx)};\n\n        let deserialization_attempts = interfaces.iter().map(|interface| {\n            let ContractMessageAttr {\n                module, variant, ..\n            } = interface;\n            let enum_name = GlueMessage::merge_module_with_name(module, name);\n            quote! {\n                let msgs = \u0026#module :: #enum_name ::messages();\n                if msgs.into_iter().any(|msg| msg == \u0026recv_msg_name) {\n                    match val.deserialize_into() {\n                        Ok(msg) =\u003e return Ok(Self:: #variant (msg)),\n                        Err(err) =\u003e return Err(D::Error::custom(err)).map(Self:: #variant),\n                    };\n                }\n            }\n        });\n\n        let contract_deserialization_attempt = quote! {\n            let msgs = \u0026#name :: messages();\n            if msgs.into_iter().any(|msg| msg == \u0026recv_msg_name) {\n                match val.deserialize_into() {\n                    Ok(msg) =\u003e return Ok(Self:: #contract (msg)),\n                    Err(err) =\u003e return Err(D::Error::custom(err)).map(Self:: #contract)\n                };\n            }\n        };\n\n        let ctx_type = msg_ty.emit_ctx_type();\n        let ret_type = msg_ty.emit_result_type(\u0026None, error);\n\n        let mut response_schemas: Vec\u003cTokenStream\u003e = interfaces\n            .iter()\n            .map(|interface| {\n                let ContractMessageAttr { module, .. } = interface;\n\n                let enum_name = GlueMessage::merge_module_with_name(module, name);\n                quote! { #module :: #enum_name :: response_schemas_impl()}\n            })\n            .collect();\n        response_schemas.push(quote! {#name :: response_schemas_impl()});\n\n        let response_schemas = match name.to_string().as_str() {\n            \"QueryMsg\" =\u003e {\n                quote! {\n                    #[cfg(not(target_arch = \"wasm32\"))]\n                    impl cosmwasm_schema::QueryResponses for #contract_name {\n                        fn response_schemas_impl() -\u003e std::collections::BTreeMap\u003cString, #sylvia ::schemars::schema::RootSchema\u003e {\n                            let responses = [#(#response_schemas),*];\n                            responses.into_iter().flatten().collect()\n                        }\n                    }\n                }\n            }\n            _ =\u003e {\n                quote! {}\n            }\n        };\n\n        quote! {\n            #[allow(clippy::derive_partial_eq_without_eq)]\n            #[derive(#sylvia ::serde::Serialize, Clone, Debug, PartialEq, #sylvia ::schemars::JsonSchema)]\n            #[serde(rename_all=\"snake_case\", untagged)]\n            pub enum #contract_name {\n                #(#variants,)*\n                #msg_name\n            }\n\n            impl #contract_name {\n                pub fn dispatch(\n                    self,\n                    contract: \u0026#contract,\n                    ctx: #ctx_type,\n                ) -\u003e #ret_type {\n                    const _: () = {\n                        let msgs: [\u0026[\u0026str]; #interfaces_cnt] = [#(#interface_names),*];\n                        #sylvia ::utils::assert_no_intersection(msgs);\n                    };\n\n                    match self {\n                        #(#dispatch_arms,)*\n                        #dispatch_arm\n                    }\n                }\n            }\n\n            #response_schemas\n\n            impl\u003c'de\u003e serde::Deserialize\u003c'de\u003e for #contract_name {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                    where D: serde::Deserializer\u003c'de\u003e,\n                {\n                    use serde::de::Error;\n\n                    let val = #sylvia ::serde_value::Value::deserialize(deserializer)?;\n                    let map = match \u0026val {\n                        #sylvia ::serde_value::Value::Map(map) =\u003e map,\n                        _ =\u003e panic!(\"Expected msg to be Value variant Map. Possibly an issue with msg format.\")\n                    };\n                    if map.len() != 1 {\n                        panic!(\"Found more or zero msgs after deserialization. Expected one.\")\n                    }\n                    // Due to earlier size check of map this unwrap is safe\n                    let recv_msg_name = map.into_iter().next().unwrap();\n\n                    if let #sylvia ::serde_value::Value::String(recv_msg_name) = \u0026recv_msg_name .0 {\n                        #(#deserialization_attempts)*\n                        #contract_deserialization_attempt\n                    }\n\n                    let msgs: [\u0026[\u0026str]; #interfaces_cnt] = [#(#interface_names),*];\n                    let mut err_msg = msgs.into_iter().flatten().fold(\n                        // It might be better to forward the error or serialization, but we just\n                        // deserialized it from JSON, not reason to expect failure here.\n                        format!(\n                            \"Unsupported message received: {}. Messages supported by this contract: \",\n                            #sylvia ::serde_json::to_string(\u0026val).unwrap_or_else(|_| String::new())\n                        ),\n                        |mut acc, message| acc + message + \", \",\n                    );\n                    err_msg.truncate(err_msg.len() - 2);\n                    Err(D::Error::custom(err_msg))\n                }\n            }\n        }\n    }\n}\n\npub struct EntryPoints {\n    name: Type,\n    error: Type,\n}\n\nimpl EntryPoints {\n    pub fn new(source: \u0026ItemImpl) -\u003e Self {\n        let sylvia = crate_module();\n        let name = StripGenerics.fold_type(*source.self_ty.clone());\n\n        let error = source\n            .attrs\n            .iter()\n            .find(|attr| attr.path.is_ident(\"error\"))\n            .and_then(\n                |attr| match ContractErrorAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(error) =\u003e Some(error.error),\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        None\n                    }\n                },\n            )\n            .unwrap_or_else(|| parse_quote! { #sylvia ::cw_std::StdError });\n\n        Self { name, error }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self { name, error } = self;\n        let sylvia = crate_module();\n\n        quote! {\n            pub mod entry_points {\n                use super::*;\n                const CONTRACT: #name = #name ::new();\n\n                #[#sylvia ::cw_std::entry_point]\n                pub fn instantiate(\n                    deps: #sylvia ::cw_std::DepsMut,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: InstantiateMsg,\n                ) -\u003e Result\u003c#sylvia ::cw_std::Response, #error\u003e {\n                    msg.dispatch(\u0026CONTRACT, (deps, env, info)).map_err(Into::into)\n                }\n\n                #[#sylvia ::cw_std::entry_point]\n                pub fn execute(\n                    deps: #sylvia ::cw_std::DepsMut,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: ContractExecMsg,\n                ) -\u003e Result\u003c#sylvia ::cw_std::Response, #error\u003e {\n                    msg.dispatch(\u0026CONTRACT, (deps, env, info)).map_err(Into::into)\n                }\n\n                #[#sylvia ::cw_std::entry_point]\n                pub fn query(deps: #sylvia ::cw_std::Deps, env: #sylvia ::cw_std::Env, msg: ContractQueryMsg) -\u003e Result\u003c#sylvia ::cw_std::Binary, #error\u003e {\n                    msg.dispatch(\u0026CONTRACT, (deps, env)).map_err(Into::into)\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":36,"address":[2390704,2392104,2392229],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":41,"address":[2390786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[2390845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[2390865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2390924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2391068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2391019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2391165,2391056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2391295,2391173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[2391375,2391485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[2391787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2391502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2391510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2391550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2391590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[2391630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[2391662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[2391730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[2391742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[2392256],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":71,"address":[2392286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2392499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2392533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2392339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2392476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2400835,2392576,2393277],"length":1,"stats":{"Line":1},"fn_name":"emit_struct"},{"line":82,"address":[2392631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2392644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2392659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[2392682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[2392697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[2392720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2392743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[2392766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[2392774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2392789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2392809,2393204,2392874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[2393206,2392902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[2392880,2393310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[2393363,2393296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[2393469,2393389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1224037,1223888],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":107,"address":[1223915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1223923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1223932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2393773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[2393936,2394389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[2393982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[2394028,2393963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[2394862,2394011,2394445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[2394470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[2394513,2394451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[2394919,2394499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[2402072,2402197,2400864],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":175,"address":[2400981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[2401030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[2401226,2401056,2401138],"length":1,"stats":{"Line":3},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[1224787,1224064,1224107],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":182,"address":[1224126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1224146,1225056,1225070,1224257,1224348],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":184,"address":[1224278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1224360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1224485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1224517,1224584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1224756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[1224870,1224993,1224458,1224855],"length":1,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[1224963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1224885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[1224889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1224893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1224897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1224866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1224240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[2401264,2401389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[2401579,2401469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[2401743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[2402240,2414664,2403695],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":225,"address":[2402293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[2402306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[2402321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[2402336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[2402359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[2402382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[2402405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[2402413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[2402436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[2402451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[2402476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[2402582,2402637,2402499],"length":1,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[1225155,1225120],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":243,"address":[2402668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1225221,1225184],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":247,"address":[2402808,2402891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[2402906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[2402945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[2403108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[2403271,2403622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[2403624,2403320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2403298,2403732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[2403714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[2403878,2403794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[2404211,2404671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[2404264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2404310,2404245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2404727,2405168,2404293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[2404752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[2404807,2404733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2404781,2405257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[2405672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[2405826,2405771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2405804,2408562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[2411214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[2414688,2415156],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":336,"address":[2414807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[2414889,2414971,2414817],"length":1,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1226083,1225360,1225403],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":341,"address":[1225422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[1225553,1226352,1225644,1226366,1225442],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":343,"address":[1225574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[1225656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[1225781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1225813,1225880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[1226052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[1225754,1226289,1226151,1226166],"length":1,"stats":{"Line":4},"fn_name":null},{"line":352,"address":[1226259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[1226181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[1226185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[1226189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[1226193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[1226162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[1225536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[2415074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[2415078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[2424285,2415184,2416898],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":376,"address":[2415231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[2415244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[2415252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[2415275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[2415298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[2415321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[2415424,2415479,2415341],"length":1,"stats":{"Line":3},"fn_name":null},{"line":388,"address":[1226416,1226451],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":389,"address":[2415510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[1226517,1226480],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":393,"address":[2415650,2415733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[2415748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[2415787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[2415950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[2416095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[2416211,2416121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[2416234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[2416378,2416306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[2416909,2416446,2416501],"length":1,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[2416479,2418980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[2421364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[2424304,2424694,2425779],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":461,"address":[2424365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[2424398,2424547,2424459],"length":1,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[2424630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[2424824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[2424836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[2424903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[2425366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[2425347,2425588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[2425596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[2424937,2424996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[2426961,2426390,2425872],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":492,"address":[2425910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[2425934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[2425992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[2425997,2426959,2427514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[2426401,2426060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[2426989,2426018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[2430411,2428747,2427520],"length":1,"stats":{"Line":1},"fn_name":"emit_dispatch_leg"},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[2427554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2427569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2427589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[2427601,2427631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[2427620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[1226701,1226656],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":529,"address":[2427684,2427772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[1227008,1227021],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":532,"address":[2427739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[1227062,1227040],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":535,"address":[2427795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2427838,2430426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[2427883,2428758,2428104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[2427928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[2428085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[2432662,2432464],"length":1,"stats":{"Line":1},"fn_name":"emit_variants_constructors"},{"line":555,"address":[2432495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[2432530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[2432737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[1227413,1227264],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":561,"address":[1227291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[1227299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[1227308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[1227453,1227440],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":567,"address":[2433202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[2434736],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":585,"address":[2434974,2435170,2434779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":586,"address":[2434799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[2434826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[2434834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[2434965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[2435054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[2435069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":611,"address":[2435077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[2435100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[2435200,2435521],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":618,"address":[2435225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[2435259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[2435552],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":627,"address":[2435557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[2436352],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":654,"address":[2436420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[1227486,1227472],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":658,"address":[1227536,1228038],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":659,"address":[1227582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[1227641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[1227746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[1227845,1227778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[1228015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[1227690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[2436536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[2436592,2437220,2459901],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":681,"address":[2436645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[2436658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[2436666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[2436681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[2436696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[2436711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[2436734,2436825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":691,"address":[2436920,2436840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":693,"address":[1228875,1228080,1228840],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[1228118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[1228130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[1228150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[1228170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[1228175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[1228237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[1228259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[1228209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[1228279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[1228303,1228365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[2437427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[2437856,2437715,2437798],"length":1,"stats":{"Line":3},"fn_name":null},{"line":714,"address":[1229227,1228896],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":715,"address":[1228926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[1228935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[1229012,1228958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[2437961,2437902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[2438219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":[1229264,1230094,1229553],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":726,"address":[1229305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[1229569,1229310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[2438375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[1233193,1231022,1230112],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[1230148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[1230165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[1230188,1230245,1231033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[2439203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[2442217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[2442295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[2442460,2442512,2442380],"length":1,"stats":{"Line":3},"fn_name":null},{"line":764,"address":[1233531,1233216],"length":1,"stats":{"Line":1},"fn_name":"{closure#4}"},{"line":765,"address":[1233246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[1233255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[1233278,1233337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[2442558,2442633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":773,"address":[2442848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[2442950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":775,"address":[2443005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[2445604,2442983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":790,"address":[2445658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":222,"coverable":426},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","multitest.rs"],"content":"use convert_case::{Case, Casing};\nuse proc_macro2::{Ident, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Parse, Parser};\nuse syn::spanned::Spanned;\nuse syn::{FnArg, GenericParam, ImplItem, ItemImpl, ItemTrait, Pat, PatType, Path, Type};\n\nuse crate::check_generics::CheckGenerics;\nuse crate::crate_module;\nuse crate::message::MsgField;\nuse crate::parser::{parse_struct_message, ContractMessageAttr, MsgAttr, MsgType};\nuse crate::utils::{extract_return_type, process_fields};\n\nstruct MessageSignature\u003c'a\u003e {\n    pub name: \u0026'a Ident,\n    pub params: Vec\u003cTokenStream\u003e,\n    pub arguments: Vec\u003c\u0026'a Ident\u003e,\n    pub msg_ty: MsgType,\n    pub return_type: TokenStream,\n}\n\npub struct MultitestHelpers\u003c'a\u003e {\n    messages: Vec\u003cMessageSignature\u003c'a\u003e\u003e,\n    error_type: TokenStream,\n    contract: \u0026'a Type,\n    is_trait: bool,\n    is_migrate: bool,\n    source: \u0026'a ItemImpl,\n    generics: \u0026'a [\u0026'a GenericParam],\n    contract_name: \u0026'a Ident,\n    proxy_name: Ident,\n}\n\nfn interface_name(source: \u0026ItemImpl) -\u003e \u0026Ident {\n    let trait_name = \u0026source.trait_;\n    let Some(trait_name) = trait_name else {unreachable!()};\n    let (_, Path { segments, .. }, _) = \u0026trait_name;\n    assert!(!segments.is_empty());\n\n    \u0026segments[0].ident\n}\n\nfn extract_contract_name(contract: \u0026Type) -\u003e \u0026Ident {\n    let Type::Path(type_path) = contract  else {\n            unreachable!()\n        };\n    let segments = \u0026type_path.path.segments;\n    assert!(!segments.is_empty());\n    let segment = \u0026segments[0];\n    \u0026segment.ident\n}\n\nimpl\u003c'a\u003e MultitestHelpers\u003c'a\u003e {\n    pub fn new(\n        source: \u0026'a ItemImpl,\n        is_trait: bool,\n        contract_error: \u0026'a Type,\n        generics: \u0026'a [\u0026'a GenericParam],\n    ) -\u003e Self {\n        let mut is_migrate = false;\n        let sylvia = crate_module();\n\n        let messages: Vec\u003c_\u003e = source\n            .items\n            .iter()\n            .filter_map(|item| match item {\n                ImplItem::Method(method) =\u003e {\n                    let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n                    let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                        Ok(attr) =\u003e attr,\n                        Err(err) =\u003e {\n                            emit_error!(method.span(), err);\n                            return None;\n                        }\n                    };\n                    let msg_ty = attr.msg_type();\n\n                    if msg_ty == MsgType::Migrate {\n                        is_migrate = true;\n                    } else if msg_ty != MsgType::Query \u0026\u0026 msg_ty != MsgType::Exec {\n                        return None;\n                    }\n                    let sig = \u0026method.sig;\n                    let return_type = if let MsgAttr::Query { resp_type } = attr {\n                        match resp_type {\n                            Some(resp_type) =\u003e quote! {#resp_type},\n                            None =\u003e {\n                                let return_type = extract_return_type(\u0026sig.output);\n                                quote! {#return_type}\n                            }\n                        }\n                    } else {\n                        quote! { #sylvia ::cw_multi_test::AppResponse }\n                    };\n\n                    let name = \u0026sig.ident;\n                    let params: Vec\u003c_\u003e = sig\n                        .inputs\n                        .iter()\n                        .skip(2)\n                        .filter_map(|arg| match arg {\n                            FnArg::Typed(ty) =\u003e {\n                                let name = match ty.pat.as_ref() {\n                                    Pat::Ident(ident) =\u003e \u0026ident.ident,\n                                    _ =\u003e return None,\n                                };\n                                let ty = \u0026ty.ty;\n                                Some(quote! {#name : #ty})\n                            }\n                            _ =\u003e None,\n                        })\n                        .collect();\n                    let arguments: Vec\u003c_\u003e = sig\n                        .inputs\n                        .iter()\n                        .skip(2)\n                        .filter_map(|arg| match arg {\n                            FnArg::Typed(item) =\u003e {\n                                let PatType { pat, .. } = item;\n                                let Pat::Ident(ident) = pat.as_ref() else {\n                                    unreachable!()\n                                };\n                                Some(\u0026ident.ident)\n                            }\n                            _ =\u003e None,\n                        })\n                        .collect();\n\n                    Some(MessageSignature {\n                        name,\n                        params,\n                        arguments,\n                        msg_ty,\n                        return_type,\n                    })\n                }\n                _ =\u003e None,\n            })\n            .collect();\n\n        let error_type = if is_trait {\n            let error_type: Vec\u003c_\u003e = source\n                .items\n                .iter()\n                .filter_map(|item| match item {\n                    ImplItem::Type(ty) if ty.ident == \"Error\" =\u003e {\n                        let ty = \u0026ty.ty;\n                        let segments = match ty {\n                            Type::Path(path) =\u003e \u0026path.path.segments,\n                            _ =\u003e {\n                                unreachable!();\n                            }\n                        };\n                        assert!(!segments.is_empty());\n\n                        Some(\u0026segments[0].ident)\n                    }\n                    _ =\u003e None,\n                })\n                .collect();\n\n            assert!(!error_type.is_empty());\n            let error_type = error_type[0];\n            quote! {#error_type}\n        } else {\n            quote! {#contract_error}\n        };\n\n        let contract = \u0026source.self_ty;\n        let contract_name = extract_contract_name(contract);\n\n        let proxy_name = if is_trait {\n            let interface_name = interface_name(source);\n            Ident::new(\u0026format!(\"{}Proxy\", interface_name), interface_name.span())\n        } else {\n            Ident::new(\u0026format!(\"{}Proxy\", contract_name), contract_name.span())\n        };\n\n        Self {\n            messages,\n            error_type,\n            contract,\n            is_trait,\n            is_migrate,\n            source,\n            generics,\n            contract_name,\n            proxy_name,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let Self {\n            messages,\n            error_type,\n            proxy_name,\n            source,\n            is_trait,\n            ..\n        } = self;\n        let sylvia = crate_module();\n\n        if *is_trait {\n            return self.impl_trait_on_proxy();\n        }\n\n        let messages = messages.iter().map(|msg| {\n            let MessageSignature {\n                name,\n                params,\n                arguments,\n                msg_ty,\n                return_type,\n            } = msg;\n            if msg_ty == \u0026MsgType::Exec {\n                quote! {\n                    #[track_caller]\n                    pub fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::ExecProxy::\u003c#error_type, ExecMsg\u003e {\n                        let msg = ExecMsg:: #name ( #(#arguments),* );\n\n                        #sylvia ::multitest::ExecProxy::new(\u0026self.contract_addr, msg, \u0026self.app)\n                    }\n                }\n            } else if msg_ty == \u0026MsgType::Migrate {\n                quote! {\n                    #[track_caller]\n                    pub fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::MigrateProxy::\u003c#error_type, MigrateMsg\u003e {\n                        let msg = MigrateMsg::new( #(#arguments),* );\n\n                        #sylvia ::multitest::MigrateProxy::new(\u0026self.contract_addr, msg, \u0026self.app)\n                    }\n                }\n            } else {\n                quote! {\n                    pub fn #name (\u0026self, #(#params,)* ) -\u003e Result\u003c#return_type, #error_type\u003e {\n                        let msg = QueryMsg:: #name ( #(#arguments),* );\n\n                        self.app\n                            .app\n                            .borrow()\n                            .wrap()\n                            .query_wasm_smart(self.contract_addr.clone(), \u0026msg)\n                            .map_err(Into::into)\n                    }\n                }\n            }\n        });\n\n        let contract_block = self.generate_contract_helpers();\n\n        let interfaces: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(|attr| {\n                let interface = match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e {\n                        let ContractMessageAttr { module, .. } = interface;\n                        assert!(!module.segments.is_empty());\n                        let module_name = \u0026module.segments[0].ident;\n                        let method_name = Ident::new(\u0026format!(\"{}_proxy\", module_name), module_name.span());\n                        let proxy_name = Ident::new(\n                            \u0026format!(\"{}Proxy\", module_name.to_string().to_case(Case::UpperCamel)),\n                            module_name.span(),\n                        );\n\n                        quote! {\n                            pub fn #method_name (\u0026self) -\u003e #module ::trait_utils:: #proxy_name \u003c'app\u003e {\n                                #module ::trait_utils:: #proxy_name ::new(self.contract_addr.clone(), self.app)\n                            }\n                        }\n                    }\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        return None;\n                    }\n                };\n\n                Some(interface)\n            })\n            .collect();\n\n        quote! {\n            pub mod multitest_utils {\n                use super::*;\n                use #sylvia ::cw_multi_test::Executor;\n                use #sylvia ::derivative::Derivative;\n\n                #[derive(Derivative)]\n                #[derivative(Debug)]\n                pub struct #proxy_name \u003c'app\u003e {\n                    pub contract_addr: #sylvia ::cw_std::Addr,\n                    #[derivative(Debug=\"ignore\")]\n                    pub app: \u0026'app #sylvia ::multitest::App,\n                }\n\n                impl\u003c'app\u003e #proxy_name \u003c'app\u003e {\n                    pub fn new(contract_addr: #sylvia ::cw_std::Addr, app: \u0026'app #sylvia ::multitest::App) -\u003e Self {\n                        #proxy_name{ contract_addr, app }\n                    }\n\n                    #(#messages)*\n\n                    #(#interfaces)*\n                }\n\n                impl\u003c'app\u003e From\u003c(#sylvia ::cw_std::Addr, \u0026'app #sylvia ::multitest::App)\u003e for #proxy_name\u003c'app\u003e {\n                    fn from(input: (#sylvia ::cw_std::Addr, \u0026'app #sylvia ::multitest::App)) -\u003e #proxy_name\u003c'app\u003e {\n                        #proxy_name::new(input.0, input.1)\n                    }\n                }\n\n                #contract_block\n            }\n        }\n    }\n\n    fn impl_trait_on_proxy(\u0026self) -\u003e TokenStream {\n        let Self {\n            messages,\n            error_type,\n            source,\n            ..\n        } = self;\n\n        let sylvia = crate_module();\n\n        let interface_name = interface_name(self.source);\n        let proxy_name = \u0026self.proxy_name;\n        let trait_name = Ident::new(\u0026format!(\"{}\", interface_name), interface_name.span());\n\n        let modules: Vec\u003c_\u003e = source\n            .attrs\n            .iter()\n            .filter(|attr| attr.path.is_ident(\"messages\"))\n            .filter_map(\n                |attr| match ContractMessageAttr::parse.parse2(attr.tokens.clone()) {\n                    Ok(interface) =\u003e {\n                        let ContractMessageAttr { module, .. } = \u0026interface;\n                        assert!(!module.segments.is_empty());\n                        Some(module.segments[0].ident.clone())\n                    }\n                    Err(err) =\u003e {\n                        emit_error!(attr.span(), err);\n                        None\n                    }\n                },\n            )\n            .collect();\n\n        let module = match modules.len() {\n            0 =\u003e {\n                quote! {}\n            }\n            1 =\u003e {\n                let module = \u0026modules[0];\n                quote! {#module ::}\n            }\n            _ =\u003e {\n                emit_error!(\n                    source.span(),\n                    \"Only one #[messages] attribute is allowed per contract\"\n                );\n                return quote! {};\n            }\n        };\n        let methods_definitions = messages.iter().map(|msg| {\n            let MessageSignature {\n                name,\n                params,\n                arguments,\n                msg_ty,\n                return_type,\n            } = msg;\n            if msg_ty == \u0026MsgType::Exec {\n                quote! {\n                    #[track_caller]\n                    fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::ExecProxy::\u003c#error_type, #module ExecMsg\u003e {\n                        let msg = #module ExecMsg:: #name ( #(#arguments),* );\n\n                        #sylvia ::multitest::ExecProxy::new(\u0026self.contract_addr, msg, \u0026self.app)\n                    }\n                }\n            } else {\n                quote! {\n                    fn #name (\u0026self, #(#params,)* ) -\u003e Result\u003c#return_type, #error_type\u003e {\n                        let msg = #module QueryMsg:: #name ( #(#arguments),* );\n\n                        self.app\n                            .app\n                            .borrow()\n                            .wrap()\n                            .query_wasm_smart(self.contract_addr.clone(), \u0026msg)\n                            .map_err(Into::into)\n                    }\n                }\n            }\n        });\n\n        let methods_declarations = messages.iter().map(|msg| {\n            let MessageSignature {\n                name,\n                params,\n                msg_ty,\n                return_type,\n                ..\n            } = msg;\n            if msg_ty == \u0026MsgType::Exec {\n                quote! {\n                    fn #name (\u0026self, #(#params,)* ) -\u003e #sylvia ::multitest::ExecProxy::\u003c#error_type, #module ExecMsg\u003e;\n                }\n            } else {\n                quote! {\n                    fn #name (\u0026self, #(#params,)* ) -\u003e Result\u003c#return_type, #error_type\u003e;\n                }\n            }\n        });\n\n        quote! {\n            pub mod test_utils {\n                use super::*;\n\n                pub trait #trait_name {\n                    #(#methods_declarations)*\n                }\n\n                impl #trait_name for #module trait_utils:: #proxy_name\u003c'_\u003e {\n                    #(#methods_definitions)*\n                }\n            }\n        }\n    }\n\n    fn generate_contract_helpers(\u0026self) -\u003e TokenStream {\n        let Self {\n            error_type,\n            is_trait,\n            source,\n            generics,\n            contract_name,\n            proxy_name,\n            ..\n        } = self;\n\n        if *is_trait {\n            return quote! {};\n        }\n\n        let sylvia = crate_module();\n\n        let mut generics_checker = CheckGenerics::new(generics);\n\n        let parsed = parse_struct_message(source, MsgType::Instantiate);\n        let Some((method,_)) = parsed else {\n            return quote! {};\n        };\n\n        let instantiate_fields = process_fields(\u0026method.sig, \u0026mut generics_checker);\n        let fields_names: Vec\u003c_\u003e = instantiate_fields.iter().map(MsgField::name).collect();\n        let fields = instantiate_fields.iter().map(MsgField::emit);\n\n        let impl_contract = self.generate_impl_contract();\n\n        quote! {\n            #impl_contract\n\n            pub struct CodeId\u003c'app\u003e {\n                code_id: u64,\n                app: \u0026'app #sylvia ::multitest::App,\n            }\n\n            impl\u003c'app\u003e CodeId\u003c'app\u003e {\n                pub fn store_code(app: \u0026'app #sylvia ::multitest::App) -\u003e Self {\n                    let code_id = app\n                        .app\n                        .borrow_mut()\n                        .store_code(Box::new(#contract_name ::new()));\n                    Self { code_id, app }\n                }\n\n                pub fn code_id(\u0026self) -\u003e u64 {\n                    self.code_id\n                }\n\n                pub fn instantiate(\n                    \u0026self, #(#fields,)*\n                ) -\u003e InstantiateProxy\u003c'_, 'app\u003e {\n                    let msg = InstantiateMsg {#(#fields_names,)*};\n                    InstantiateProxy {\n                        code_id: self,\n                        funds: \u0026[],\n                        label: \"Contract\",\n                        admin: None,\n                        msg,\n                    }\n                }\n            }\n\n            pub struct InstantiateProxy\u003c'a, 'app\u003e {\n                code_id: \u0026'a CodeId \u003c'app\u003e,\n                funds: \u0026'a [#sylvia ::cw_std::Coin],\n                label: \u0026'a str,\n                admin: Option\u003cString\u003e,\n                msg: InstantiateMsg,\n            }\n\n            impl\u003c'a, 'app\u003e InstantiateProxy\u003c'a, 'app\u003e {\n                pub fn with_funds(self, funds: \u0026'a [#sylvia ::cw_std::Coin]) -\u003e Self {\n                    Self { funds, ..self }\n                }\n\n                pub fn with_label(self, label: \u0026'a str) -\u003e Self {\n                    Self { label, ..self }\n                }\n\n                pub fn with_admin\u003c's\u003e(self, admin: impl Into\u003cOption\u003c\u0026's str\u003e\u003e) -\u003e Self {\n                    let admin = admin.into().map(str::to_owned);\n                    Self { admin, ..self }\n                }\n\n                #[track_caller]\n                pub fn call(self, sender: \u0026str) -\u003e Result\u003c#proxy_name\u003c'app\u003e, #error_type\u003e {\n                    self.code_id\n                        .app\n                        .app\n                        .borrow_mut()\n                        .instantiate_contract(\n                            self.code_id.code_id,\n                            #sylvia ::cw_std::Addr::unchecked(sender),\n                            \u0026self.msg,\n                            self.funds,\n                            self.label,\n                            self.admin,\n                        )\n                        .map_err(|err| err.downcast().unwrap())\n                        .map(|addr| #proxy_name {\n                            contract_addr: addr,\n                            app: self.code_id.app,\n                        })\n                }\n            }\n        }\n    }\n\n    fn generate_impl_contract(\u0026self) -\u003e TokenStream {\n        let contract = \u0026self.contract;\n        let sylvia = crate_module();\n\n        // MigrateMsg is not generated all the time in contrary to Exec, Query and Instantiate.\n        let migrate_body = if self.is_migrate {\n            quote! {\n                #sylvia ::cw_std::from_slice::\u003cMigrateMsg\u003e(\u0026msg)?\n                    .dispatch(self, (deps, env).into())\n                    .map_err(Into::into)\n            }\n        } else {\n            quote! {\n                #sylvia ::anyhow::bail!(\"migrate not implemented for contract\")\n            }\n        };\n        quote! {\n            impl #sylvia ::cw_multi_test::Contract\u003c#sylvia ::cw_std::Empty\u003e for #contract {\n                fn execute(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::cw_std::from_slice::\u003cContractExecMsg\u003e(\u0026msg)?\n                        .dispatch(self, (deps, env, info))\n                        .map_err(Into::into)\n                }\n\n                fn instantiate(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    info: #sylvia ::cw_std::MessageInfo,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::cw_std::from_slice::\u003cInstantiateMsg\u003e(\u0026msg)?\n                        .dispatch(self, (deps, env, info))\n                        .map_err(Into::into)\n                }\n\n                fn query(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::Deps\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Binary\u003e {\n                    #sylvia ::cw_std::from_slice::\u003cContractQueryMsg\u003e(\u0026msg)?\n                        .dispatch(self, (deps, env))\n                        .map_err(Into::into)\n                }\n\n                fn sudo(\n                    \u0026self,\n                    _deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    _env: #sylvia ::cw_std::Env,\n                    _msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::anyhow::bail!(\"sudo not implemented for contract\")\n                }\n\n                fn reply(\n                    \u0026self,\n                    _deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    _env: #sylvia ::cw_std::Env,\n                    _msg: #sylvia ::cw_std::Reply,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #sylvia ::anyhow::bail!(\"reply not implemented for contract\")\n                }\n\n                fn migrate(\n                    \u0026self,\n                    deps: #sylvia ::cw_std::DepsMut\u003c#sylvia ::cw_std::Empty\u003e,\n                    env: #sylvia ::cw_std::Env,\n                    msg: Vec\u003cu8\u003e,\n                ) -\u003e #sylvia ::anyhow::Result\u003c#sylvia ::cw_std::Response\u003c#sylvia ::cw_std::Empty\u003e\u003e {\n                    #migrate_body\n                }\n            }\n        }\n    }\n}\n\npub struct TraitMultitestHelpers\u003c'a\u003e {\n    trait_name: \u0026'a Ident,\n}\n\nimpl\u003c'a\u003e TraitMultitestHelpers\u003c'a\u003e {\n    pub fn new(source: \u0026'a ItemTrait) -\u003e Self {\n        Self {\n            trait_name: \u0026source.ident,\n        }\n    }\n\n    pub fn emit(\u0026self) -\u003e TokenStream {\n        let trait_name = self.trait_name;\n        let sylvia = crate_module();\n        let proxy_name = Ident::new(\u0026format!(\"{}Proxy\", trait_name), trait_name.span());\n\n        quote! {\n            pub mod trait_utils {\n                pub struct #proxy_name \u003c'app\u003e {\n                    pub contract_addr: #sylvia ::cw_std::Addr,\n                    pub app: \u0026'app #sylvia ::multitest::App,\n                }\n                impl\u003c'app\u003e #proxy_name \u003c'app\u003e {\n                    pub fn new(contract_addr: #sylvia ::cw_std::Addr, app: \u0026'app #sylvia ::multitest::App) -\u003e Self {\n                        #proxy_name { contract_addr, app }\n                    }\n                }\n                impl Into\u003c#sylvia ::cw_std::Addr\u003e for #proxy_name \u003c'_\u003e {\n                    fn into(self) -\u003e #sylvia ::cw_std::Addr {\n                        self.contract_addr\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":35,"address":[442960],"length":1,"stats":{"Line":1},"fn_name":"interface_name"},{"line":36,"address":[442974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[443041,442979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[443010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[443025,443102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[443076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[443136],"length":1,"stats":{"Line":1},"fn_name":"extract_contract_name"},{"line":45,"address":[443150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[443220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[443190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[443204,443286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[443255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[443277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[443328,444188,445570],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":61,"address":[443425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[443441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[443454,443616,443545],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[443592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[1241829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1241849,1244384,1242072,1244398,1241978],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":70,"address":[1242002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1242079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1242210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1242242,1242309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1242481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1242191,1242586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1242593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1242660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[1242708,1242629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[1242778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[1242671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1242688,1242800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[1242872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1243234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1243215,1243456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[1243464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1242906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1243166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1243690,1243186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[1244483,1244448,1244816],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":103,"address":[1244509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1244517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[1244575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1244640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1244592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[1244649,1244601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1244545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1243748,1243830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1244848,1244867],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":119,"address":[1244893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1244898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1244907,1244950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1244966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1244959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1244926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1244060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1243893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1243941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1243989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1243996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[1241958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[443677,444384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[443800,443713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1245008,1245027],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":147,"address":[1245038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1245093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1245115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[1245147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1245185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[1245247,1245169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1245219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1245079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[443901,443962,444004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[443970,444044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[444055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[444249,443683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[444207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[444448,444227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[444456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[444500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[444525,444765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[445493,445293,444460],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[447206,453157,445600],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[445636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[445659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[445667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[445682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[445705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[445720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[445741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[445788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[445758,445879],"length":1,"stats":{"Line":3},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[1245343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1245358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1245381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1245404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1245419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[1245427,1247950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[1245749,1245484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1250458,1245451,1252997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[1248042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1247983,1250463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[445985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[446082,446000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1253008,1253022],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":256,"address":[1253072,1253733],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":257,"address":[1253130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1253193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[1253321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[1253869,1253826,1253369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1253834,1253906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1253918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1254826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1254277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1254790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1254908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1253406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1253438,1253511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1253710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1256494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[446241,447217,446182],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[457084,453184,453751],"length":1,"stats":{"Line":1},"fn_name":"impl_trait_on_proxy"},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[453223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[453246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[453254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[453282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[453295,453374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[453382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[453394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[453814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[1256624,1256638],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":338,"address":[1256734,1256688,1257242],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":339,"address":[1256794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1256926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[1257362,1256934,1257322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1257335,1257399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1256957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1256983,1257050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1257222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[453996,454053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[454617,454100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[454122,454415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[454423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[454081,454167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[454160,454089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[454335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[454673,454600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1257535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[1257550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[1257573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[1257596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1257611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1262715,1257619,1260151],"length":1,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[1257961,1257702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[1260184,1257643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[454779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1262758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[1262770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[1262790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[1262802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[1263723,1262807,1264432],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[1263392,1262881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[1262828,1263753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[454902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[457104,472592,458844],"length":1,"stats":{"Line":1},"fn_name":"generate_contract_helpers"},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[457143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[457151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[457168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[457191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[457214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[457229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[457244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[457399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[457265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[1264448,1264467],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":457,"address":[457356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[457369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[457473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[457544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[457621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[457586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[457808,457729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[457891,457958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[458060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[458855,458130,458067],"length":1,"stats":{"Line":3},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[472608,473158,488945],"length":1,"stats":{"Line":1},"fn_name":"generate_impl_contract"},{"line":554,"address":[472638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[472647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[472662,474481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":559,"address":[472750,473169,472693],"length":1,"stats":{"Line":3},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[474073,472671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[474532,474059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[488960],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":644,"address":[488969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[493043,488992,489383],"length":1,"stats":{"Line":1},"fn_name":"emit"},{"line":649,"address":[489017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[489030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[489035,489112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[489443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":160,"coverable":411},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","parser.rs"],"content":"use proc_macro2::{Punct, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Error, Nothing, Parse, ParseBuffer, ParseStream, Parser};\nuse syn::spanned::Spanned;\nuse syn::{parenthesized, Ident, ImplItem, ImplItemMethod, ItemImpl, Path, Result, Token, Type};\n\nuse crate::crate_module;\n\n/// Parsed arguments for `interface` macro\npub struct InterfaceArgs {\n    /// Module name wrapping generated messages, by default no additional module is created\n    pub module: Option\u003cIdent\u003e,\n    /// The type being a parameter of `CosmosMsg` for blockchain it is intendet to be used; can be\n    /// set to any of generic parameters to create interface being generic over blockchains; If not\n    /// provided, cosmos messages would be unparametrized (so default would be used)\n    pub msg_type: Option\u003cType\u003e,\n}\n\n/// Parser arguments for `contract` macro\npub struct ContractArgs {\n    /// Module name wrapping generated messages, by default no additional module is created\n    pub module: Option\u003cIdent\u003e,\n}\n\nimpl Parse for InterfaceArgs {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let mut module = None;\n        let mut msg_type = None;\n\n        while !input.is_empty() {\n            let attr: Ident = input.parse()?;\n            let _: Token![=] = input.parse()?;\n\n            if attr == \"module\" {\n                module = Some(input.parse()?);\n            } else if attr == \"msg_type\" {\n                msg_type = Some(input.parse()?);\n            } else {\n                return Err(Error::new(attr.span(), \"expected `module`, or `msg_type`\"));\n            }\n\n            if input.peek(Token![,]) {\n                let _: Token![,] = input.parse()?;\n            } else if !input.is_empty() {\n                return Err(input.error(\"Unexpected token, comma expected\"));\n            }\n        }\n\n        let _: Nothing = input.parse()?;\n\n        Ok(InterfaceArgs { module, msg_type })\n    }\n}\n\nimpl Parse for ContractArgs {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let mut module = None;\n\n        while !input.is_empty() {\n            let attr: Ident = input.parse()?;\n            let _: Token![=] = input.parse()?;\n\n            if attr == \"module\" {\n                module = Some(input.parse()?);\n            } else {\n                return Err(Error::new(attr.span(), \"expected `module`\"));\n            }\n\n            if input.peek(Token![,]) {\n                let _: Token![,] = input.parse()?;\n            } else if !input.is_empty() {\n                return Err(input.error(\"Unexpected token, comma expected\"));\n            }\n        }\n\n        let _: Nothing = input.parse()?;\n\n        Ok(ContractArgs { module })\n    }\n}\n\n/// Type of message to be generated\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\npub enum MsgType {\n    Exec,\n    Query,\n    Instantiate,\n    Migrate,\n}\n\n/// `#[msg(...)]` attribute for `interface` macro\npub enum MsgAttr {\n    Exec,\n    Query { resp_type: Option\u003cIdent\u003e },\n    Instantiate { name: Ident },\n    Migrate { name: Ident },\n}\n\nimpl MsgType {\n    pub fn emit_ctx_type(self) -\u003e TokenStream {\n        use MsgType::*;\n\n        let sylvia = crate_module();\n\n        match self {\n            Exec | Instantiate =\u003e quote! {\n                (#sylvia ::cw_std::DepsMut, #sylvia ::cw_std::Env, #sylvia ::cw_std::MessageInfo)\n            },\n            Migrate =\u003e quote! {\n                (#sylvia ::cw_std::DepsMut, #sylvia ::cw_std::Env)\n            },\n            Query =\u003e quote! {\n                (#sylvia ::cw_std::Deps, #sylvia ::cw_std::Env)\n            },\n        }\n    }\n\n    /// Emits type which should be returned by dispatch function for this kind of message\n    pub fn emit_result_type(self, msg_type: \u0026Option\u003cType\u003e, err_type: \u0026Type) -\u003e TokenStream {\n        use MsgType::*;\n\n        let sylvia = crate_module();\n\n        match (self, msg_type) {\n            (Exec, Some(msg_type)) | (Instantiate, Some(msg_type)) | (Migrate, Some(msg_type)) =\u003e {\n                quote! {\n                    std::result::Result\u003c#sylvia ::cw_std::Response\u003c#msg_type\u003e, #err_type\u003e\n                }\n            }\n            (Exec, None) | (Instantiate, None) | (Migrate, None) =\u003e quote! {\n                std::result::Result\u003c#sylvia ::cw_std::Response, #err_type\u003e\n            },\n\n            (Query, _) =\u003e quote! {\n                std::result::Result\u003c#sylvia ::cw_std::Binary, #err_type\u003e\n            },\n        }\n    }\n}\n\nimpl PartialEq\u003cMsgType\u003e for MsgAttr {\n    fn eq(\u0026self, other: \u0026MsgType) -\u003e bool {\n        self.msg_type() == *other\n    }\n}\n\nimpl MsgAttr {\n    fn parse_query(content: ParseBuffer) -\u003e Result\u003cSelf\u003e {\n        if content.peek2(Ident) {\n            let _: Punct = content.parse()?;\n            let _: Ident = content.parse()?;\n            let _: Punct = content.parse()?;\n            let resp_type: Option\u003cIdent\u003e = Some(content.parse()?);\n            Ok(Self::Query { resp_type })\n        } else {\n            Ok(Self::Query { resp_type: None })\n        }\n    }\n\n    pub fn msg_type(\u0026self) -\u003e MsgType {\n        use MsgAttr::*;\n\n        match self {\n            Exec =\u003e MsgType::Exec,\n            Query { .. } =\u003e MsgType::Query,\n            Instantiate { .. } =\u003e MsgType::Instantiate,\n            Migrate { .. } =\u003e MsgType::Migrate,\n        }\n    }\n}\n\nimpl Parse for MsgAttr {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let content;\n        parenthesized!(content in input);\n\n        let ty: Ident = content.parse()?;\n        if ty == \"exec\" {\n            Ok(Self::Exec)\n        } else if ty == \"query\" {\n            Self::parse_query(content)\n        } else if ty == \"instantiate\" {\n            let name = Ident::new(\"InstantiateMsg\", content.span());\n            Ok(Self::Instantiate { name })\n        } else if ty == \"migrate\" {\n            let name = Ident::new(\"MigrateMsg\", content.span());\n            Ok(Self::Migrate { name })\n        } else {\n            Err(Error::new(\n                ty.span(),\n                \"Invalid message type, expected one of: `exec`, `query`, `instantiate`, `migrate`\",\n            ))\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct ContractErrorAttr {\n    pub error: Type,\n}\n\n#[cfg(not(tarpaulin_include))]\n// False negative. It is being called in closure\nimpl Parse for ContractErrorAttr {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let content;\n        parenthesized!(content in input);\n\n        content.parse().map(|error| Self { error })\n    }\n}\n\n#[derive(Debug)]\npub struct ContractMessageAttr {\n    pub module: Path,\n    pub exec_generic_params: Vec\u003cPath\u003e,\n    pub query_generic_params: Vec\u003cPath\u003e,\n    pub variant: Ident,\n}\n\n#[cfg(not(tarpaulin_include))]\n// False negative. Called in function below\nfn parse_generics(content: \u0026ParseBuffer) -\u003e Result\u003cVec\u003cPath\u003e\u003e {\n    let _: Token![\u003c] = content.parse()?;\n    let mut params = vec![];\n\n    loop {\n        let param: Path = content.parse()?;\n        params.push(param);\n\n        let generics_close: Option\u003cToken![\u003e]\u003e = content.parse()?;\n        if generics_close.is_some() {\n            break;\n        }\n\n        let comma: Option\u003cToken![,]\u003e = content.parse()?;\n        if comma.is_none() {\n            return Err(Error::new(content.span(), \"Expected comma or `\u003e`\"));\n        }\n    }\n\n    Ok(params)\n}\n\n#[cfg(not(tarpaulin_include))]\n// False negative. It is being called in closure\nimpl Parse for ContractMessageAttr {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let content;\n        parenthesized!(content in input);\n\n        let module = content.parse()?;\n\n        let generics_open: Option\u003cToken![:]\u003e = content.parse()?;\n        let mut exec_generic_params = vec![];\n        let mut query_generic_params = vec![];\n\n        if generics_open.is_some() {\n            loop {\n                let ty: Ident = content.parse()?;\n                let params = if ty == \"exec\" {\n                    \u0026mut exec_generic_params\n                } else if ty == \"query\" {\n                    \u0026mut query_generic_params\n                } else {\n                    return Err(Error::new(ty.span(), \"Invalid message type\"));\n                };\n\n                *params = parse_generics(\u0026content)?;\n\n                if content.peek(Token![as]) {\n                    break;\n                }\n\n                let _: Token![,] = content.parse()?;\n            }\n        }\n\n        let _: Token![as] = content.parse()?;\n\n        let variant = content.parse()?;\n\n        if !content.is_empty() {\n            return Err(Error::new(\n                content.span(),\n                \"Unexpected token on the end of `message` attribtue\",\n            ));\n        }\n\n        Ok(Self {\n            module,\n            exec_generic_params,\n            query_generic_params,\n            variant,\n        })\n    }\n}\n\npub fn parse_struct_message(source: \u0026ItemImpl, ty: MsgType) -\u003e Option\u003c(\u0026ImplItemMethod, MsgAttr)\u003e {\n    let mut methods = source.items.iter().filter_map(|item| match item {\n        ImplItem::Method(method) =\u003e {\n            let msg_attr = method.attrs.iter().find(|attr| attr.path.is_ident(\"msg\"))?;\n            let attr = match MsgAttr::parse.parse2(msg_attr.tokens.clone()) {\n                Ok(attr) =\u003e attr,\n                Err(err) =\u003e {\n                    emit_error!(method.span(), err);\n                    return None;\n                }\n            };\n\n            if attr == ty {\n                Some((method, attr))\n            } else {\n                None\n            }\n        }\n        _ =\u003e None,\n    });\n\n    let (method, msg_attr) = if let Some(method) = methods.next() {\n        method\n    } else {\n        if ty == MsgType::Instantiate {\n            emit_error!(source.span(), \"No instantiation message\");\n        }\n        return None;\n    };\n\n    if let Some((obsolete, _)) = methods.next() {\n        emit_error!(\n            obsolete.span(), \"More than one instantiation or migration message\";\n            note = method.span() =\u003e \"Instantiation/Migration message previously defined here\"\n        );\n    }\n    Some((method, msg_attr))\n}\n","traces":[{"line":32,"address":[334781,332368,334370],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":33,"address":[332398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[332403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[332417,332477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[332511,332678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[332651,332829,332934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[333048,333929,332899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[333092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[333054,333532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[333569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[334286,333538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[333510,333938,334061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[334068,333972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[333949,334185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[334198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[332496,334639,334397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[334437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[337385,334816,335085],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":63,"address":[334846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[334851,334911,335096],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[335103,335163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[335364,335197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[335337,335620,335515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[335585,336585,335734],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[335778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[335740,336218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[336255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[336224,336942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[336717,336594,336196],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[336628,336724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[336605,336841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[336854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[337281,335182,337042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[337082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[337424,338035,339247],"length":1,"stats":{"Line":1},"fn_name":"emit_ctx_type"},{"line":112,"address":[337453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[337458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[338625,337491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[337532,337592,338051],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[338122,337510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[340014,340941,339264],"length":1,"stats":{"Line":1},"fn_name":"emit_result_type"},{"line":131,"address":[339317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[340059,339426,339541,339331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[339531,339502,340049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[339512,340064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[339480,340505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[339584,339404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[340960],"length":1,"stats":{"Line":1},"fn_name":"eq"},{"line":152,"address":[340979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[342356,341024],"length":1,"stats":{"Line":1},"fn_name":"parse_query"},{"line":158,"address":[342255,341111,341052,341224],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[341324,341238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[341409,341300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[341652,341753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[341729,341844,342265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[342097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[341122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[342416],"length":1,"stats":{"Line":1},"fn_name":"msg_type"},{"line":172,"address":[342425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[342454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[342461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[342468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[342475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[344017,342496,344040],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":183,"address":[342518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[342526,342737,342588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[342886,342705,343040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[343215,343002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[343256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[343221,343312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[343353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[343408,343665,343318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":192,"address":[343447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[343507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[344012,343924,343414,343674],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[343706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[343766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[343933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[343680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[348880,349527],"length":1,"stats":{"Line":1},"fn_name":"parse_struct_message"},{"line":293,"address":[280555,280512,281243],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":294,"address":[280574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[280800,281486,281472,280709,280594],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":296,"address":[280730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[280812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[280937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[280969,281036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[281208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[281326,281307,280910],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[281328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[281318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[280688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[348987,349131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[349083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[349290,349223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[349332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[349301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[349603,349213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[349733,349645,349994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[349653,349726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[349983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[350287],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":83,"coverable":102},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","strip_generics.rs"],"content":"use syn::fold::Fold;\n\n/// Removes all generics from type assumning default values for it\npub struct StripGenerics;\n\nimpl Fold for StripGenerics {\n    fn fold_path_arguments(\u0026mut self, _: syn::PathArguments) -\u003e syn::PathArguments {\n        syn::PathArguments::None\n    }\n}\n","traces":[{"line":7,"address":[2460608],"length":1,"stats":{"Line":1},"fn_name":"fold_path_arguments"},{"line":8,"address":[2460636],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","strip_input.rs"],"content":"use syn::fold::{self, Fold};\nuse syn::punctuated::Punctuated;\nuse syn::{FnArg, ImplItemMethod, ItemImpl, PatType, Receiver, Signature, Token, TraitItemMethod};\n\n/// Utility for stripping all attributes from input before it is emitted\npub struct StripInput;\n\nfn remove_input_attr(inputs: Punctuated\u003cFnArg, Token![,]\u003e) -\u003e Punctuated\u003cFnArg, Token![,]\u003e {\n    inputs\n        .into_iter()\n        .map(|input| match input {\n            syn::FnArg::Receiver(rec) if !rec.attrs.is_empty() =\u003e {\n                let rec = Receiver {\n                    attrs: vec![],\n                    ..rec\n                };\n                syn::FnArg::Receiver(rec)\n            }\n            syn::FnArg::Typed(ty) if !ty.attrs.is_empty() =\u003e {\n                let ty = PatType {\n                    attrs: vec![],\n                    ..ty\n                };\n                syn::FnArg::Typed(ty)\n            }\n            _ =\u003e input,\n        })\n        .collect()\n}\n\nimpl Fold for StripInput {\n    fn fold_trait_item_method(\u0026mut self, i: TraitItemMethod) -\u003e TraitItemMethod {\n        let attrs = i\n            .attrs\n            .into_iter()\n            .filter(|attr| !attr.path.is_ident(\"msg\"))\n            .collect();\n\n        let inputs = remove_input_attr(i.sig.inputs);\n        let sig = Signature { inputs, ..i.sig };\n        fold::fold_trait_item_method(self, TraitItemMethod { attrs, sig, ..i })\n    }\n\n    fn fold_impl_item_method(\u0026mut self, i: ImplItemMethod) -\u003e ImplItemMethod {\n        let attrs = i\n            .attrs\n            .into_iter()\n            .filter(|attr| !attr.path.is_ident(\"msg\"))\n            .collect();\n\n        let inputs = remove_input_attr(i.sig.inputs);\n        let sig = Signature { inputs, ..i.sig };\n        fold::fold_impl_item_method(self, ImplItemMethod { attrs, sig, ..i })\n    }\n\n    fn fold_item_impl(\u0026mut self, i: ItemImpl) -\u003e ItemImpl {\n        let attrs = i\n            .attrs\n            .into_iter()\n            .filter(|attr| !(attr.path.is_ident(\"messages\") || attr.path.is_ident(\"error\")))\n            .collect();\n\n        fold::fold_item_impl(self, ItemImpl { attrs, ..i })\n    }\n}\n","traces":[{"line":8,"address":[2460800],"length":1,"stats":{"Line":1},"fn_name":"remove_input_attr"},{"line":9,"address":[2460814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[1622237,1622719,1621710,1621680],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":12,"address":[1621768,1622265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[1622407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1622342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[1622511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[1621939,1621887,1621803],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[1622050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[1621982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1622128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[1621903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[2462175,2461963,2460912],"length":1,"stats":{"Line":1},"fn_name":"fold_trait_item_method"},{"line":33,"address":[2461166,2460947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[1622768,1622793],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":39,"address":[2461203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2461304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2461716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[2463323,2462208,2463570],"length":1,"stats":{"Line":1},"fn_name":"fold_impl_item_method"},{"line":45,"address":[2462478,2462243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1622857,1622832],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":51,"address":[2462515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2462616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2463031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2463616,2464322,2464251],"length":1,"stats":{"Line":1},"fn_name":"fold_item_impl"},{"line":57,"address":[2463651,2463814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[1622896,1622921],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":63,"address":[2463853],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":28},{"path":["/","home","janw","workspace","confio","sylvia","sylvia-derive","src","utils.rs"],"content":"use proc_macro_error::emit_error;\nuse syn::spanned::Spanned;\nuse syn::visit::Visit;\nuse syn::{\n    FnArg, GenericArgument, GenericParam, PathArguments, PathSegment, ReturnType, Signature, Type,\n    WhereClause, WherePredicate,\n};\n\nuse crate::check_generics::CheckGenerics;\nuse crate::message::MsgField;\n\npub fn filter_wheres\u003c'a\u003e(\n    clause: \u0026'a Option\u003cWhereClause\u003e,\n    generics: \u0026[\u0026GenericParam],\n    used_generics: \u0026[\u0026GenericParam],\n) -\u003e Vec\u003c\u0026'a WherePredicate\u003e {\n    clause\n        .as_ref()\n        .map(|clause| {\n            clause\n                .predicates\n                .iter()\n                .filter(|pred| {\n                    let mut generics_checker = CheckGenerics::new(generics);\n                    generics_checker.visit_where_predicate(pred);\n                    generics_checker\n                        .used()\n                        .into_iter()\n                        .all(|gen| used_generics.contains(\u0026gen))\n                })\n                .collect()\n        })\n        .unwrap_or_default()\n}\n\npub fn process_fields\u003c's\u003e(\n    sig: \u0026's Signature,\n    generics_checker: \u0026mut CheckGenerics,\n) -\u003e Vec\u003cMsgField\u003c's\u003e\u003e {\n    sig.inputs\n        .iter()\n        .skip(2)\n        .filter_map(|arg| match arg {\n            FnArg::Receiver(item) =\u003e {\n                emit_error!(item.span(), \"Unexpected `self` argument\");\n                None\n            }\n\n            FnArg::Typed(item) =\u003e MsgField::new(item, generics_checker),\n        })\n        .collect()\n}\n\npub fn extract_return_type(ret_type: \u0026ReturnType) -\u003e \u0026PathSegment {\n    let ReturnType::Type(_, ty) = ret_type  else {\n            unreachable!()\n        };\n\n    let Type::Path(type_path) = ty.as_ref()  else {\n            unreachable!()\n        };\n    let segments = \u0026type_path.path.segments;\n    assert!(!segments.is_empty());\n    let segment = \u0026segments[0];\n\n    // In case of aliased result user need to define the return type by hand\n    if segment.ident != \"Result\" \u0026\u0026 segment.ident != \"StdResult\" {\n        emit_error!(\n            segment.span(),\n            \"Neither Result nor StdResult found in return type. \\\n                    You might be using aliased return type. \\\n                    Please use #[msg(return_type=\u003cyour_return_type\u003e)]\"\n        );\n    }\n    let PathArguments::AngleBracketed(args) = \u0026segments[0].arguments  else{\n            unreachable!()\n        };\n    let args = \u0026args.args;\n    assert!(!args.is_empty());\n    let GenericArgument::Type(Type::Path(type_path)) = \u0026args[0] else{\n            unreachable!()\n        };\n    let segments = \u0026type_path.path.segments;\n    assert!(!segments.is_empty());\n\n    \u0026segments[0]\n}\n","traces":[{"line":12,"address":[671392],"length":1,"stats":{"Line":1},"fn_name":"filter_wheres"},{"line":17,"address":[671474,671523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[1668240],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":20,"address":[1668323,1668275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[1668645,1668288,1668368,1668672],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":24,"address":[1668401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[1668449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[1668613,1668500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[1668769,1668589,1668752],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[671568],"length":1,"stats":{"Line":1},"fn_name":"process_fields"},{"line":40,"address":[671610,671644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[1668843,1668800],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":44,"address":[1668873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1668881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1669017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1669041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[671696],"length":1,"stats":{"Line":1},"fn_name":"extract_return_type"},{"line":55,"address":[671716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[671797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[671758,671832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[671877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[671844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[671861,671967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[671912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[671997,671945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[672102,672085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[672090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[672043,672226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[672267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[672243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[672251,672355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[672390,672302,672452],"length":1,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[672417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[672468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[672485,672529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[672504],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":41}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>